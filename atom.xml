<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caesar Bao&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-01T14:22:24.914Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Caesar Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>走向自动化：神经网络训练模型加入torch.nn和torch.optim</title>
    <link href="http://yoursite.com/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/"/>
    <id>http://yoursite.com/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/</id>
    <published>2019-04-01T11:45:11.000Z</published>
    <updated>2019-04-01T14:22:24.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将尝试在上一篇博客的训练模型的基础上加入torch.nn包以及torch.optim包来优化我的训练模型，使其在更少的训练次数里得到更好的优化结果。</p><a id="more"></a><h2 id="一、torch-nn包"><a href="#一、torch-nn包" class="headerlink" title="一、torch.nn包"></a>一、torch.nn包</h2><p>Pytorch中torch.nn包提供了很多实现神经网络的具体功能的类，具体本文就不展开讲了，以后肯定会涉及到，本文主要介绍在训练模型里用到的相关函数。<br>测试代码<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">batch_n = 100</span><br><span class="line">hidden_layer = 100</span><br><span class="line">input_data = 1000</span><br><span class="line">output_data = 10</span><br><span class="line"></span><br><span class="line">x = Variable(torch.randn(batch_n, input_data), requires_grad=False)</span><br><span class="line">y = Variable(torch.randn(batch_n, output_data), requires_grad=False)</span><br><span class="line"></span><br><span class="line">models = torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_data, hidden_layer),</span><br><span class="line">torch.nn.ReLU(),</span><br><span class="line">torch.nn.Linear(hidden_layer, output_data))</span><br><span class="line"></span><br><span class="line">epoch_n = 10000</span><br><span class="line">learning_rate = 1e-4</span><br><span class="line">loss_fn = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred = models(x)</span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    if epoch % 1000 == 0:</span><br><span class="line">        print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line">    models.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    for param in models.parameters():</span><br><span class="line">        param.data -= param.grad.data * learning_rate</span><br></pre></td></tr></table></figure><br>测试结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.9800</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.9122</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8534</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8013</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7544</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7119</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6727</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6366</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6031</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.5715</span></span><br></pre></td></tr></table></figure></p><h3 id="1-torch-nn-Sequential"><a href="#1-torch-nn-Sequential" class="headerlink" title="1.torch.nn.Sequential"></a>1.torch.nn.Sequential</h3><p>Sequential类是一种序列容器，通过在容器中嵌套各种实现神经网络中具体功能的类，来完成神经网络模型的搭建。如果说上一篇博客提到的Variable类是将前向传播中的计算过程变成一张计算图，那么Sequential类就是将计算图封装在容器里，更为特殊的是，计算图的每一个步骤在容器里都有自己的名字，因此每一个步骤都可以当作模块单独拿出来调用。模块的命名方式可以是按照数字序列从零开始命名，也可以import一个OrderedDict包以有序字典的形式命名，这种方法的话对每个模块可以自己命名，有点类似于python列表和字典的区别。例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">models = torch<span class="selector-class">.nn</span><span class="selector-class">.Sequential</span>(</span><br><span class="line">    OrderedDict([</span><br><span class="line">        (<span class="string">"Line1"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.Linear</span>(input_data, hidden_layer)),</span><br><span class="line">        (<span class="string">"ReLU1"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.ReLU</span>()),</span><br><span class="line">        (<span class="string">"Line2"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.Linear</span>(hidden_layer, output_data))])</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="2-torch-nn-Linear"><a href="#2-torch-nn-Linear" class="headerlink" title="2.torch.nn.Linear"></a>2.torch.nn.Linear</h3><p>torch.nn.Linear用于定义模型的线性层，即完成不同层之间的线性变换（如模型中输入层和隐藏层以及隐藏层和输出层的线性变换）。Linear有三个参数，分别是输入特征数，输出特征数以及是否使用偏置（默认为True）。Linear会自动生成权重参数和偏置（默认情况），因此在模型中不需要单独定义如w1w2之类的权重参数，并且Linear提供比原先自定义权重参数时使用的randn随机正太分布更好的参数初始化方法，让人放心～</p><h3 id="3-torch-nn-ReLU"><a href="#3-torch-nn-ReLU" class="headerlink" title="3.torch.nn.ReLU"></a>3.torch.nn.ReLU</h3><p>一看名字就是激活函数，先挖一个坑，以后一起讲，不讲可以打我，话放在这里了。</p><h3 id="4-仨常见损失函数"><a href="#4-仨常见损失函数" class="headerlink" title="4.仨常见损失函数"></a>4.仨常见损失函数</h3><p>torch.nn.MSELoss：均方误差函数<br>torch.nn.L1Loss：平均绝对误差函数<br>torch.nn.CrossEntropyLoss：交叉熵函数<br>仨在定义类的对象时都不需要传参，只要在使用实例时输入维度一样的参数即可计算（交叉熵函数要满足交叉熵的计算条件）</p><h3 id="5-torch-nn-parameter"><a href="#5-torch-nn-parameter" class="headerlink" title="5.torch.nn.parameter"></a>5.torch.nn.parameter</h3><p>有点搞不明白，所以看了一下官方的docs：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">r"""A kind of Tensor that is to be considered a module parameter.</span><br><span class="line"></span><br><span class="line">Parameters are :class:`~torch.Tensor` subclasses, that have a</span><br><span class="line">very special property when used <span class="keyword">with</span> :<span class="keyword">class</span>:<span class="string">`Module`</span> s - <span class="keyword">when</span> they<span class="string">'re</span></span><br><span class="line"><span class="string">assigned as Module attributes they are automatically added to the list of</span></span><br><span class="line"><span class="string">its parameters, and will appear e.g. in :meth:`~Module.parameters` iterator.</span></span><br><span class="line"><span class="string">Assigning a Tensor doesn'</span>t have such effect. This <span class="keyword">is</span> because one might</span><br><span class="line">want <span class="keyword">to</span> <span class="keyword">cache</span> <span class="keyword">some</span> <span class="keyword">temporary</span> state, <span class="keyword">like</span> <span class="keyword">last</span> hidden state <span class="keyword">of</span> the RNN, <span class="keyword">in</span></span><br><span class="line">the model. <span class="keyword">If</span> there was <span class="keyword">no</span> such <span class="keyword">class</span> <span class="keyword">as</span> :<span class="keyword">class</span>:<span class="string">`Parameter`</span>, these</span><br><span class="line">temporaries would <span class="keyword">get</span> registered too.</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line"><span class="keyword">data</span> (Tensor): parameter tensor.</span><br><span class="line">requires_grad (<span class="built_in">bool</span>, optional): <span class="keyword">if</span> the parameter requires gradient. See</span><br><span class="line">:<span class="keyword">ref</span>:<span class="string">`excluding-subgraphs`</span> <span class="keyword">for</span> more details. <span class="keyword">Default</span>: <span class="string">`True`</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><br>看着像是一个迭代器，也就是说在使用torch.nn包中的类进行神经网络的搭建之后，网络的参数都会保存在parameters()函数当中，访问models中的参数是对models.parameters()进行遍历完成的，然后才对每个遍历的参数进行更新。</p><h3 id="6"><a href="#6" class="headerlink" title="6.???"></a>6.???</h3><p>我一开始在看代码的时候发现<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">models</span><span class="selector-class">.zero_grad</span>()</span><br></pre></td></tr></table></figure><br>这个梯度置零的函数放的位置不太对，然后试着把它注释掉，结果一运行发现：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1.0549</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2391</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2478</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.1410</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.1171</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0837</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0743</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0634</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0581</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0590</span></span><br></pre></td></tr></table></figure><br>误差降低了十倍？<br>这超出了我的知识范围……希望以后有能力解答这个问题……<br><img src="/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/1.jpg"></p><h2 id="二、torch-optim"><a href="#二、torch-optim" class="headerlink" title="二、torch.optim"></a>二、torch.optim</h2><p>我的训练模型到现在仍在自定义学习速率，这是因为输出层只有一个比较简单导致的。如果网络一复杂仍然自定义学习速率来进行权重参数的更新是非常不现实的，torch.optim包中正好提供了很多自动优化的类，下面介绍其中的Adam类。</p><p>测试代码<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">batch_n = 100</span><br><span class="line">hidden_layer = 100</span><br><span class="line">input_data = 1000</span><br><span class="line">output_data = 10</span><br><span class="line"></span><br><span class="line">x = Variable(torch.randn(batch_n, input_data), requires_grad=False)</span><br><span class="line">y = Variable(torch.randn(batch_n, output_data), requires_grad=False)</span><br><span class="line"></span><br><span class="line">models = torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_data, hidden_layer), torch.nn.ReLU(),</span><br><span class="line">torch.nn.Linear(hidden_layer, output_data))</span><br><span class="line"></span><br><span class="line">epoch_n = 100</span><br><span class="line">learning_rate = 1e-4</span><br><span class="line">loss_fn = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.Adam(models.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred = models(x)</span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    if epoch % 10 == 0:</span><br><span class="line">        print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><br>测试结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1.0926</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8934</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:20</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7386</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:30</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6166</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:40</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.5177</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:50</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.4355</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:60</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.3654</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:70</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.3050</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:80</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2525</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:90</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2068</span></span><br></pre></td></tr></table></figure><br>仅仅100次就达到了比优化前10000次更好的效果</p><h3 id="1-torch-optim-Adam"><a href="#1-torch-optim-Adam" class="headerlink" title="1.torch.optim.Adam"></a>1.torch.optim.Adam</h3><p>torch.optim.Adam类有两个参数，分别是需要被优化的参数和学习速率（默认为1e-2）。Adam的表现之所以这么优秀，是因为它可以做到使学习速率自适应调节，达到最好的速率。<br>加入优化算法，每次训练的梯度更新可以写成<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.<span class="built_in">step</span>()</span><br></pre></td></tr></table></figure></p><h3 id="2"><a href="#2" class="headerlink" title="2.???"></a>2.???</h3><p>注释掉梯度置零函数<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">optimizer</span><span class="selector-class">.zero_grad</span>()</span><br></pre></td></tr></table></figure><br>好像训练效果又好了那么一点点……<br><img src="/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/2.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将尝试在上一篇博客的训练模型的基础上加入torch.nn包以及torch.optim包来优化我的训练模型，使其在更少的训练次数里得到更好的优化结果。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>简单训练模型加入autograd实现自动梯度计算</title>
    <link href="http://yoursite.com/2019/03/31/Pytorch-A-Simple-Neural-Networks-With-Autograd/"/>
    <id>http://yoursite.com/2019/03/31/Pytorch-A-Simple-Neural-Networks-With-Autograd/</id>
    <published>2019-03-31T10:40:23.000Z</published>
    <updated>2019-03-31T11:25:05.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天的训练模型将在昨天的训练模型基础上做出改进，通过Pytorch中的autograd包替代后向传播中的手动链式求导，实现自动梯度功能。<br>（昨天的后向传播部分写的非常简略，主要是里面有个.t()函数一直查不出来是干啥用的……感觉自己理解的也非常模糊，只知道是在求偏导数……幸好有autograd可以掩盖我的无知……）</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> torch</span><br><span class="line"></span><br><span class="line">from torch.autograd <span class="built_in">import</span> Variable</span><br><span class="line"><span class="attr">batch_n</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">hidden_layer</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">input_data</span> = <span class="number">1000</span></span><br><span class="line"><span class="attr">output_data</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">x</span> = Variable(torch.randn(batch_n, input_data), <span class="attr">requires_grad=False)</span></span><br><span class="line"><span class="attr">y</span> = Variable(torch.randn(batch_n, output_data), <span class="attr">requires_grad=False)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">w1</span> = Variable(torch.randn(input_data, hidden_layer), <span class="attr">requires_grad=True)</span></span><br><span class="line"><span class="attr">w2</span> = Variable(torch.randn(hidden_layer, output_data), <span class="attr">requires_grad=True)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">epoch_n</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">learning_rate</span> = <span class="number">1</span>e-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">for epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line">    <span class="attr">y_pred</span> = x.mm(w1).clamp(<span class="attr">min=0).mm(w2)</span></span><br><span class="line">    <span class="attr">loss</span> = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    w1.data <span class="attr">-=</span> learning_rate * w1.grad.data</span><br><span class="line">    w2.data <span class="attr">-=</span> learning_rate * w2.grad.data</span><br><span class="line"></span><br><span class="line">    w1.grad.data.zero_()</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:46125084.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:97735776.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:353886400.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:681477440.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:70418120.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:19572480.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:10264789.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:6297184.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:4209952.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2988804.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2225728.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:11</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1726369.1250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:12</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1387307.2500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:13</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1149427.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:14</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:977541.5625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:15</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:849593.3125</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:16</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:751535.7500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:17</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:674315.6875</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:18</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:611959.5625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:19</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:560407.1250</span></span><br></pre></td></tr></table></figure><br>由于在定义输入层和输出层时使用的是randn随即正态分布函数，运行结果会有很大不同，我挑了一组比较明显的结果。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>torch.grad包u实现自动梯度的过程大致为先通过定义的Tensor类型数据变量在前向传播中生成计算图，然后根据计算图和输出结果计算出每个参数需要更新的梯度，并通过后向传播完成对参数的梯度更新。<br>开头需要导入torch.grad包中的Variable类从而对Tensor数据类型变量进行封装。在计算图中，每个节点都应该是Variable类型的对象，这样才能应用自动梯度的功能。<br>requires_grad一看名字就知道，决定了Variable类型是否需要计算梯度，w1、w2是权重参数，所以为True。<br>.backward()函数根据我们自己设置的需求求出梯度值并保留，再结合学习速率对权重参数进行更新，最后通过.zero_()函数对grad.data进行置零，否则梯度值会一直累加，影响后边儿计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天的训练模型将在昨天的训练模型基础上做出改进，通过Pytorch中的autograd包替代后向传播中的手动链式求导，实现自动梯度功能。&lt;br&gt;（昨天的后向传播部分写的非常简略，主要是里面有个.t()函数一直查不出来是干啥用的……感觉自己理解的也非常模糊，只知道是在求偏导数……幸好有autograd可以掩盖我的无知……）&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>入门神经网络训练模型搭建</title>
    <link href="http://yoursite.com/2019/03/30/Pytorch-A-Simple-Neural-Networks/"/>
    <id>http://yoursite.com/2019/03/30/Pytorch-A-Simple-Neural-Networks/</id>
    <published>2019-03-30T12:54:32.000Z</published>
    <updated>2019-03-31T11:25:17.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天试着搭建一个小的神经网络训练模型，通过训练会使预测值和真实值逐渐逼近。</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#一次输入数据的数量 即100组数据</span></span><br><span class="line"><span class="attr">batch_n</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#每组数据的数据特征数</span></span><br><span class="line"><span class="attr">input_data</span> = <span class="number">1000</span></span><br><span class="line"><span class="comment">#数据经过隐藏层后保留的数据特征的个数（只考虑一层隐藏层）</span></span><br><span class="line"><span class="attr">hidden_layer</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#每组输出数据的数据特征数</span></span><br><span class="line"><span class="attr">output_data</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入层和输出层</span></span><br><span class="line"><span class="attr">x</span> = torch.randn(batch_n, input_data)</span><br><span class="line"><span class="attr">y</span> = torch.randn(batch_n, output_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入层到隐藏层的权重参数和隐藏层到输出层的权重参数</span></span><br><span class="line"><span class="attr">w1</span> = torch.randn(input_data, hidden_layer)</span><br><span class="line"><span class="attr">w2</span> = torch.randn(hidden_layer, output_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练次数</span></span><br><span class="line"><span class="attr">epoch_n</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">#学习速率</span></span><br><span class="line"><span class="attr">learning_rate</span> = <span class="number">1</span>e-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">for epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line">    <span class="attr">h1</span> = x.mm(w1)</span><br><span class="line">    <span class="attr">h1</span> = h1.clamp(<span class="attr">min=0)</span></span><br><span class="line">    <span class="attr">y_pred</span> = h1.mm(w2)</span><br><span class="line"></span><br><span class="line">    <span class="attr">loss</span> = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss))</span><br><span class="line"></span><br><span class="line">    <span class="attr">grad_y_pred</span> = <span class="number">2</span> * (y_pred - y)</span><br><span class="line">    <span class="attr">grad_w2</span> = h1.t().mm(grad_y_pred)</span><br><span class="line"></span><br><span class="line">    <span class="attr">grad_h</span> = grad_y_pred.clone()</span><br><span class="line">    <span class="attr">grad_h</span> = grad_h.mm(w2.t())</span><br><span class="line">    grad_h.clamp_(<span class="attr">min=0)</span></span><br><span class="line">    <span class="attr">grad_w1</span> = x.t().mm(grad_h)</span><br><span class="line"></span><br><span class="line">    w1 <span class="attr">-=</span> learning_rate * grad_w1</span><br><span class="line">    w2 <span class="attr">-=</span> learning_rate * grad_w2</span><br></pre></td></tr></table></figure><p>测试结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:58291408.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:159056992.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:521834688.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:522471264.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:4316087.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:3243381.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2620373.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2226943.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1957315.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1758743.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1603234.8750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:11</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1475709.2500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:12</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1367604.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:13</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1273678.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:14</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1190754.3750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:15</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1116698.3750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:16</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1049910.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:17</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:989398.0625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:18</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:934201.0625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:19</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:883768.8750</span></span><br></pre></td></tr></table></figure></p><h2 id="一、前向传播"><a href="#一、前向传播" class="headerlink" title="一、前向传播"></a>一、前向传播</h2><p>26-28行其实就是用输入层进入隐藏层再进入输出层的整个过程了，通过mm函数（注意不是mul函数）实现了数据特征从1000到100到10的变化，在计算过程中还对矩阵的乘积使用clamp函数进行裁剪，将小于0的数赋值为0（clamp函数本来有3个参数，分别是需要进行裁剪的Tensor变量，裁剪的上边界和下边界，在这里需要裁剪的变量是其本身，只定义下边界不定义上边界是为了实现ReLU激活函数的功能，但并不完全等于ReLU激活函数）<br>30-31行计算损失函数并打印，这里使用的是均方误差的计算方法，给个图：<br><img src="/2019/03/30/Pytorch-A-Simple-Neural-Networks/1.jpg"><br>求出来是真实值和预测值的差值的平方和。</p><h2 id="二、后向传播"><a href="#二、后向传播" class="headerlink" title="二、后向传播"></a>二、后向传播</h2><p>后向传播主要是为了对权重值w进行优化。<br>33-39行grad_w1和grad_w2是更新的权重梯度值。（梯度就是多元函数的偏导数以向量形式表示）<br>41-42行在得到参数的梯度值之后，按照设置好的学习速率对权重值进行更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天试着搭建一个小的神经网络训练模型，通过训练会使预测值和真实值逐渐逼近。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>基本是最终版本的小工程</title>
    <link href="http://yoursite.com/2019/03/27/OpenCV-Learning-Day-17/"/>
    <id>http://yoursite.com/2019/03/27/OpenCV-Learning-Day-17/</id>
    <published>2019-03-27T06:37:24.000Z</published>
    <updated>2019-03-31T11:25:30.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天角度定位的问题解决了……角度还是算不出来，我调整了几个函数，在图像旋转之后再次使用Rotate()函数得到外接矩形的点阵信息，然后标记ROI图形区域裁剪图像并用imwrite()函数读出。</p><a id="more"></a><h2 id="基本是最终版本的测试代码"><a href="#基本是最终版本的测试代码" class="headerlink" title="基本是最终版本的测试代码"></a>基本是最终版本的测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> angle;</span><br><span class="line">Point2f rect[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Mat&amp; img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutImage</span><span class="params">(Mat&amp; img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveImage</span><span class="params">(Mat&amp; img,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBorder</span><span class="params">(Mat&amp; src,Mat&amp; dst,<span class="keyword">int</span> B,<span class="keyword">int</span> G,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        makeBorder(images[i],images[i],<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        Rotate(images[i],images[i],angle);</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        <span class="comment">//drawLine(images[i]);</span></span><br><span class="line">        cutImage(images[i]);</span><br><span class="line">        saveImage(images[i],i);</span><br><span class="line">        imshow(<span class="string">"image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(dstImage, dstImage, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(dstImage, dstImage, <span class="number">254</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="comment">//imshow("srcImage", dstImage);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(dstImage, contours, hierarcy, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line">    sort(contours.begin(),contours.end(),ContoursSortFunction);</span><br><span class="line">    contours.erase(contours.begin());</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i])); </span><br><span class="line">        box[i].points(rect); </span><br><span class="line">        angle = box[i].angle;</span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; 4; j++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; rect[j] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (contourArea(contour1) &gt; contourArea(contour2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>&#123;</span><br><span class="line">    makeBorder(src,dst,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//rotate</span></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">( (<span class="keyword">float</span>)(dst.cols/<span class="number">2</span>) , (<span class="keyword">float</span>) (dst.rows/<span class="number">2</span>))</span></span>;</span><br><span class="line">    Mat affine_matrix = getRotationMatrix2D( center, angle, <span class="number">1.0</span> );</span><br><span class="line">    warpAffine(dst, dst, affine_matrix, dst.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Mat&amp; img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        line(img, rect[i], rect[(i+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">2</span>,LINE_AA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutImage</span><span class="params">(Mat&amp; img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = rect[<span class="number">2</span>].x - rect[<span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">int</span> height = rect[<span class="number">0</span>].y - rect[<span class="number">1</span>].y;</span><br><span class="line">    Mat ROI = img(Rect(rect[<span class="number">1</span>].x,rect[<span class="number">1</span>].y,width,height));</span><br><span class="line">    ROI.copyTo(img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveImage</span><span class="params">(Mat&amp; img,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(path,<span class="string">"./outputImages/%d.jpg"</span>,i);</span><br><span class="line">    imwrite(path,img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBorder</span><span class="params">(Mat&amp; src,Mat&amp; dst,<span class="keyword">int</span> B,<span class="keyword">int</span> G,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxBorder =(<span class="keyword">int</span>) (max(src.cols, src.rows)* <span class="number">1.414</span>);</span><br><span class="line">    <span class="keyword">int</span> dx = (maxBorder - src.cols)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> dy = (maxBorder - src.rows)/<span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, dy, dy, dx, dx, BORDER_CONSTANT,Scalar(B,G,R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>测试图没啥好看的，老师发的零件图片，效果图也不贴了（不是我懒）<br>并无新函数，但就这玩意儿我写了三天……后面算是整理的比较清楚了，功能基本上都写在函数里了，就酱。<br>开始学习Pytorch。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天角度定位的问题解决了……角度还是算不出来，我调整了几个函数，在图像旋转之后再次使用Rotate()函数得到外接矩形的点阵信息，然后标记ROI图形区域裁剪图像并用imwrite()函数读出。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>warpAffine()函数实现最小外接矩形和原始图像平行</title>
    <link href="http://yoursite.com/2019/03/26/OpenCV-Learning-Day-16/"/>
    <id>http://yoursite.com/2019/03/26/OpenCV-Learning-Day-16/</id>
    <published>2019-03-26T12:26:09.000Z</published>
    <updated>2019-03-31T11:25:42.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来今天想一并吧图像的旋转和裁剪给一起完成了，但是图像在旋转之后的坐标定位一直有问题，所以今天只好放出在昨天的博客的基础上做的图像旋转的函数，旋转之后目标图像的最小外接矩形是和原始图像平行的，为的是设置ROI为裁剪图像做准备。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> angle;</span><br><span class="line">Point pointlu;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        Rotate(images[i],images[i],angle);</span><br><span class="line">        imshow(<span class="string">"image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(dstImage, dstImage, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(dstImage, dstImage, <span class="number">254</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="comment">//imshow("srcImage", dstImage);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(dstImage, contours, hierarcy, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line">    sort(contours.begin(),contours.end(),ContoursSortFunction);</span><br><span class="line">    contours.erase(contours.begin());</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); <span class="comment">//定义最小外接矩形集合</span></span><br><span class="line">    Point2f rect[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i])); <span class="comment">//计算每个轮廓最小外接矩形</span></span><br><span class="line">        box[i].points(rect); <span class="comment">//把最小外接矩形四个端点复制给rect数组</span></span><br><span class="line">        angle = box[i].angle;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            line(srcImg, rect[j], rect[(j+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)); <span class="comment">//绘制最小外接矩形每条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (contourArea(contour1) &gt; contourArea(contour2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fill</span></span><br><span class="line">    <span class="keyword">int</span> maxBorder =(<span class="keyword">int</span>) (max(src.cols, src.rows)* <span class="number">1.414</span>); <span class="comment">//即为sqrt(2)*max</span></span><br><span class="line">    <span class="keyword">int</span> dx = (maxBorder - src.cols)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> dy = (maxBorder - src.rows)/<span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, dy, dy, dx, dx, BORDER_CONSTANT,Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//rotate</span></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">( (<span class="keyword">float</span>)(dst.cols/<span class="number">2</span>) , (<span class="keyword">float</span>) (dst.rows/<span class="number">2</span>))</span></span>;</span><br><span class="line">    Mat affine_matrix = getRotationMatrix2D( center, angle, <span class="number">1.0</span> );<span class="comment">//求得旋转矩阵</span></span><br><span class="line">    warpAffine(dst, dst, affine_matrix, dst.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、copyMakeBorder-边缘扩充函数"><a href="#一、copyMakeBorder-边缘扩充函数" class="headerlink" title="一、copyMakeBorder()边缘扩充函数"></a>一、copyMakeBorder()边缘扩充函数</h2><p>函数原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyMakeBorder</span>(<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; src, Mat&amp; dst,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> top, <span class="keyword">int</span> bottom, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType, <span class="keyword">const</span> Scalar&amp; <span class="keyword">value</span>=Scalar(</span>)</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>第一个参数和第二个参数分别是输入图像和输出图像<br>top、bottom、left、right参数非常明显，分别是顶端、底部、左边和右边所需填充的距离<br>borderType：扩充边缘的类型，就是外插的类型，OpenCV中给出以下几种方式<br>BORDER_REPLICATE 对边界像素进行复制<br>BORDER_REFLECT 对感兴趣的图像中的像素在两边分别进行复制，也就是左右各复制一次<br>BORDER_REFLECT_101 只复制一次，左右各占一半<br>BORDER_WRAP 外包装（？）<br>BORDER_CONSTANT 常量，选择这种方式的时候，需要用到最后一个参数为扩充的边缘选择颜色</p><h2 id="二、warpAffine-旋转函数"><a href="#二、warpAffine-旋转函数" class="headerlink" title="二、warpAffine()旋转函数"></a>二、warpAffine()旋转函数</h2><p>函数原型：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void warpAffine(</span><br><span class="line">    InputArray src,</span><br><span class="line">    OutputArray dst,</span><br><span class="line">    InputArray M,</span><br><span class="line">    Size dsize,</span><br><span class="line">    int flags = INTER_LINEAR,</span><br><span class="line">    int <span class="keyword">borderMode </span>= <span class="keyword">BORDER_CONSTANT,</span></span><br><span class="line"><span class="keyword"> </span>   const <span class="keyword">Scalar </span>&amp; <span class="keyword">borderValue </span>= <span class="keyword">Scalar() </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>src: 输入图像<br>dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致<br>M: 2X3的变换矩阵<br>dsize: 指定图像输出尺寸<br>flags: 插值算法标识符，有默认值INTER_LINEAR<br>borderMode: 边界像素模式，有默认值BORDER_CONSTANT<br>borderValue: 边界取值，有默认值Scalar()即0</p><h2 id="三、getRotationMatrix2D-旋转图像矩阵取得函数"><a href="#三、getRotationMatrix2D-旋转图像矩阵取得函数" class="headerlink" title="三、getRotationMatrix2D()旋转图像矩阵取得函数"></a>三、getRotationMatrix2D()旋转图像矩阵取得函数</h2><p>warpAffine()函数的InputArrey M的取得需要用到这个函数<br>函数原型：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat getRotationMatrix2D(</span><br><span class="line">    Point2f center, </span><br><span class="line">    <span class="keyword">double</span> angle, </span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">scale</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>center: Point2f类型，表示原图像的旋转中心<br>angle: double类型，表示图像旋转角度，角度为正则表示逆时针旋转，角度为负表示逆时针旋转（坐标原点是图像左上角）<br>scale: 缩放系数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来今天想一并吧图像的旋转和裁剪给一起完成了，但是图像在旋转之后的坐标定位一直有问题，所以今天只好放出在昨天的博客的基础上做的图像旋转的函数，旋转之后目标图像的最小外接矩形是和原始图像平行的，为的是设置ROI为裁剪图像做准备。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>最小外接矩形（不完美）</title>
    <link href="http://yoursite.com/2019/03/25/OpenCV-Learning-Day-15/"/>
    <id>http://yoursite.com/2019/03/25/OpenCV-Learning-Day-15/</id>
    <published>2019-03-25T13:56:14.000Z</published>
    <updated>2019-03-31T11:25:52.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节结合前面一章的批处理函数glob()，进行图像的最小外接矩形的描绘（实际效果不太完美）。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/DeepLearning/OpenCV/*.jpeg"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(srcImg, srcImg, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(srcImg, srcImg, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(srcImg, contours, hierarcy, RETR_EXTERNAL, CHAIN_APPROX_NONE);</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); <span class="comment">//定义最小外接矩形集合</span></span><br><span class="line">    Point2f rect[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;contours.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i]));  <span class="comment">//计算每个轮廓最小外接矩形</span></span><br><span class="line">        box[i].points(rect);  <span class="comment">//把最小外接矩形四个端点复制给rect数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            line(dstImage, rect[j], rect[(j+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, LINE_AA);  <span class="comment">//绘制最小外接矩形每条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Image"</span>,dstImage);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br>（可以看到第二张图明显识别出了问题……）<br><img src="/2019/03/25/OpenCV-Learning-Day-15/1.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/2.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/3.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/4.jpg"></p><h2 id="一、findContours-轮廓扫描函数"><a href="#一、findContours-轮廓扫描函数" class="headerlink" title="一、findContours()轮廓扫描函数"></a>一、findContours()轮廓扫描函数</h2><p>函数原型：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">findContours( </span><br><span class="line">    InputOutputArray image, </span><br><span class="line">    OutputArrayOfArrays contours,           </span><br><span class="line">    OutputArray hierarchy, </span><br><span class="line">    int mode,            </span><br><span class="line">    int <span class="function"><span class="keyword">method</span>, </span></span><br><span class="line"><span class="function">    <span class="title">Point</span> <span class="title">offset</span>=<span class="title">Point</span><span class="params">()</span></span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>第一个参数是输入图像，这里有很大一个坑，输入图像必须是八位单通道图像（即8UC1），在函数中被认为是一个二值化图像（即所有非零元素都被视作是相等的，非0即1），但如果mode是CV_RETR_CCOMP 或者 CV_RETR_FLOODFILL，输入图像也可以是32位的整型图像(CV_32SC1)。<br>第二个参数是二维vector数组，这里将使用找到的轮廓的列表进行填充（即，这将是一个contours的vector,其中contours[i]表示一个特定的轮廓，这样，contours[i][j]将表示contour[i]的一个特定的端点）。<br>第三个参数可以指定，也可以不提指定。如果指定的话，输出hierarchy，将会描述输出轮廓树的结构信息。（Vec4i是Vec&lt;int,4&gt;的别名，定义了一个“向量内每一个元素包含了4个int型变量”的向量）<br>第四个参数将会告诉OpenCV你想用何种方式来对轮廓进行提取<br>RETR_EXTERNAL：表示只提取最外面的轮廓；<br>RETR_LIST：表示提取所有轮廓并将其放入列表；<br>RETR_CCOMP:表示提取所有轮廓并将组织成一个两层结构，其中顶层轮廓是外部轮廓，第二层轮廓是“洞”的轮廓；<br>RETR_TREE：表示提取所有轮廓并组织成轮廓嵌套的完整层级结构。<br>第五个参数给出轮廓如何呈现的方法<br>CHAIN_APPROX_NONE：将轮廓中的所有点的编码转换成点；<br>CHAIN_APPROX_SIMPLE：压缩水平、垂直和对角直线段，仅保留它们的端点；</p><p>CHAIN_APPROX_TC89_L1 or CHAIN_APPROX_TC89_KCOS：应用Teh-Chin链近似算法中的一种风格</p><h2 id="二、minAreaRect-函数"><a href="#二、minAreaRect-函数" class="headerlink" title="二、minAreaRect()函数"></a>二、minAreaRect()函数</h2><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RotatedRect minAreaRect(<span class="name">InputArray</span> points)</span><br></pre></td></tr></table></figure><br>第一个参数可以输入点阵容器（vector）或者Mat类型的图像，这里很坑的是，如果参数是Mat类型必须满足depth == CV_32F || depth == CV_32S，且checkVector(2)才可以，否则会报错（minAreaRect()中主要调用的求凸包的函数convexHull()会检查Mat满不满足上面的条件）。<br>Mat::depth()函数：求矩阵中元素的一个通道的数据类型，这个值和type是相关的。<br>Mat::checkVector()函数：当Mat的channels,depth,和连续性  满足checkVector的参数内容时,返回(int)(total()*channels()/_elemChannels), 否则返回-1。checkVector(2)，要求矩阵的列数位2。<br>（我就是因为minAreaRect()中的Mat类总是报错才怒转findContours()函数的，然而测试代码的视线效果并不完美，有待改进）</p><h2 id="三、RotatedRect类"><a href="#三、RotatedRect类" class="headerlink" title="三、RotatedRect类"></a>三、RotatedRect类</h2><p>RotatedRect类常用于配合minAreaRect()函数的计算（因为minAreaRect()函数的返回类型就是RotatedRect类）<br>函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">RotatedRect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    RotatedRect();</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> Point2f&amp; center, <span class="keyword">const</span> Size2f&amp; size, <span class="keyword">float</span> angle);</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> CvBox2D&amp; box);</span><br><span class="line">    <span class="comment">//! returns 4 vertices of the rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">points</span><span class="params">(Point2f pts[])</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! returns the minimal up-right rectangle containing the rotated rectangle</span></span><br><span class="line">    <span class="function">Rect <span class="title">boundingRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvBox2D structure</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvBox2D</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Point2f center; <span class="comment">//&lt; the rectangle mass center</span></span><br><span class="line">    Size2f size; <span class="comment">//&lt; width and height of the rectangle</span></span><br><span class="line">    <span class="keyword">float</span> angle; <span class="comment">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>RotatedRect类中定义了矩形的中心点center、尺寸size（包括width、height）、旋转角度angle共3个成员变量；<br>points()函数用于求矩形的4个顶点，boundingRect()函数求包含最小外接矩形的，与坐标轴平行（或垂直）的最小矩形。<br>参考博文：<br><blockquote><footer><strong>OpenCV 中boundingRect、minAreaRect的用法区别</strong><cite><a href="https://blog.csdn.net/u013925378/article/details/84563011" target="_blank" rel="noopener">blog.csdn.net/u013925378/article/details/84563011</a></cite></footer></blockquote><br><blockquote><footer><strong>Opencv轮廓检测findContours分析（层次结构）</strong><cite><a href="https://www.jianshu.com/p/4bc3349b4611" target="_blank" rel="noopener">www.jianshu.com/p/4bc3349b4611</a></cite></footer></blockquote><br><blockquote><footer><strong>【OpenCV3】图像轮廓查找与绘制——cv::findContours()与cv::drawContours()详解</strong><cite><a href="https://blog.csdn.net/guduruyu/article/details/69220296" target="_blank" rel="noopener">blog.csdn.net/guduruyu/article/details/69220296</a></cite></footer></blockquote><br><blockquote><footer><strong>Opencv RotatedRect类中的points、angle、width、height等详解</strong><cite><a href="https://blog.csdn.net/mailzst1/article/details/83141632" target="_blank" rel="noopener">blog.csdn.net/mailzst1/article/details/83141632</a></cite></footer></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章节结合前面一章的批处理函数glob()，进行图像的最小外接矩形的描绘（实际效果不太完美）。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>批处理函数和二值化函数</title>
    <link href="http://yoursite.com/2019/03/24/OpenCV-Learning-Day-14/"/>
    <id>http://yoursite.com/2019/03/24/OpenCV-Learning-Day-14/</id>
    <published>2019-03-24T12:45:28.000Z</published>
    <updated>2019-03-31T11:25:57.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图像批处理，管进不管出。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        <span class="comment">//cvtColor(images[i],images[i],COLOR_BGR2GRAY);</span></span><br><span class="line">        <span class="comment">//blur(images[i],images[i],Size(5,5));</span></span><br><span class="line">        threshold(images[i],images[i],<span class="number">170</span>,<span class="number">255</span>,THRESH_BINARY);</span><br><span class="line">        imshow(<span class="string">"Image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、glob-批处理函数"><a href="#一、glob-批处理函数" class="headerlink" title="一、glob()批处理函数"></a>一、glob()批处理函数</h2><p>glob()函数可以批处理指定文件夹中的图像，函数目的是将pattern路径下的所用文件名存进&amp;result中<br>函数原型：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glob(<span class="built_in">String</span> pattern, vector&lt;<span class="built_in">String</span>&gt; &amp;result, <span class="built_in">bool</span> recursive = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><br>第一个参数是文件夹的绝对路径<br>第二个参数是存放图片名称和路径的vector容器，需要注意的是该容器必须是OpenCV的String类<br>第三个参数默认是false，当recursive为false时，仅仅遍历指定文件夹内符合模式的文件，当recursive为true时，会同时遍历指定文件夹的子文件夹</p><h2 id="二、threshold-二值化函数"><a href="#二、threshold-二值化函数" class="headerlink" title="二、threshold()二值化函数"></a>二、threshold()二值化函数</h2><p>函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double threshold(</span><br><span class="line">    InputArray src, </span><br><span class="line">    OutputArray dst, </span><br><span class="line">    double thresh, </span><br><span class="line">    double maxval, </span><br><span class="line">    int type</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数和第二个参数分别为输入图像和输出图像<br>thresh参数表示阈值<br>maxval参数表示与THRESH_BINARY和THRESH_BINARY_INV阈值类型一起使用设置的最大值。<br>type参数表示阈值类型：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_BINARY</span> //如果 src(x,y)&gt;threshold ,dst(x,y) = max_value; 否则,dst（x,y）=0;</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_BINARY_INV</span> //如果 src(x,y)&gt;threshold,dst(x,y) = 0; 否则,dst(x,y) = max_value.</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TRUNC</span> //如果 src(x,y)&gt;threshold，dst(x,y) = max_value; 否则dst(x,y) = src(x,y).</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TOZERO</span> //如果src(x,y)&gt;threshold，dst(x,y) = src(x,y) ; 否则 dst(x,y) = 0。</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TOZERO_INV</span> //如果 src(x,y)&gt;threshold，dst(x,y) = 0 ; 否则dst(x,y) = src(x,y)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图像批处理，管进不管出。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>离散傅里叶变换函数的补充</title>
    <link href="http://yoursite.com/2019/03/23/OpenCV-Learning-Day-13/"/>
    <id>http://yoursite.com/2019/03/23/OpenCV-Learning-Day-13/</id>
    <published>2019-03-23T13:30:58.000Z</published>
    <updated>2019-03-31T11:26:02.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的上一篇的博客的关于傅里叶变换的一些函数补充，理解不易，且行且珍惜～</p><a id="more"></a><p>测试代码在上一篇。<br>原图：<br><img src="/2019/03/23/OpenCV-Learning-Day-13/1.jpg"><br>测试图；<br><img src="/2019/03/23/OpenCV-Learning-Day-13/2.jpg"></p><h2 id="一、getOptimalDFTSize-函数"><a href="#一、getOptimalDFTSize-函数" class="headerlink" title="一、getOptimalDFTSize()函数"></a>一、getOptimalDFTSize()函数</h2><p>返回给定向量尺寸经过DFT变换后结果的最优尺寸大小。其函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOptimalDFTSize</span><span class="params">(<span class="keyword">int</span> vecsize)</span></span></span><br></pre></td></tr></table></figure><br>int vecsize: 输入向量尺寸大小(vector size)<br>DFT变换在一个向量尺寸上不是一个单调函数，当计算两个数组卷积或对一个数组进行光学分析，它常常会用0扩充一些数组来得到稍微大点的数组以达到比原来数组计算更快的目的。一个尺寸是2阶指数（2,4,8,16,32……）的数组计算速度最快，一个数组尺寸是2、3、5的倍数（例如：300 = 5*5*3*2*2）同样有很高的处理效率。<br>getOptimalDFTSize()函数返回大于或等于vecsize的最小数值N，这样尺寸为N的向量进行DFT变换能得到更高的处理效率。在当前N通过p，q，r等一些整数得出N = 2^p*3^q*5^r.<br>这个函数不能直接用于DCT（离散余弦变换）最优尺寸的估计，可以通过getOptimalDFTSize((vecsize+1)/2)*2得到。</p><h2 id="二、magnitude-函数"><a href="#二、magnitude-函数" class="headerlink" title="二、magnitude()函数"></a>二、magnitude()函数</h2><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void magnitude(<span class="name">InputArray</span> x, InputArray y, OutputArray magnitude)</span><br></pre></td></tr></table></figure><br>InputArray x: 浮点型数组的x坐标矢量，也就是实部<br>InputArray y: 浮点型数组的y坐标矢量，必须和x尺寸相同<br>OutputArray magnitude: 与x类型和尺寸相同的输出数组 </p><h2 id="三、copyMakeBorder"><a href="#三、copyMakeBorder" class="headerlink" title="三、copyMakeBorder()"></a>三、copyMakeBorder()</h2><p>扩充图像边界，其函数定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyMakeBorder</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray src, </span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> top, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> bottom, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> left, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> right, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Scalar&amp; <span class="keyword">value</span>=Scalar(</span>)</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>InputArray src: 输入图像<br>OutputArray dst: 输出图像，与src图像有相同的类型，其尺寸应为Size(src.cols+left+right, src.rows+top+bottom)<br>int类型的top、bottom、left、right: 在图像的四个方向上扩充像素的值<br>int borderType: 边界类型，由borderInterpolate()来定义，常见的取值为BORDER_CONSTANT<br>const Scalar&amp; value = Scalar(): 如果边界类型为BORDER_CONSTANT则表示为边界值</p><h2 id="四、normalize-函数"><a href="#四、normalize-函数" class="headerlink" title="四、normalize() 函数"></a>四、normalize() 函数</h2><p>归一化就是把要处理的数据经过某种算法的处理限制在所需要的范围内。首先归一化是为了后面数据处理的方便，其次归一化能够保证程序运行时收敛加快。归一化的具体作用是归纳同意样本的统计分布性，归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布，在机器学习算法的数据预处理阶段，归一化也是非常重要的步骤。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void normalize(</span><br><span class="line">    InputArray src, </span><br><span class="line">    OutputArray dst, </span><br><span class="line">    double <span class="attribute">alpha</span>=1, </span><br><span class="line">    double <span class="attribute">beta</span>=0, </span><br><span class="line">    int <span class="attribute">norm_type</span>=NORM_L2, </span><br><span class="line">    int <span class="attribute">dtype</span>=-1, </span><br><span class="line">    InputArray <span class="attribute">mask</span>=noArray()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>InputArray src: 输入图像<br>OutputArray dst: 输出图像，尺寸大小和src相同<br>double alpha = 1: range normalization模式的最小值<br>double beta = 0: range normalization模式的最大值，不用于norm normalization(范数归一化)模式<br>int norm_type = NORM_L2: 归一化的类型，主要有  NORM_INF: 归一化数组的C-范数（绝对值的最大值）<br>NORM_L1: 归一化数组的L1-范数（绝对值的和）<br>NORM_L2: 归一化数组的L2-范数（欧几里得）<br>NORM_MINMAX: 数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。<br>int dtype = -1: 当该参数为负数时，输出数组的类型与输入数组的类型相同，否则输出数组与输入数组只是通道数相同，而depth = CV_MAT_DEPTH(dtype)<br>InputArray mask = noArray(): 操作掩膜版，用于指示函数是否仅仅对指定的元素进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我的上一篇的博客的关于傅里叶变换的一些函数补充，理解不易，且行且珍惜～&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>离散傅里叶变换</title>
    <link href="http://yoursite.com/2019/03/22/OpenCV-Learning-Day-12/"/>
    <id>http://yoursite.com/2019/03/22/OpenCV-Learning-Day-12/</id>
    <published>2019-03-22T12:26:13.000Z</published>
    <updated>2019-03-31T11:26:07.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节学习离散傅里叶变换，好难啊～分两天学习</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcIamge = imread(<span class="string">"3.jpg"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!srcIamge.data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcIamge);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = getOptimalDFTSize(srcIamge.rows);</span><br><span class="line">    <span class="keyword">int</span> n = getOptimalDFTSize(srcIamge.cols);</span><br><span class="line"></span><br><span class="line">    Mat padded;</span><br><span class="line">    copyMakeBorder(srcIamge,padded,<span class="number">0</span>,m - srcIamge.rows,<span class="number">0</span>,n - srcIamge.cols,BORDER_CONSTANT,Scalar::all(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Mat planes[] = &#123;Mat_&lt;<span class="keyword">float</span>&gt;(padded),Mat::zeros(padded.size(),CV_32F)&#125;;</span><br><span class="line">    Mat complexI;</span><br><span class="line">    merge(planes,<span class="number">2</span>,complexI);</span><br><span class="line"></span><br><span class="line">    dft(complexI,complexI);</span><br><span class="line"></span><br><span class="line">    split(complexI,planes);</span><br><span class="line">    magnitude(planes[<span class="number">0</span>],planes[<span class="number">1</span>],planes[<span class="number">0</span>]);</span><br><span class="line">    Mat magnitudeImage = planes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    magnitudeImage = magnitudeImage(Rect(<span class="number">0</span>,<span class="number">0</span>,magnitudeImage.cols &amp; <span class="number">-2</span>,magnitudeImage.rows &amp; <span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">int</span> cx = magnitudeImage.cols / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cy = magnitudeImage.rows / <span class="number">2</span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q0</span><span class="params">(magnitudeImage, Rect(<span class="number">0</span>,<span class="number">0</span>,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q1</span><span class="params">(magnitudeImage, Rect(cx,<span class="number">0</span>,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q2</span><span class="params">(magnitudeImage, Rect(<span class="number">0</span>,cy,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q3</span><span class="params">(magnitudeImage, Rect(cx,cy,cx,cy))</span></span>;</span><br><span class="line"></span><br><span class="line">    Mat tmp;</span><br><span class="line">    q0.copyTo(tmp);</span><br><span class="line">    q3.copyTo(q0);</span><br><span class="line">    tmp.copyTo(q3);</span><br><span class="line">    q1.copyTo(tmp);</span><br><span class="line">    q2.copyTo(q1);</span><br><span class="line">    tmp.copyTo(q2);</span><br><span class="line"></span><br><span class="line">    normalize(magnitudeImage,magnitudeImage,<span class="number">0</span>,<span class="number">1</span>,NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,magnitudeImage);</span><br><span class="line">    waitKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一：dft-函数"><a href="#一：dft-函数" class="headerlink" title="一：dft()函数"></a>一：dft()函数</h2><p>参数解释：<br>第一个参数为输入图像，可以是实数或虚数<br>第二个参数为输出图像，其大小和类型取决于第三个参数flags<br>第三个参数为转换的标识符，有默认值0.其可取的值如下所示：<br>DFT_INVERSE: 用一维或二维逆变换取代默认的正向变换<br>DFT_SCALE: 缩放比例标识符，根据数据元素个数平均求出其缩放结果，如有N个元素，则输出结果以1/N缩放输出，常与DFT_INVERSE搭配使用。<br>DFT_ROWS: 对输入矩阵的每行进行正向或反向的傅里叶变换；此标识符可在处理多种适量的的时候用于减小资源的开销，这些处理常常是三维或高维变换等复杂操作。<br>DFT_COMPLEX_OUTPUT: 对一维或二维的实数数组进行正向变换，这样的结果虽然是复数阵列，但拥有复数的共轭对称性（CCS），可以以一个和原数组尺寸大小相同的实数数组进行填充，这是最快的选择也是函数默认的方法。你可能想要得到一个全尺寸的复数数组（像简单光谱分析等等），通过设置标志位可以使函数生成一个全尺寸的复数输出数组。<br>DFT_REAL_OUTPUT: 对一维二维复数数组进行逆向变换，这样的结果通常是一个尺寸相同的复数矩阵，但是如果输入矩阵有复数的共轭对称性（比如是一个带有DFT_COMPLEX_OUTPUT标识符的正变换结果），便会输出实数矩阵。<br>int nonzeroRows = 0: 当这个参数不为0，函数会假设只有输入数组（没有设置DFT_INVERSE）的第一行或第一个输出数组（设置了DFT_INVERSE）包含非零值。这样的话函数就可以对其他的行进行更高效的处理节省一些时间，这项技术尤其是在采用DFT计算矩阵卷积时非常有效。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本节学习离散傅里叶变换，好难啊～分两天学习&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>亮度和对比度调节</title>
    <link href="http://yoursite.com/2019/03/21/OpenCV-Learning-Day-11/"/>
    <id>http://yoursite.com/2019/03/21/OpenCV-Learning-Day-11/</id>
    <published>2019-03-21T07:01:34.000Z</published>
    <updated>2019-03-31T11:26:12.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_ContrastAndBright</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nContrastValue;</span><br><span class="line"><span class="keyword">int</span> g_nBrightValue;</span><br><span class="line">Mat g_srcImage, g_dstImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g_srcImage = imread(<span class="string">"1.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage.data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_dstImage = Mat::zeros(g_srcImage.size(), g_srcImage.type());</span><br><span class="line"></span><br><span class="line">    g_nContrastValue = <span class="number">80</span>;</span><br><span class="line">    g_nBrightValue = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Output"</span>,WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    createTrackbar(<span class="string">"Contrast:"</span>,<span class="string">"Output"</span>,&amp;g_nContrastValue,<span class="number">300</span>,on_ContrastAndBright);</span><br><span class="line">    createTrackbar(<span class="string">"Bright:"</span>,<span class="string">"Output"</span>,&amp;g_nBrightValue,<span class="number">200</span>,on_ContrastAndBright);</span><br><span class="line"></span><br><span class="line">    on_ContrastAndBright(g_nContrastValue,<span class="number">0</span>);</span><br><span class="line">    on_ContrastAndBright(g_nBrightValue,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">char</span>(waitKey(<span class="number">1</span>)) != <span class="string">'q'</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_ContrastAndBright</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    namedWindow(<span class="string">"Input"</span>,WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; g_srcImage.rows; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; g_srcImage.cols; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)&#123;</span><br><span class="line">                g_dstImage.at&lt;Vec3b&gt;(y,x)[c] = saturate_cast&lt;uchar&gt;</span><br><span class="line">                ((g_nContrastValue*<span class="number">0.01</span>) * (g_srcImage.at&lt;Vec3b&gt;(y,x)[c]) + g_nBrightValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Input"</span>,g_srcImage);</span><br><span class="line">    imshow(<span class="string">"Output"</span>,g_dstImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原图：<br><img src="/2019/03/21/OpenCV-Learning-Day-11/1.jpg"><br>测试图；<br><img src="/2019/03/21/OpenCV-Learning-Day-11/2.jpg"><br>感觉图片上的时间硬是调早了两个小时……</p><h2 id="1-Mat-zeros-和Mat-ones"><a href="#1-Mat-zeros-和Mat-ones" class="headerlink" title="1.Mat::zeros()和Mat::ones()"></a>1.Mat::zeros()和Mat::ones()</h2><p>Mat::zeros()相当于创建了一张全黑的图，图像矩阵上每个像素点的每个通道全设置为0。<br>Mat::ones()则是将图像矩阵上每个像素点的第一个通道设置为1，其余通道设置为0。</p><h2 id="2-saturate-cast防止数据溢出"><a href="#2-saturate-cast防止数据溢出" class="headerlink" title="2.saturate_cast防止数据溢出"></a>2.saturate_cast防止数据溢出</h2><p>原理如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">data</span>&lt;<span class="number">0</span>) <span class="keyword">data</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">data</span>&gt;<span class="number">255</span>) <span class="keyword">data</span>=<span class="number">255</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-Mat类中的at函数"><a href="#3-Mat类中的at函数" class="headerlink" title="3.Mat类中的at函数"></a>3.Mat类中的at函数</h2><p>在测试代码中，函数实现亮度和对比度的调节是通过Mat类中的at函数遍历各个像素点并修改来实现的，但这不是最有效率的做法，在测试图像素为4000✖1900左右，在调节亮度和对比度时就会变得非常卡了。还有一种指针的做法和一种迭代器的做法，可以参考我之前的博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要介&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>图像通道的分离与合并</title>
    <link href="http://yoursite.com/2019/03/20/OpenCV-Learning-Day-10/"/>
    <id>http://yoursite.com/2019/03/20/OpenCV-Learning-Day-10/</id>
    <published>2019-03-20T07:13:13.000Z</published>
    <updated>2019-03-26T02:22:00.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不要问，就是水，前言说没就会没。</p><a id="more"></a><h2 id="一、通道的分离（split-函数）和合并（merge-函数）"><a href="#一、通道的分离（split-函数）和合并（merge-函数）" class="headerlink" title="一、通道的分离（split()函数）和合并（merge()函数）"></a>一、通道的分离（split()函数）和合并（merge()函数）</h2><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"2.jpg"</span>);</span><br><span class="line">    Mat ImageBlue, ImageGreen, ImageRed;</span><br><span class="line">    Mat mergeImage;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;channels;</span><br><span class="line">    split(srcImage,channels);</span><br><span class="line"></span><br><span class="line">    ImageBlue = channels.at(<span class="number">0</span>);</span><br><span class="line">    imshow(<span class="string">"Blue Channel"</span>,ImageBlue);</span><br><span class="line"></span><br><span class="line">    ImageGreen = channels.at(<span class="number">1</span>);</span><br><span class="line">    imshow(<span class="string">"Green Channel"</span>,ImageGreen);</span><br><span class="line"></span><br><span class="line">    ImageRed = channels.at(<span class="number">2</span>);</span><br><span class="line">    imshow(<span class="string">"Red Channel"</span>,ImageRed);</span><br><span class="line"></span><br><span class="line">    merge(channels,mergeImage);</span><br><span class="line">    imshow(<span class="string">"mergeImage"</span>,mergeImage);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br>蓝色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/1.jpg"><br>绿色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/2.jpg"><br>红色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/3.jpg"><br>合并通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/4.jpg"></p><h3 id="1-split-函数：图像通道的分离"><a href="#1-split-函数：图像通道的分离" class="headerlink" title="1.split()函数：图像通道的分离"></a>1.split()函数：图像通道的分离</h3><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void split(<span class="name">InputArray</span> m, OutputArrayOfArrays mv)</span><br></pre></td></tr></table></figure><br>第一个参数为输入图像<br>第二个参数是函数的输出数组或者vector容器</p><h3 id="2-merge-函数：图像通道的合并"><a href="#2-merge-函数：图像通道的合并" class="headerlink" title="2.merge()函数：图像通道的合并"></a>2.merge()函数：图像通道的合并</h3><p>函数原型：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">merge</span>(InputArrayOfArrays <span class="keyword">mv</span>, OutputArray dst)</span><br></pre></td></tr></table></figure><br>可以看出merge的两个参数和split函数正好相反：<br>第一个参数是保存函数通道的数组或者vector容器<br>第二个参数为输出图像</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不要问，就是水，前言说没就会没。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>通过访问图像像素减少图像颜色数量</title>
    <link href="http://yoursite.com/2019/03/19/OpenCV-Learning-Day-9/"/>
    <id>http://yoursite.com/2019/03/19/OpenCV-Learning-Day-9/</id>
    <published>2019-03-19T10:54:55.000Z</published>
    <updated>2019-03-31T11:26:23.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于你可以自己看下面的内容，所以没有前言。</p><a id="more"></a><p>该测试代码实现的功能是减少图像种颜色的数量，将256×256×256转换成26×26×26从而提高程序运行速度。实现该功能需要用到访问图像像素的函数和计时的函数。<br>效果图：<br><img src="/2019/03/19/OpenCV-Learning-Day-9/1.jpg"><br><img src="/2019/03/19/OpenCV-Learning-Day-9/2.jpg"><br>测试代码：</p><h2 id="一、main函数："><a href="#一、main函数：" class="headerlink" title="一、main函数："></a>一、main函数：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(Mat&amp; inputImage,Mat&amp; outputImage,<span class="keyword">int</span> div)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"1.jpg"</span>);</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">    Mat dstImage;</span><br><span class="line">    dstImage.create(srcImage.rows,srcImage.cols,srcImage.type());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> time0 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line"></span><br><span class="line">    colorReduce(srcImage,dstImage,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    time0 = ((<span class="keyword">double</span>)getTickCount() - time0) / getTickFrequency();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time: "</span> &lt;&lt; time0 &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-计时函数"><a href="#1-计时函数" class="headerlink" title="1.计时函数"></a>1.计时函数</h3><p>getTickCount()函数返回CPU自某个事件以来走过的时钟周期数<br>getTickFrequency()函数返回CPU一秒钟走过的时钟周期数<br>两者组合如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time0 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line">time0 = ((<span class="keyword">double</span>)getTickCount() - time0) / getTickFrequency();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time: "</span> &lt;&lt; time0 &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>即可实现对colorReduce()函数的计时。</p><h3 id="2-static-cast函数"><a href="#2-static-cast函数" class="headerlink" title="2.static_cast函数"></a>2.static_cast函数</h3><p>强制类型转换，即在程序员知情的情况下进行转换，系统不会报错。</p><h2 id="二、实现colorReduce-函数的三种方法"><a href="#二、实现colorReduce-函数的三种方法" class="headerlink" title="二、实现colorReduce()函数的三种方法"></a>二、实现colorReduce()函数的三种方法</h2><h3 id="1-指针访问"><a href="#1-指针访问" class="headerlink" title="1.指针访问"></a>1.指针访问</h3><p>函数代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> colorReduce(<span class="type">Mat</span>&amp; inputImage,<span class="type">Mat</span>&amp; outputImage,<span class="built_in">int</span> <span class="keyword">div</span>)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    <span class="built_in">int</span> rowNumber = outputImage.rows;</span><br><span class="line">    <span class="built_in">int</span> colNumber = outputImage.cols * outputImage.channels();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rowNumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* data = outputImage.<span class="keyword">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; colNumber; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mat类中的ptr函数<br>可以返回第i行的首地址，如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">uchar</span>* <span class="class"><span class="keyword">data</span> = outputImage.ptr&lt;uchar&gt;(<span class="title">i</span>);</span></span><br></pre></td></tr></table></figure></p><h3 id="2-迭代器iterator"><a href="#2-迭代器iterator" class="headerlink" title="2.迭代器iterator"></a>2.迭代器iterator</h3><p>函数代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> colorReduce(<span class="type">Mat</span>&amp; inputImage,<span class="type">Mat</span>&amp; outputImage,<span class="built_in">int</span> <span class="keyword">div</span>)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    <span class="type">Mat_</span>&lt;<span class="type">Vec3b</span>&gt;::<span class="keyword">iterator</span> it = outputImage.begin&lt;<span class="type">Vec3b</span>&gt;();</span><br><span class="line">    <span class="type">Mat_</span>&lt;<span class="type">Vec3b</span>&gt;::<span class="keyword">iterator</span> itend = outputImage.<span class="keyword">end</span>&lt;<span class="type">Vec3b</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;it != itend; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)[<span class="number">0</span>] = (*it)[<span class="number">0</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        (*it)[<span class="number">1</span>] = (*it)[<span class="number">1</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        (*it)[<span class="number">2</span>] = (*it)[<span class="number">2</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL 迭代器嘻嘻嘻…自己找</p><h3 id="3-动态地址计算"><a href="#3-动态地址计算" class="headerlink" title="3.动态地址计算"></a>3.动态地址计算</h3><p>函数代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void colorReduce(Mat&amp; inputImage,Mat&amp; outputImage,int div)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    int rowNumber = outputImage.rows;</span><br><span class="line">    int colNumber = outputImage.cols;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; rowNumber; <span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; colNumber; <span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">0</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">0</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">1</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">1</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">2</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">2</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mat类中的at函数可以读取和修改图像矩阵中对应坐标的元素，但是必须在编译时知道图像的数据类型，at函数本身不会进行任何数据类型的转换，因此需要确保我们指定的数据类型要和图像矩阵中的数据类型相同。<br>一般形式：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[channel] = value;</span><br></pre></td></tr></table></figure><br>在本程序给出的图像是三通道的，因此是Vec3b，表示三个八位数的向量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于你可以自己看下面的内容，所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>简单图形绘制</title>
    <link href="http://yoursite.com/2019/03/18/OpenCV-Learning-Day-8/"/>
    <id>http://yoursite.com/2019/03/18/OpenCV-Learning-Day-8/</id>
    <published>2019-03-18T11:37:25.000Z</published>
    <updated>2019-03-31T11:26:28.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看毛星云大大的教程的测试代码就把我看晕了……所以没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_WIDTH 600</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME1 <span class="meta-string">"Picture1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME2 <span class="meta-string">"Picture2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFilledCircle</span><span class="params">(Mat img,Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Mat img,Point start,Point end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPolygon</span><span class="params">(Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat atomImage = Mat::zeros(WINDOW_WIDTH,WINDOW_WIDTH,CV_8UC3);</span><br><span class="line">    Mat rookImage = Mat::zeros(WINDOW_WIDTH,WINDOW_WIDTH,CV_8UC3);</span><br><span class="line"></span><br><span class="line">    DrawEllipse(atomImage,<span class="number">90</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">0</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">45</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">-45</span>);</span><br><span class="line"></span><br><span class="line">    DrawFilledCircle(atomImage,Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH/<span class="number">2</span>));</span><br><span class="line">    DrawPolygon(rookImage);</span><br><span class="line"></span><br><span class="line">    rectangle(rookImage,</span><br><span class="line">    Point(<span class="number">0</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),</span><br><span class="line">    Point(WINDOW_WIDTH,WINDOW_WIDTH),</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    <span class="number">8</span>);</span><br><span class="line">    <span class="number">9</span>)</span><br><span class="line">    DrawLine(rookImage,Point(<span class="number">0</span>,<span class="number">15</span>*WINDOW_WIDTH/<span class="number">16</span>),Point(WINDOW_WIDTH,<span class="number">15</span>*WINDOW_WIDTH/<span class="number">16</span>));</span><br><span class="line">    DrawLine(rookImage,Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH));</span><br><span class="line">    DrawLine(rookImage,Point(WINDOW_WIDTH/<span class="number">2</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH));</span><br><span class="line">    DrawLine(rookImage,Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">    imshow(WINDOW_NAME1,atomImage);</span><br><span class="line">    moveWindow(WINDOW_NAME1,<span class="number">0</span>,<span class="number">200</span>);</span><br><span class="line">    imshow(WINDOW_NAME2,rookImage);</span><br><span class="line">    moveWindow(WINDOW_NAME2,WINDOW_WIDTH,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Mat img, <span class="keyword">double</span> angle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ellipse(img,</span><br><span class="line">    Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH/<span class="number">2</span>),</span><br><span class="line">    Size(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">16</span>),</span><br><span class="line">    angle,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">360</span>,</span><br><span class="line">    Scalar(<span class="number">255</span>,<span class="number">129</span>,<span class="number">0</span>),</span><br><span class="line">    thickness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFilledCircle</span><span class="params">(Mat img,Point center)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line">    circle(img,</span><br><span class="line">    center,</span><br><span class="line">    WINDOW_WIDTH/<span class="number">32</span>,</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),</span><br><span class="line">    thickness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPolygon</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Point rookPoints[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">0</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">1</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">2</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">3</span>] = Point(<span class="number">11</span>*WINDOW_WIDTH/<span class="number">16</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">4</span>] = Point(<span class="number">19</span>*WINDOW_WIDTH/<span class="number">32</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">5</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">6</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">7</span>] = Point(<span class="number">26</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">8</span>] = Point(<span class="number">26</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">9</span>] = Point(<span class="number">22</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">10</span>] = Point(<span class="number">22</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">11</span>] = Point(<span class="number">18</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">12</span>] = Point(<span class="number">18</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">13</span>] = Point(<span class="number">14</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">14</span>] = Point(<span class="number">14</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">15</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">16</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">17</span>] = Point(<span class="number">13</span>*WINDOW_WIDTH/<span class="number">32</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">18</span>] = Point(<span class="number">5</span>*WINDOW_WIDTH/<span class="number">16</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">19</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point* ppt[<span class="number">1</span>] = &#123;rookPoints[<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    fillPoly(img,</span><br><span class="line">    ppt,</span><br><span class="line">    npt,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Mat img,Point start,Point end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thinkness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line">    line(img,</span><br><span class="line">    start,</span><br><span class="line">    end,</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">    thinkness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br><img src="/2019/03/18/OpenCV-Learning-Day-8/1.png"><br><img src="/2019/03/18/OpenCV-Learning-Day-8/2.png"></p><h2 id="一、void-DrawEllipse-Mat-img-double-angle"><a href="#一、void-DrawEllipse-Mat-img-double-angle" class="headerlink" title="一、void DrawEllipse(Mat img, double angle)"></a>一、void DrawEllipse(Mat img, double angle)</h2><p>该函数调用了OpenCV中的ellipse函数用以绘制椭圆。<br>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">ellipse</span>(</span><br><span class="line">    Mat&amp; img, </span><br><span class="line">    Point center, </span><br><span class="line">    Size axes, </span><br><span class="line">    <span class="keyword">double</span> angle, </span><br><span class="line">    <span class="keyword">double</span> startAngle, </span><br><span class="line">    <span class="keyword">double</span> endAngle, </span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness=<span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType=<span class="number">8</span>, </span><br><span class="line">    <span class="built_in">int</span> shift=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">ellipse</span>(</span><br><span class="line">    Mat&amp; img, </span><br><span class="line">    <span class="keyword">const</span> RotatedRect&amp; <span class="built_in">box</span>, </span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness=<span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType=<span class="number">8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="二、void-DrawFilledCircle-Mat-img-Point-center"><a href="#二、void-DrawFilledCircle-Mat-img-Point-center" class="headerlink" title="二、void DrawFilledCircle(Mat img,Point center)"></a>二、void DrawFilledCircle(Mat img,Point center)</h2><p>该函数调用circle函数用以绘制圆形。<br>函数原型：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">circle</span>(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point center, </span><br><span class="line">    <span class="keyword">int</span> radius, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;color, </span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">1</span>, </span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>在测试程序中，由于线粗设置为-1，因此圆形是实心的。</p><h2 id="三、void-DrawPolygon-Mat-img"><a href="#三、void-DrawPolygon-Mat-img" class="headerlink" title="三、void DrawPolygon(Mat img)"></a>三、void DrawPolygon(Mat img)</h2><p>该函数调用了fillPoly函数用以绘制自定义的多边形。<br>函数原型：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> fillPoly(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    <span class="keyword">const</span> Point **pts, </span><br><span class="line">    <span class="keyword">const</span> <span class="type">int</span> *npts, </span><br><span class="line">    <span class="type">int</span> ncontours, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;color, </span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="type">int</span> shift = <span class="number">0</span>, </span><br><span class="line">    Point <span class="keyword">offset</span> = Point()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>在测试程序中，该函数的多边形的顶点集为ppt，需绘制的多边形顶点数目为npt，绘制图形数量为1。</p><h2 id="四、void-DrawLine-Mat-img-Point-start-Point-end"><a href="#四、void-DrawLine-Mat-img-Point-start-Point-end" class="headerlink" title="四、void DrawLine(Mat img,Point start,Point end)"></a>四、void DrawLine(Mat img,Point start,Point end)</h2><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">line</span>(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point pt1, </span><br><span class="line">    Point pt2, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;<span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness = <span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="built_in">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>无甚可讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看毛星云大大的教程的测试代码就把我看晕了……所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标操作初级</title>
    <link href="http://yoursite.com/2019/03/17/OpenCV-Learning-Day-7/"/>
    <id>http://yoursite.com/2019/03/17/OpenCV-Learning-Day-7/</id>
    <published>2019-03-17T00:37:57.000Z</published>
    <updated>2019-03-31T11:26:32.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为今天天气不错，所以没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME <span class="meta-string">"SetMouseCallback Sample"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> on_MouseHandle(<span class="keyword">int</span> event,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flags,<span class="keyword">void</span>* param);</span><br><span class="line"><span class="keyword">void</span> DrawRectangle(Mat&amp; img,Rect box);</span><br><span class="line"><span class="keyword">void</span> ShowHelpText();</span><br><span class="line"></span><br><span class="line">Rect g_rectangle;</span><br><span class="line"><span class="keyword">bool</span> g_bDrawingBox = false;</span><br><span class="line">RNG g_rng(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)&#123;</span><br><span class="line">    g_rectangle = Rect(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    Mat srcImage(<span class="number">600</span>,<span class="number">800</span>,CV_8UC3),tempImage;</span><br><span class="line">    srcImage.copyTo(tempImage);</span><br><span class="line">    srcImage = Scalar::all(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    namedWindow(WINDOW_NAME);</span><br><span class="line">    setMouseCallback(WINDOW_NAME,on_MouseHandle,(<span class="keyword">void</span>*)&amp;srcImage);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        srcImage.copyTo(tempImage);</span><br><span class="line">        <span class="built_in">if</span>(g_bDrawingBox) DrawRectangle(tempImage, g_rectangle);</span><br><span class="line">        imshow(WINDOW_NAME,tempImage);</span><br><span class="line">        <span class="built_in">if</span>(waitKey(<span class="number">10</span>) == <span class="number">27</span>) <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> on_MouseHandle(<span class="keyword">int</span> event,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flags,<span class="keyword">void</span>* param)&#123;</span><br><span class="line">    Mat&amp; <span class="built_in">image</span> = *(Mat*) param;</span><br><span class="line">    <span class="built_in">switch</span> (event)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//鼠标移动消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_MOUSEMOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">if</span> (g_bDrawingBox) &#123;</span><br><span class="line">            g_rectangle.<span class="built_in">width</span> = x - g_rectangle.x;</span><br><span class="line">            g_rectangle.<span class="built_in">height</span> = y - g_rectangle.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左键按下消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            g_bDrawingBox = true;</span><br><span class="line">            g_rectangle = Rect(x,y,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左键抬起消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_LBUTTONUP:</span><br><span class="line">        &#123;</span><br><span class="line">            g_bDrawingBox = false;</span><br><span class="line">            <span class="comment">//对宽和高小于0的处理</span></span><br><span class="line">            <span class="built_in">if</span> (g_rectangle.<span class="built_in">width</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                g_rectangle.x += g_rectangle.<span class="built_in">width</span>;</span><br><span class="line">                g_rectangle.<span class="built_in">width</span> *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            DrawRectangle(<span class="built_in">image</span>,g_rectangle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DrawRectangle(Mat&amp; img,Rect box)&#123;</span><br><span class="line">    rectangle(img,box.tl(),box.br(),Scalar(g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>),g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>),g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br><img src="/2019/03/17/OpenCV-Learning-Day-7/1.png"><br>setMouseCallback()函数<br>函数原型：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setMouseCallback(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">String</span> &amp;winname, </span><br><span class="line">    MouseCallback onMouse, </span><br><span class="line">    <span class="keyword">void</span> *userdata = (<span class="keyword">void</span> *)<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数为窗口名称<br>第二个参数为MouseCallback类型的onMouse，窗口里每次鼠标操作的发生都会调用这个函数，这个函数的原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_MouseHandle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> <span class="keyword">event</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> x, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> y, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *param</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><br>event是许多EVENT_变量，这个在测试程序中有所体现；x和y是在图像坐标系（？）的坐标值，flags是EVENT_FLAG的组合，param是用户定义的传递到setMouseCallback()函数调用的参数。<br>第三个参数是用户定义的传递到回调函数的参数，有默认值0</p><h2 id="一、Scalar-函数："><a href="#一、Scalar-函数：" class="headerlink" title="一、Scalar()函数："></a>一、Scalar()函数：</h2><p>函数定义：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct <span class="keyword">Scalar</span></span><br><span class="line">&#123;</span><br><span class="line">    double <span class="comment">val[4]</span>;</span><br><span class="line">&#125;<span class="keyword">Scalar</span>;</span><br></pre></td></tr></table></figure><br>由函数定义可知Scalar()可以存储4个double类型的值，分别对应4通道（需要注意的是，在OpenCV中，前三个颜色通道分别是BGR而不是常识中的RGB，第四个通道则是透明度Alpha值），在使用Scalar()函数的过程中，具体需要使用几个值需要看Mat类型图像的type，比如常见的CV_8UC3类型，C就代表通道（channel），看到C3就知道这个图像有三个通道，因此应该写三个值，每个值分别赋值给对应通道内的所有矩阵元素，如果出现参数比通道数少的情况，那么未赋值的通道内所有矩阵元素全部为0。<br>另科普Mat类型的type参数：<br>1.bit_depth：比特数，代表8bite,16bites,32bites,64bites例如创建一个存储灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位，所以它对应的就是CV_8<br>2.S|U|F<br>S代表signed int有符号整形<br>U代表unsigned int无符号整形<br>F代表float单精度浮点型<br>3.C（channel）代表一张图片的通道数<br>灰度图片grayImg是单通道图像<br>RGB彩色图像是3通道图像<br>带Alph通道的RGB图像是4通道图像</p><h2 id="二、Rect-函数"><a href="#二、Rect-函数" class="headerlink" title="二、Rect()函数"></a>二、Rect()函数</h2><p>函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">/* 方形的左上角的x-坐标 */</span> </span><br><span class="line">    <span class="keyword">int</span> y; <span class="comment">/* 方形的左上角的y-坐标*/</span> </span><br><span class="line">    <span class="keyword">int</span> width; <span class="comment">/* 宽 */</span> </span><br><span class="line">    <span class="keyword">int</span> height; <span class="comment">/* 高 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数用法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果创建一个Rect对象rect(100, 50, 50, 100)，那么rect会有以下几个功能： </span></span><br><span class="line"><span class="built_in">rect</span>.area(); <span class="comment">//返回rect的面积 5000 </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">size</span>(); <span class="comment">//返回rect的尺寸 [50 × 100] </span></span><br><span class="line"><span class="built_in">rect</span>.tl(); <span class="comment">//返回rect的左上顶点的坐标 [100, 50] </span></span><br><span class="line"><span class="built_in">rect</span>.br(); <span class="comment">//返回rect的右下顶点的坐标 [150, 150] </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">width</span>(); <span class="comment">//返回rect的宽度 50 </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">height</span>(); <span class="comment">//返回rect的高度 100 </span></span><br><span class="line"><span class="built_in">rect</span>.contains(Point(x, y)); <span class="comment">//返回布尔变量，判断rect是否包含Point(x, y)点 </span></span><br><span class="line"><span class="comment">//还可以求两个矩形的交集和并集 </span></span><br><span class="line"><span class="built_in">rect</span> = rect1 &amp; rect2; </span><br><span class="line"><span class="built_in">rect</span> = rect1 | rect2; </span><br><span class="line"><span class="comment">//还可以对矩形进行平移和缩放 </span></span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + Point(<span class="number">-100</span>, <span class="number">100</span>); <span class="comment">//平移，也就是左上顶点的x坐标-100，y坐标+100 </span></span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + Size(<span class="number">-100</span>, <span class="number">100</span>); <span class="comment">//缩放，左上顶点不变，宽度-100，高度+100 </span></span><br><span class="line"><span class="comment">//还可以对矩形进行对比，返回布尔变量 </span></span><br><span class="line">rect1 == rect2; </span><br><span class="line">rect1 != rect2; </span><br><span class="line"><span class="comment">//判断rect1是否在rect2里面</span></span><br><span class="line"><span class="keyword">bool</span> isInside(Rect rect1, Rect rect2) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> (rect1 == (rect1&amp;rect2)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//矩形中心点</span></span><br><span class="line">Point getCenterPoint(Rect <span class="built_in">rect</span>) </span><br><span class="line">&#123; </span><br><span class="line">    Point cpt; </span><br><span class="line">    cpt.x = <span class="built_in">rect</span>.x + cvRound(<span class="built_in">rect</span>.<span class="built_in">width</span>/<span class="number">2.0</span>); </span><br><span class="line">    cpt.y = <span class="built_in">rect</span>.y + cvRound(<span class="built_in">rect</span>.<span class="built_in">height</span>/<span class="number">2.0</span>); </span><br><span class="line">    <span class="built_in">return</span> cpt; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//围绕矩形中心缩放 </span></span><br><span class="line">Rect rectCenterScale(Rect <span class="built_in">rect</span>, Size <span class="built_in">size</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">size</span>; </span><br><span class="line">    Point pt; </span><br><span class="line">    pt.x = cvRound(<span class="built_in">size</span>.<span class="built_in">width</span>/<span class="number">2.0</span>); </span><br><span class="line">    pt.y = cvRound(<span class="built_in">size</span>.<span class="built_in">height</span>/<span class="number">2.0</span>); </span><br><span class="line">    <span class="built_in">return</span> (<span class="built_in">rect</span>-pt); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>Rect()函数用法摘自：<br><blockquote><footer><strong>【OpenCV】cv::Rect矩形类用法</strong><cite><a href="https://blog.csdn.net/qq_30214939/article/details/65648273" target="_blank" rel="noopener">blog.csdn.net/qq_30214939/article/details/65648273</a></cite></footer></blockquote></p><h2 id="三、Rectangle-函数"><a href="#三、Rectangle-函数" class="headerlink" title="三、Rectangle()函数"></a>三、Rectangle()函数</h2><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rectangle(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point pt1, </span><br><span class="line">    Point pt2,</span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">int</span> lineType = LINE_8, </span><br><span class="line">    <span class="built_in">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数是要处理的图片<br>第二和第三个参数分别是矩形的左上角和右下角的坐标<br>第四个参数是矩形的颜色<br>第五个参数是线的粗细<br>第六个参数是线形</p><h2 id="四、RNG随机数类型"><a href="#四、RNG随机数类型" class="headerlink" title="四、RNG随机数类型"></a>四、RNG随机数类型</h2><p>RNG可以产生3种随机数：<br>RNG(int seed)使用种子seed产生一个64位随机整数，默认-1（计算机的伪随机数是由随机种子根据一定的计算方法计算出来的数值，所以只要计算方法一定，随机种子一定，那么产生的随机数就是固定的）<br>RNG::uniform()产生一个均匀分布的随机数（RNG::uniform(a, b )返回一个[a,b)范围的均匀分布的随机数，a,b的数据类型要一致，而且必须是int、float、double中的一种，默认是int）<br>RNG::gaussian( )产生一个高斯分布的随机数（返回一个均值为0，标准差为σ的随机数。如果要产生均值为λ，标准差为σ的随机数，可以λ+ RNG::gaussian( σ)）</p><h2 id="五、Mat-amp-image-Mat-param-的解释"><a href="#五、Mat-amp-image-Mat-param-的解释" class="headerlink" title="五、Mat&amp; image = (Mat) param;的解释"></a>五、Mat&amp; image = <em>(Mat</em>) param;的解释</h2><p>param是用户定义的传递到setMouseCallback()函数调用的参数,在本行代码中先将param强制转换为Mat类型指针，然后取param的值赋值给左边作为Mat类型引用的image变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为今天天气不错，所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动条创建和使用</title>
    <link href="http://yoursite.com/2019/03/16/OpenCV-Learning-Day-6/"/>
    <id>http://yoursite.com/2019/03/16/OpenCV-Learning-Day-6/</id>
    <published>2019-03-16T07:12:39.000Z</published>
    <updated>2019-03-26T02:37:08.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_nMaxAlphaValue = <span class="number">100</span>; <span class="comment">//Alpha值最大值</span></span><br><span class="line"><span class="keyword">int</span> g_nAlphaValueSlider;<span class="comment">//滑动条对应变量</span></span><br><span class="line"><span class="keyword">double</span> g_dAlphaValue;</span><br><span class="line"><span class="keyword">double</span> g_dBetaValue;</span><br><span class="line"></span><br><span class="line">Mat g_srcImage1;</span><br><span class="line">Mat g_srcImage2;</span><br><span class="line">Mat g_dstImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_Trackbar</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Alpha和Beta值的比例</span></span><br><span class="line">    g_dAlphaValue = (<span class="keyword">double</span>) g_nAlphaValueSlider / g_nMaxAlphaValue;</span><br><span class="line">    g_dBetaValue = (<span class="number">1.0</span> - g_dAlphaValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据Alpha和Beta线性混合</span></span><br><span class="line">    addWeighted(g_srcImage1,g_dAlphaValue,g_srcImage2,g_dBetaValue,<span class="number">0</span>,g_dstImage);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"Trackbar Sample"</span>,g_dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">//图像尺寸必须相同！！！</span></span><br><span class="line">    g_srcImage1 = imread(<span class="string">"Paint1.jpg"</span>);</span><br><span class="line">    g_srcImage2 = imread(<span class="string">"Paint2.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage1.data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reading image 1 failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage2.data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reading image 2 failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_nAlphaValueSlider = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Trackbar Sample"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> TrakbarName[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(TrakbarName,<span class="string">"Alpha"</span>);</span><br><span class="line"></span><br><span class="line">    createTrackbar(TrakbarName,<span class="string">"Trackbar Sample"</span>,&amp;g_nAlphaValueSlider,g_nMaxAlphaValue,on_Trackbar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行时初始化界面</span></span><br><span class="line">    on_Trackbar(g_nAlphaValueSlider,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图；<br>Alpha为0时：<br><img src="/2019/03/16/OpenCV-Learning-Day-6/1.jpg"><br>Alpha为100时：<br><img src="/2019/03/16/OpenCV-Learning-Day-6/2.jpg"></p><p>1.createTrackbar() 函数<br>函数原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTrackbar</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">string</span>&amp; trackbarname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">string</span>&amp; winname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>* <span class="keyword">value</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count, </span></span></span><br><span class="line"><span class="function"><span class="params">    TrackbarCallback onChange=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* userdata=<span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><br>第一个参数：轨迹条的名字<br>第二个参数：窗口的名字<br>第三个参数：int*类型的指针，指向滑块位置，创建时滑块的位置就是该变量当前的值<br>第四个参数：滑块能达到的最大位置的值<br>第五个参数：TrackbarCallback回调函数，默认为零，滑动条的每一次变化都会调用这个函数，函数原型必须是void XXX(int, void*)，第一个参数是轨迹条的位置，第二个参数是用户传给回调函数的参数，如果第三个参数是全局变量的话，完全可以不用管第六个参数。<br>需要注意的是，读取的图像尺寸必须相同，不然会报错。<br>2.getTrackbarPos()：获取滑动条的位置的值<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTrackbarPos</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; trackbarname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; winname</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>图像的简单载入、显示和输出</title>
    <link href="http://yoursite.com/2019/03/15/OpenCV-Learning-Day-5/"/>
    <id>http://yoursite.com/2019/03/15/OpenCV-Learning-Day-5/</id>
    <published>2019-03-15T13:27:49.000Z</published>
    <updated>2019-03-26T02:37:41.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章主要介绍图像的简单载入、显示和输出，新内容有namedWindow()函数、图像的ROI（感兴趣区域）以及图像的输出imwrite()函数，顺带科普一下c++文件中常常定义在main函数中的两个形参argc和argv究竟是什么意思～</p><a id="more"></a><h2 id="一、图像的载入、显示和输出"><a href="#一、图像的载入、显示和输出" class="headerlink" title="一、图像的载入、显示和输出"></a>一、图像的载入、显示和输出</h2><p>测试代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    Mat <span class="built_in">image</span> = imread(<span class="string">"Girl.jpg"</span>);</span><br><span class="line">    Mat logo = imread(<span class="string">"logo.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Girl"</span>);</span><br><span class="line">    imshow(<span class="string">"Girl"</span>,<span class="built_in">image</span>);</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"logo"</span>);</span><br><span class="line">    imshow(<span class="string">"logo"</span>,logo);</span><br><span class="line">    Mat imageROI;</span><br><span class="line">    imageROI = <span class="built_in">image</span>(Rect(<span class="number">1600</span>,<span class="number">2100</span>,logo.cols,logo.rows));</span><br><span class="line">    <span class="comment">//imageROI = image(Range(2100,2100+logo.rows),Range(1600,1600+logo.cols));</span></span><br><span class="line"></span><br><span class="line">    addWeighted(imageROI,<span class="number">0.5</span>,logo,<span class="number">1</span>,<span class="number">0</span>,imageROI);</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Girl+logo"</span>);</span><br><span class="line">    imshow(<span class="string">"Girl+logo"</span>,<span class="built_in">image</span>);</span><br><span class="line"></span><br><span class="line">    imwrite(<span class="string">"Output.jpg"</span>,<span class="built_in">image</span>);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原图：<br><img src="/2019/03/15/OpenCV-Learning-Day-5/Girl.jpg"><br><img src="/2019/03/15/OpenCV-Learning-Day-5/logo.jpg"></p><p>效果图；<br><img src="/2019/03/15/OpenCV-Learning-Day-5/Girl+logo.jpg"></p><p>1.为什么会有namedWindow()函数？<br>在简单的图像处理中，我们通常只要读取图像，经过处理后使用imshow()函数输出图像即可，但是在进阶操作中，我们可能会在执行代码生成的窗口上放置滚动条或者按钮，这时候我们就需要在代码执行前就定义这个窗口，这就是namedWindow()函数的作用。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nameWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; winname,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags = WINDOW_AUTOSIZE</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><br>其中第二个参数可以设置窗口能否放缩以及是否支持OpenGL。<br>2.ROI（region of interest）感兴趣区域<br>圈定一块图像中需要处理的区域，既节省性能，又便于操作。需要定义一个Mat类型以存放图像的ROI，设置ROI其实就是在原来图片上指定一个区域，而这个区域只是新创建了一个图片文件的头信息而已并没有产生新的图片，文件头里的图片区域的起始位置指向了ROI区域的左上角位置，所以在ROI上做的任何操作都会影响原图片。设置ROI区域有两种方法，测试代码里的注释是另一种，两者效果相同。<br>3.imwrite()函数：输出图像到文件。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">imwrite</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, </span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray img, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; params=<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><br>注意：第一个参数文件名要带上后缀</p><h2 id="二、argc和argv"><a href="#二、argc和argv" class="headerlink" title="二、argc和argv"></a>二、argc和argv</h2><p>argc、argv中的arg指的是参数（argument），因此argc的全称为argument counter和argument vector，其中argc为整数，用来统计运行程序时送给main函数的命令行参数的个数；而*argv[]:为字符串数组用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：<br>argv[0]指向程序运行的全路径名<br>argv[1]指向在命令行中执行程序名后的第一个字符串<br>argv[2]指向在命令行中执行程序名后的第二个字符串<br>argv[3]指向在命令行中执行程序名后的第三个字符串<br>argv[argv]为NULL</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章主要介绍图像的简单载入、显示和输出，新内容有namedWindow()函数、图像的ROI（感兴趣区域）以及图像的输出imwrite()函数，顺带科普一下c++文件中常常定义在main函数中的两个形参argc和argv究竟是什么意思～&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>基本视频读取和操作</title>
    <link href="http://yoursite.com/2019/03/14/OpenCV-Learning-Day-4/"/>
    <id>http://yoursite.com/2019/03/14/OpenCV-Learning-Day-4/</id>
    <published>2019-03-14T08:57:35.000Z</published>
    <updated>2019-03-26T02:38:50.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍VideoCapture()函数的使用，包括读取视频和调用摄像头等操作，并结合之前学的一些基本图像处理操作实现视频中物体边缘显示并给出测试代码。对于Mac OS X 10.14无法调用摄像头的问题，文中将给出解决方法。</p><a id="more"></a><h2 id="一、读取视频"><a href="#一、读取视频" class="headerlink" title="一、读取视频"></a>一、读取视频</h2><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">"Adventure.mp4"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//循环显示每一帧</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture &gt;&gt; frame;</span><br><span class="line">        imshow(<span class="string">"Video"</span>,frame);</span><br><span class="line">        waitKey(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于声明为VideoCapture类型的参数，只要将其初始化为视频文件的相对路径或者绝对路径，就可以读取视频文件。定义一个Mat类型的变量，通过while循环将视频的每一帧读取到Mat变量中，这样就可以实现图像操作。</p><h2 id="二、调用摄像头"><a href="#二、调用摄像头" class="headerlink" title="二、调用摄像头"></a>二、调用摄像头</h2><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//循环显示每一帧</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat srcImage;</span><br><span class="line">        capture &gt;&gt; srcImage;</span><br><span class="line">        Mat grayImage, dstImage;</span><br><span class="line">        Mat grad_x,abs_grad_x,grad_y,abs_grad_y;</span><br><span class="line">        cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">        blur(grayImage,dstImage,Size(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        Sobel(grayImage,grad_x,CV_16S,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        convertScaleAbs(grad_x,abs_grad_x);</span><br><span class="line">        Sobel(grayImage,grad_y,CV_16S,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        convertScaleAbs(grad_y,abs_grad_y);</span><br><span class="line">        addWeighted(abs_grad_x,<span class="number">0.5</span>,abs_grad_y,<span class="number">0.5</span>,<span class="number">0</span>,dstImage);</span><br><span class="line">        imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line">        waitKey(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于声明为VideoCapture类型的参数，只要将其初始化为0，就表示调用摄像头。定义一个Mat类型的变量，通过while循环将视频的每一帧读取到Mat变量中，这样就可以实现图像操作。测试代码实现的功能是调用摄像头后通过sobel算子勾勒出物体轮廓。具体sobel函数实现可参考我的上一篇博客：<br><blockquote><footer><strong>三种基本边缘检测算子</strong><cite><a href="https://www.whoiscaesarbao.com/2019/03/13/OpenCV-Learning-Day-3" target="_blank" rel="noopener">www.whoiscaesarbao.com/2019/03/13/OpenCV-Learning-Day-3</a></cite></footer></blockquote><br>需要注意的是，Mac OS X 10.14版本存在摄像头无法调用的问题，原因是摄像头权限没给，因此我们要在应用程序文件夹里找到macOS自带的Photo Booth.app，右键选择显示包内容，文件夹里有一个Info.plist文件，默认使用Xcode打开并删去不必要的项，并加入最后一项Privacy - Camera Usage Description 设置为YES，配置后如下图：<br><img src="/2019/03/14/OpenCV-Learning-Day-4/Infoplist.png"><br>其中OpenCV是我的项目名，将编辑好的Info.plist文件拷贝到：<br>Xcode为与项目文件夹并列<br>VS Code为与生成的可执行文件并列<br>这样就有权限调用摄像头了。</p><p>今天有点水，做数学作业去了～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要介绍VideoCapture()函数的使用，包括读取视频和调用摄像头等操作，并结合之前学的一些基本图像处理操作实现视频中物体边缘显示并给出测试代码。对于Mac OS X 10.14无法调用摄像头的问题，文中将给出解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>三种基本边缘检测算子</title>
    <link href="http://yoursite.com/2019/03/13/OpenCV-Learning-Day-3/"/>
    <id>http://yoursite.com/2019/03/13/OpenCV-Learning-Day-3/</id>
    <published>2019-03-13T11:16:53.000Z</published>
    <updated>2019-03-31T11:26:51.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本片主要介绍三个基本边缘检测的算子（canny算子、sobel算子、laplace算子），关于三个算子的原理和介绍ck2016的简书博客：<br><blockquote><footer><strong>数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</strong><cite><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">www.jianshu.com/p/2334bee37de5</a></cite></footer></blockquote></p><p>介绍的非常通俗易懂和详细，下面主要放函数原型，测试代码和图片展示～</p><p>原图：<br><img src="/2019/03/13/OpenCV-Learning-Day-3/Girl.jpg"></p><a id="more"></a><h2 id="一、canny算子："><a href="#一、canny算子：" class="headerlink" title="一、canny算子："></a>一、canny算子：</h2><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv::Canny  (</span><br><span class="line">    InputArray  image,</span><br><span class="line">    <span class="comment">//输入图像，必须为单通道灰度图</span></span><br><span class="line">    OutputArray     edges,</span><br><span class="line">    <span class="comment">//输出图像，为单通道黑白图</span></span><br><span class="line">    <span class="keyword">double</span>  threshold1,</span><br><span class="line">    <span class="keyword">double</span>  threshold2,</span><br><span class="line">    <span class="comment">//第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割，即如果一个像素的梯度大于上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个点与高于上限值的像素点连接时我们才保留，否则删除。</span></span><br><span class="line">    <span class="keyword">int</span>     apertureSize = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">//第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。Sobel 算子与高斯拉普拉斯算子都是常用的边缘算子</span></span><br><span class="line">    <span class="keyword">bool</span>    L2gradient = <span class="literal">false</span> </span><br><span class="line">)   </span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"Girl.jpg"</span>);</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">    Mat grayImage, dstImage;</span><br><span class="line">    cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    blur(grayImage,dstImage,Size(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    Canny(dstImage,dstImage,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/13/OpenCV-Learning-Day-3/canny.jpg"></p><p>需要注意的是，canny算子在算出梯度值后会有勾勒边缘的一步：把区域内不是极值的点全部置0，因此效果图中的边缘会变成细线，但同时也会导致一些弱的边缘会被抹去，因此canny算子提供了两个阈值的设置，数值超过大阈值的像素点会被认为是边缘，低于小阈值的像素点被认为不是边缘，数值处于两个阈值之间的，将由周围已经被认为是边缘的像素点开始走格子，可达的是边缘，不可达的被认为不是。阈值的大小比最好为2：1或3：1。</p><h2 id="二、sobel算子"><a href="#二、sobel算子" class="headerlink" title="二、sobel算子"></a>二、sobel算子</h2><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Sobel( </span><br><span class="line">    InputArray src, <span class="comment">//输入图像</span></span><br><span class="line">    OutputArray dst, <span class="comment">//输出图像</span></span><br><span class="line">    <span class="built_in">int</span> ddepth,<span class="comment">//目标图像的颜色深度</span></span><br><span class="line">    <span class="built_in">int</span> dx, <span class="comment">//取1表示对x求一阶导数，用来检测竖直边缘</span></span><br><span class="line">    <span class="built_in">int</span> dy, <span class="comment">//取1表示对y求一阶导数，用来检测水平边缘</span></span><br><span class="line">    <span class="built_in">int</span> ksize=<span class="number">3</span>, <span class="comment">//sobel核的大小，必须是奇数，默认为3</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">scale</span>=<span class="number">1</span>, </span><br><span class="line">    <span class="keyword">double</span> delta=<span class="number">0</span>,</span><br><span class="line">    <span class="built_in">int</span> borderType=BORDER_DEFAULT</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"Girl.jpg"</span>);</span><br><span class="line">    imshow(<span class="string">"scrImage"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">    Mat grayImage, dstImage;</span><br><span class="line">    Mat grad_x,abs_grad_x,grad_y,abs_grad_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取灰度图和模糊降噪</span></span><br><span class="line">    cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    blur(grayImage,dstImage,Size(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    Sobel(grayImage,grad_x,CV_16S,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>); <span class="comment">//sobel算子使用16位有符号的数据类型,防止截断</span></span><br><span class="line">    convertScaleAbs(grad_x,abs_grad_x); <span class="comment">//用convertScaleAbs()函数将其转回原来的uint8形式</span></span><br><span class="line">    Sobel(grayImage,grad_y,CV_16S,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    convertScaleAbs(grad_y,abs_grad_y);</span><br><span class="line">    addWeighted(abs_grad_x,<span class="number">0.5</span>,abs_grad_y,<span class="number">0.5</span>,<span class="number">0</span>,dstImage);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/13/OpenCV-Learning-Day-3/sobel.jpg"></p><p>1.需要注意的是，sobel算子的颜色深度最好使用CV_16S，因为OpenCV文档中对Sobel算子的介绍中有这么一句：“in the case of 8-bit input images it will result in truncated derivatives”。即Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断，因此要使用16位有符号的数据类型，即cv2.CV_16S。因此在计算完之后要用convertScaleAbs()函数将其转回原来的uint8形式。<br>2.addWeighted()函数是将两张相同大小，相同类型的图片融合的函数。</p><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cvAddWeighted( </span><br><span class="line">    <span class="keyword">const</span> CvArr* src1, <span class="comment">//第一个原数组</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">alpha</span>,<span class="comment">//第一个数组元素权重</span></span><br><span class="line">    <span class="keyword">const</span> CvArr* src2, <span class="comment">//第二个原数值</span></span><br><span class="line">    <span class="keyword">double</span> beta,<span class="comment">//第二个数组元素权重</span></span><br><span class="line">    <span class="keyword">double</span> gamma, <span class="comment">//两个数组作和后添加的数值。不要太大，不然图片一片白。总和等于255以上就是纯白色了</span></span><br><span class="line">    CvArr* dst <span class="comment">//输出图像</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="三、laplace算子"><a href="#三、laplace算子" class="headerlink" title="三、laplace算子"></a>三、laplace算子</h2><p>函数原型：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Laplacian( </span><br><span class="line"><span class="built_in">    src_gray,</span> //输入图像</span><br><span class="line"><span class="built_in">    dst,</span> //输出图像</span><br><span class="line"><span class="built_in">    ddepth,</span> //因为输入图像一般为CV_8U，为了避免数据溢出，输出图像深度应该设置为CV_16S</span><br><span class="line"><span class="built_in">    kernel_size,</span> //核大小，默认为<span class="number">3</span></span><br><span class="line"><span class="built_in">    scale,</span> </span><br><span class="line"><span class="built_in">    delta,</span> </span><br><span class="line">    BORDER_DEFAULT</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"Girl.jpg"</span>);</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">    Mat grayImage, dstImage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取灰度图和模糊降噪</span></span><br><span class="line">    cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    blur(grayImage,dstImage,Size(<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    Laplacian(grayImage,dstImage,CV_16S,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    convertScaleAbs(dstImage,dstImage);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/13/OpenCV-Learning-Day-3/laplace.jpg"></p><p>需要注意的是，由于输入图像是CV_8U格式，但是在使用laplace是为了防止截断需要转换成CV_16S格式，在计算完之后需要convertScaleAbs()函数转换回CV_8U格式，否则是一张灰色图像，别问我怎么知道的。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>sobel算子产生的边缘有强弱，抗噪性好。<br>laplace算子对边缘敏感，可能有些是噪声的边缘，也被算进来了。<br>canny算走产生的边缘很细，可能就一个像素那么细，没有强弱之分。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><footer><strong>【OpenCV入门教程之十二】OpenCV边缘检测：Canny算子,Sobel算子,Laplace算子,Scharr滤波器合辑</strong><cite><a href="https://blog.csdn.net/poem_qianmo/article/details/25560901" target="_blank" rel="noopener">blog.csdn.net/poem_qianmo/article/details/25560901</a></cite></footer></blockquote><blockquote><footer><strong>数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</strong><cite><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">www.jianshu.com/p/2334bee37de5</a></cite></footer></blockquote><blockquote><footer><strong>OpenCV-Python教程（6、Sobel算子）</strong><cite><a href="https://blog.csdn.net/sunny2038/article/details/9170013" target="_blank" rel="noopener">blog.csdn.net/sunny2038/article/details/9170013</a></cite></footer></blockquote><blockquote><footer><strong>Opencv--Sobel算子</strong><cite><a href="https://blog.csdn.net/qq_41248872/article/details/82886228" target="_blank" rel="noopener">blog.csdn.net/qq_41248872/article/details/82886228</a></cite></footer></blockquote><blockquote><footer><strong>opencv中addWeighted()函数用法总结（05）</strong><cite><a href="https://blog.csdn.net/fanjiule/article/details/81607873" target="_blank" rel="noopener">blog.csdn.net/fanjiule/article/details/81607873</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本片主要介绍三个基本边缘检测的算子（canny算子、sobel算子、laplace算子），关于三个算子的原理和介绍ck2016的简书博客：&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://www.jianshu.com/p/2334bee37de5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.jianshu.com/p/2334bee37de5&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;介绍的非常通俗易懂和详细，下面主要放函数原型，测试代码和图片展示～&lt;/p&gt;
&lt;p&gt;原图：&lt;br&gt;&lt;img src=&quot;/2019/03/13/OpenCV-Learning-Day-3/Girl.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>五种基本滤波器</title>
    <link href="http://yoursite.com/2019/03/12/OpenCV-Learning-Day-2/"/>
    <id>http://yoursite.com/2019/03/12/OpenCV-Learning-Day-2/</id>
    <published>2019-03-12T13:48:45.000Z</published>
    <updated>2019-03-31T11:26:56.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本片主要介绍五个常见的滤波器（线性滤波、方框滤波、高斯滤波、中值滤波、双边滤波），文章基本是我翻阅博客整理而成的笔记～目前水平太菜了自己写不了基础知识，只能整理大神们的文章了！</p><a id="more"></a><h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line">using namespace cv<span class="comment">;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"Bilbo.jpg"</span>)<span class="comment">;</span></span><br><span class="line">    imshow(<span class="string">"Input Image"</span>,srcImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Mat dstImage<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">blur(srcImage,dstImage,Size(3,3));</span></span><br><span class="line"><span class="keyword"> </span>   imshow(<span class="string">"blur"</span>,dstImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boxFilter(srcImage,dstImage,-1,Size(3,3));</span></span><br><span class="line"><span class="keyword"> </span>   imshow(<span class="string">"boxFilter"</span>,dstImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    GaussianBlur(srcImage,dstImage,Size(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>,<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    imshow(<span class="string">"GaussianBlur"</span>,dstImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    medianBlur(srcImage,dstImage,<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">    imshow(<span class="string">"medianBlur"</span>,dstImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bilateralFilter(srcImage,dstImage,100,0,0);</span></span><br><span class="line"><span class="keyword"> </span>   imshow(<span class="string">"bilateralFilter"</span>,dstImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">waitKey(0);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/InputImage.jpg"></p><h2 id="一、基本滤波器"><a href="#一、基本滤波器" class="headerlink" title="一、基本滤波器"></a>一、基本滤波器</h2><h3 id="1-线性滤波"><a href="#1-线性滤波" class="headerlink" title="1.线性滤波"></a>1.线性滤波</h3><p>均值滤波blur：<br>将一个区域内的像素值求和取平均值，然后用这个平均值替换区域中心的像素值。计算速度很快，但是在去躁的同时会模糊很多细节部分，不容易保存细节。</p><p>函数原型：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> blur(</span><br><span class="line">    InputArray src, <span class="comment">//输入图像</span></span><br><span class="line">    OutputArray dst, <span class="comment">//输出图像</span></span><br><span class="line">    <span class="keyword">Size</span> ksize, <span class="comment">//内核大小</span></span><br><span class="line">    Point anchor = Point(-<span class="number">1</span>,-<span class="number">1</span>), <span class="comment">//锚点位置，默认为中心点</span></span><br><span class="line">    <span class="keyword">int</span> borderType = BORDER_DEFAULT <span class="comment">//用于推断图像外部像素的某种边界模式，默认值BORDER_DEFAULT</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/blur.jpg"></p><p>方框滤波boxFilter：<br>算法和均值滤波相似，优缺点也相同，均值滤波算是方框滤波的特殊版本。</p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/boxFilter.jpg"></p><p>高斯滤波GaussianBlur：<br>高斯滤波是专门用于消除满足高斯分布(正态分布)的误差而存在的滤波，此时邻域算子是专门的高斯核，图像中的像素与高斯核做卷积，生成的结果加权平均存放到目标像素中，权重按照二维正态分布，对于抑制符合正态分布的噪声非常有效，并可以增强图像值不同比例下的图像效果。</p><p>函数原型：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GaussianBlur(</span><br><span class="line">    InputArray src, </span><br><span class="line">    OutputArray dst, </span><br><span class="line">    <span class="keyword">Size</span> ksize, </span><br><span class="line">    <span class="comment">//表示高斯核函数在Y方向的的标准偏差，若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来</span></span><br><span class="line">    <span class="keyword">double</span> sigmaX, </span><br><span class="line">    <span class="keyword">double</span> sigmaY=<span class="number">0</span>, </span><br><span class="line">    <span class="keyword">int</span> borderType=BORDER_DEFAULT</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/GaussianBlur.jpg"></p><h3 id="2-非线性滤波"><a href="#2-非线性滤波" class="headerlink" title="2.非线性滤波"></a>2.非线性滤波</h3><p>中值滤波medianBlur：<br>基本思想就是用像素点的领域灰度的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的细节（不会出现边缘模糊的情况）。中值滤波跟均值滤波的思想看起来很相似，只是一个取平均值，一个取中位数，但是均值滤波的计算速度是中值滤波的五倍，具体原因可以看总结。</p><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">medianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> ksize <span class="comment">//孔径的线性尺寸（aperture linear size），必须为奇数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/medianBlur.jpg"></p><p>双边滤波bilateralFilter：<br>双边滤波的最大特点就是做边缘保存，保边去噪。大概的原理是给定一个范围，如果某些区域点与点之间如果数值差距超出范围，那么这个区域就不滤波了，能够很好的保留图像轮廓。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilateralFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray src, </span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> d, <span class="comment">//在过滤过程中每个像素邻域的直径范围</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> sigmaColor, <span class="comment">//颜色空间过滤器的sigma值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> sigmaSpace, <span class="comment">//坐标空间中滤波器的sigma值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType=BORDER_DEFAULT  <span class="comment">//用于推断图像外部像素的某种边界模式，默认值BORDER_DEFAULT</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p><p>注：对sigmaColor、和sigmaSpace两个参数存在比较大的疑惑，因为我不管怎么调后面的参数，效果图好像和原图没有差别…<br>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/bilateralFilter.jpg"></p><p>3.线性滤波和非线性滤波的区别<br>线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算实现，如均值滤波器（模板内像素灰度值的平均值）、高斯滤波器（高斯加权平均值）等。由于线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数是可以确定并且是唯一的（转移函数即模板的傅里叶变换）。</p><p>非线性滤波器的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器、最小值滤波器、中值滤波器等，是通过比较一定邻域内的灰度值大小来实现的，没有固定的模板，因而也就没有特定的转移函数（因为没有模板作傅里叶变换），另外，膨胀和腐蚀也是通过最大值、最小值滤波器实现的。（这就是为什么均值滤波要比中值滤波快五倍的原因：需要通过排序确定中值后才能生成模版）</p><p>参考资料：<br><blockquote><footer><strong>什么是线性滤波、非线性滤波</strong><cite><a href="https://www.cnblogs.com/snowxshy/p/3855011.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowxshy/p/3855011.html</a></cite></footer></blockquote><br><blockquote><footer><strong>opencv中的各种滤波</strong><cite><a href="https://www.jianshu.com/p/8f4024742821" target="_blank" rel="noopener">https://www.jianshu.com/p/8f4024742821</a></cite></footer></blockquote><br><blockquote><footer><strong>OpenCv基本滤波算法小结 blockquote</strong><cite><a href="https://blog.csdn.net/fzhykx/article/details/79546549" target="_blank" rel="noopener">https://blog.csdn.net/fzhykx/article/details/79546549</a></cite></footer></blockquote><br><blockquote><footer><strong>opencv中的各种滤波函数</strong><cite><a href="https://blog.csdn.net/zoucharming/article/details/70197863" target="_blank" rel="noopener">https://blog.csdn.net/zoucharming/article/details/70197863</a></cite></footer></blockquote><br><blockquote><footer><strong>OpenCV探索之路（三）：滤波操作</strong><cite><a href="https://www.cnblogs.com/skyfsm/p/6873188.html" target="_blank" rel="noopener">https://www.cnblogs.com/skyfsm/p/6873188.html</a></cite></footer></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本片主要介绍五个常见的滤波器（线性滤波、方框滤波、高斯滤波、中值滤波、双边滤波），文章基本是我翻阅博客整理而成的笔记～目前水平太菜了自己写不了基础知识，只能整理大神们的文章了！&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>了解卷积：深度学习中的卷积之我见</title>
    <link href="http://yoursite.com/2019/03/11/Something-Fundamental-about-Convolution/"/>
    <id>http://yoursite.com/2019/03/11/Something-Fundamental-about-Convolution/</id>
    <published>2019-03-11T12:07:09.000Z</published>
    <updated>2019-03-11T12:40:04.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在学习OpenCV的过程中接触到了几个常见的算子（canny算子、sobel算子、laplace算子），并对其中的卷积产生了非常大的困惑，此为其一；同时，卷积也可以说是深度学习当中最重要的概念，如CNN神经网络（Conventional Neural Net）更是深度学习中最为常见，也是最为优秀的神经网络之一，此为其二。可以说，卷积是一道不得不迈的门槛，迈过去能办事，迈不过去就只能吹牛了。在翻阅许多博客之后，我发现每个人对卷积的理解都不尽相同，每一篇都能让我有或多或少的收获，但没有一篇能让我完全理解，因此我想站在自己的角度上，稍微谈谈我对卷积以及卷积在深度学习中的使用的一些浅见。</p><a id="more"></a><h2 id="二、一维卷积及其意义"><a href="#二、一维卷积及其意义" class="headerlink" title="二、一维卷积及其意义"></a>二、一维卷积及其意义</h2><p>在数学中，卷积地表示是一维的。我们称 (f*g)(n) 为 f,g 的卷积，其连续的定义为：<br>(f∗g)(n)=∫∞−∞f(τ)g(n−τ)dτ<br>其离散的定义为：<br>(f∗g)(n)=∑−∞∞f(τ)g(n−τ)</p><p>好家伙，看是看得懂，可卷积出来的结果究竟是个什么东西？它的意义是什么？我看到的最能让我明白的是这两个答案：<br><blockquote><footer><strong>如何通俗易懂地解释卷积？ - 张俊博的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="noopener">https://www.zhihu.com/question/22298352/answer/34267457</a></cite></footer></blockquote><br><blockquote><footer><strong>卷积为什么叫「卷」积？ - 荆哲的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/54677157/answer/141245297" target="_blank" rel="noopener">https://www.zhihu.com/question/54677157/answer/141245297</a></cite></footer></blockquote></p><p>看完你理解一下就会知道，卷积的一个重要意义就是：一个函数在另一个函数上的加权叠加。在深度学习中，我们把一个函数看作是输入的图像代表的矩阵（Input Image），把另一个图像看作是卷积核（Convolution Kernel），两者卷积，就是输入图像和卷积核的加权叠加，权重越大，卷积值越大，就代表越重要。这是一个陌生的概念，我先按下不提。我之所以会提及一维卷积，是因为一维的卷积更能帮助我们理解卷积的意义：加权叠加。这就是为什么要用卷积的原因所在。</p><h2 id="三、人类视觉原理"><a href="#三、人类视觉原理" class="headerlink" title="三、人类视觉原理"></a>三、人类视觉原理</h2><p>在谈及卷积在深度学习的应用之前，我想先分享一下深度学习神经网络是怎么出现的，这是摘自<br><blockquote><footer><strong>Alex Cai的博客</strong><cite><a href="http://www.cnblogs.com/alexcai/p/5506806.html" target="_blank" rel="noopener">http://www.cnblogs.com/alexcai/p/5506806.html</a></cite></footer></blockquote><br>它更能帮助我们了解神经网络的作用，以及卷积在其中扮演的角色。</p><p>深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。</p><p>1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。</p><p>人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例：</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/1.png"><p>对于不同的物体，人类视觉也是通过这样逐层分级，来进行认知的：</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/2.png"><p>我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。</p><p>那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，较低层的识别初级的图像特征，若干底层特征组成更上一层特征，最终通过多个层级的组合，最终在顶层做出分类呢？答案是肯定的，这也是许多深度学习算法（包括CNN）的灵感来源。</p><h2 id="四、深度学习中的卷积"><a href="#四、深度学习中的卷积" class="headerlink" title="四、深度学习中的卷积"></a>四、深度学习中的卷积</h2><p>由上一节可见，机器学习脱胎于人类视觉原理，而卷积的作用，就是把关键细节抽象化，因为同一类事物总是有各种相同或者相似的细节，记得卷积的作用吗？加权叠加可以提取出相同的、我们所需要的细节并强调它，一层层的提取和强调，就可以生成机器识物的“逻辑”。</p><p>在深度学习中，我们所使用的卷积是二维的，因为机器所“看”的图片实质上是一个矩阵，那么相应的，卷积核也是一个矩阵，这个卷积核在 2 维输入数据上“滑动”，对当前输入的部分元素进行矩阵乘法，然后将结果汇为单个输出像素。</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/Convolution.gif"><p>这里曾是让我最百思不得其解的地方，可能是智商限制了我的发挥，很长时间有一个问题困扰着我：一维卷积和二维卷积有什么关系？为什么二维卷积会这么计算而不是别的什么方法？其实稍微转换一下角度就很好理解：把输入图像的矩阵和卷积核排成一行而不是将它以二维的形式放置，就会发现它们其实就是f(x)和g(x)以离散的形式所构成的函数！实质上图像正是以这样一种方式，通过训练得出的卷积核，来抽象出图像的特征：强调个性，抑制共性，抽丝剥茧出一套“逻辑”来。</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>以上是我在一天的学习后所做的总结，本文没有涉及任何高级的操作，只是我对卷积的一些浅显认识过程。我认为，在深度学习中，打好基础，掌握必要概念非常重要，它会对后面的学习起到意想不到的效果！希望能给予想要学习深度学习的读者一个比较清楚的认识！</p><p>参考链接：<br><blockquote><footer><strong>如何通俗易懂地解释卷积？ - 张俊博的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="noopener">https://www.zhihu.com/question/22298352/answer/34267457</a></cite></footer></blockquote><br><blockquote><footer><strong>卷积为什么叫「卷」积？ - 荆哲的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/54677157/answer/141245297" target="_blank" rel="noopener">https://www.zhihu.com/question/54677157/answer/141245297</a></cite></footer></blockquote><br><blockquote><footer><strong>Alex Cai的博客</strong><cite><a href="http://www.cnblogs.com/alexcai/p/5506806.html" target="_blank" rel="noopener">http://www.cnblogs.com/alexcai/p/5506806.html</a></cite></footer></blockquote><br>以及所有我看过的博客们！<br>转载请注明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近在学习OpenCV的过程中接触到了几个常见的算子（canny算子、sobel算子、laplace算子），并对其中的卷积产生了非常大的困惑，此为其一；同时，卷积也可以说是深度学习当中最重要的概念，如CNN神经网络（Conventional Neural Net）更是深度学习中最为常见，也是最为优秀的神经网络之一，此为其二。可以说，卷积是一道不得不迈的门槛，迈过去能办事，迈不过去就只能吹牛了。在翻阅许多博客之后，我发现每个人对卷积的理解都不尽相同，每一篇都能让我有或多或少的收获，但没有一篇能让我完全理解，因此我想站在自己的角度上，稍微谈谈我对卷积以及卷积在深度学习中的使用的一些浅见。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
</feed>
