<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caesar Bao&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-12T14:50:41.507Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Caesar Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五种基本滤波器</title>
    <link href="http://yoursite.com/2019/03/12/OpenCV-Learning-Day-2/"/>
    <id>http://yoursite.com/2019/03/12/OpenCV-Learning-Day-2/</id>
    <published>2019-03-12T13:48:45.000Z</published>
    <updated>2019-03-12T14:50:41.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本片主要介绍五个常见的滤波器（线性滤波、方框滤波、高斯滤波、中值滤波、双边滤波），文章基本是我翻阅博客整理而成的笔记～目前水平太菜了自己写不了基础知识，只能整理大神们的文章了！</p><a id="more"></a><h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line">using namespace cv<span class="comment">;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Bilbo.jpg"</span>)<span class="comment">;</span></span><br><span class="line">imshow(<span class="string">"Input Image"</span>,srcImage)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Mat dstImage<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">blur(srcImage,dstImage,Size(3,3));</span></span><br><span class="line"><span class="keyword">imshow("blur",dstImage);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">boxFilter(srcImage,dstImage,-1,Size(3,3));</span></span><br><span class="line"><span class="keyword">imshow("boxFilter",dstImage);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">GaussianBlur(srcImage,dstImage,Size(3,3),0,0);</span></span><br><span class="line"><span class="keyword">imshow("GaussianBlur",dstImage);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">medianBlur(srcImage,dstImage,3);</span></span><br><span class="line"><span class="keyword">imshow("medianBlur",dstImage);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">bilateralFilter(srcImage,dstImage,100,0,0);</span></span><br><span class="line"><span class="keyword">imshow("bilateralFilter",dstImage);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">waitKey(0);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/InputImage.jpg"></p><h2 id="一、基本滤波器"><a href="#一、基本滤波器" class="headerlink" title="一、基本滤波器"></a>一、基本滤波器</h2><h3 id="1-线性滤波"><a href="#1-线性滤波" class="headerlink" title="1.线性滤波"></a>1.线性滤波</h3><p>均值滤波blur：<br>将一个区域内的像素值求和取平均值，然后用这个平均值替换区域中心的像素值。计算速度很快，但是在去躁的同时会模糊很多细节部分，不容易保存细节。</p><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blur</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">OutputArray dst, <span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">Size ksize, <span class="comment">//内核大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">Point anchor = Point(<span class="number">-1</span>,<span class="number">-1</span>), <span class="comment">//锚点位置，默认为中心点</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> borderType = BORDER_DEFAULT )</span></span>; <span class="comment">//用于推断图像外部像素的某种边界模式，默认值BORDER_DEFAULT</span></span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/blur.png"></p><p>方框滤波boxFilter：<br>算法和均值滤波相似，优缺点也相同，均值滤波算是方框滤波的特殊版本。</p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/boxFilter.png"></p><p>高斯滤波GaussianBlur：<br>高斯滤波是专门用于消除满足高斯分布(正态分布)的误差而存在的滤波，此时邻域算子是专门的高斯核，图像中的像素与高斯核做卷积，生成的结果加权平均存放到目标像素中，权重按照二维正态分布，对于抑制符合正态分布的噪声非常有效，并可以增强图像值不同比例下的图像效果。</p><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">InputArray src, </span></span></span><br><span class="line"><span class="function"><span class="params">OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params">Size ksize, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//表示高斯核函数在Y方向的的标准偏差，若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> sigmaX, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> sigmaY=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> borderType=BORDER_DEFAULT)</span></span>;</span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/GaussianBlur.png"></p><h3 id="2-非线性滤波"><a href="#2-非线性滤波" class="headerlink" title="2.非线性滤波"></a>2.非线性滤波</h3><p>中值滤波medianBlur：<br>基本思想就是用像素点的领域灰度的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的细节（不会出现边缘模糊的情况）。中值滤波跟均值滤波的思想看起来很相似，只是一个取平均值，一个取中位数，但是均值滤波的计算速度是中值滤波的五倍，具体原因可以看总结。</p><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">medianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">InputArray src,</span></span></span><br><span class="line"><span class="function"><span class="params">OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> ksize)</span> <span class="comment">//孔径的线性尺寸（aperture linear size），必须为奇数</span></span></span><br></pre></td></tr></table></figure></p><p>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/medianBlur.png"></p><p>双边滤波bilateralFilter：<br>双边滤波的最大特点就是做边缘保存，保边去噪。大概的原理是给定一个范围，如果某些区域点与点之间如果数值差距超出范围，那么这个区域就不滤波了，能够很好的保留图像轮廓。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilateralFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">InputArray src, </span></span></span><br><span class="line"><span class="function"><span class="params">OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> d, <span class="comment">//在过滤过程中每个像素邻域的直径范围</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> sigmaColor, <span class="comment">//颜色空间过滤器的sigma值</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> sigmaSpace, <span class="comment">//坐标空间中滤波器的sigma值</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> borderType=BORDER_DEFAULT )</span> <span class="comment">//用于推断图像外部像素的某种边界模式，默认值BORDER_DEFAULT</span></span></span><br></pre></td></tr></table></figure></p><p>注：对sigmaColor、和sigmaSpace两个参数存在比较大的疑惑，因为我不管怎么调后面的参数，效果图好像和原图没有差别…<br>效果图：<br><img src="/2019/03/12/OpenCV-Learning-Day-2/bilateralFilter.png"></p><p>3.线性滤波和非线性滤波的区别<br>线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算实现，如均值滤波器（模板内像素灰度值的平均值）、高斯滤波器（高斯加权平均值）等。由于线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数是可以确定并且是唯一的（转移函数即模板的傅里叶变换）。</p><p>非线性滤波器的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器、最小值滤波器、中值滤波器等，是通过比较一定邻域内的灰度值大小来实现的，没有固定的模板，因而也就没有特定的转移函数（因为没有模板作傅里叶变换），另外，膨胀和腐蚀也是通过最大值、最小值滤波器实现的。（这就是为什么均值滤波要比中值滤波快五倍的原因：需要通过排序确定中值后才能生成模版）</p><p>参考资料：<br><blockquote><footer><strong>什么是线性滤波、非线性滤波</strong><cite><a href="https://www.cnblogs.com/snowxshy/p/3855011.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowxshy/p/3855011.html</a></cite></footer></blockquote><br><blockquote><footer><strong>opencv中的各种滤波</strong><cite><a href="https://www.jianshu.com/p/8f4024742821" target="_blank" rel="noopener">https://www.jianshu.com/p/8f4024742821</a></cite></footer></blockquote><br><blockquote><footer><strong>OpenCv基本滤波算法小结 blockquote</strong><cite><a href="https://blog.csdn.net/fzhykx/article/details/79546549" target="_blank" rel="noopener">https://blog.csdn.net/fzhykx/article/details/79546549</a></cite></footer></blockquote><br><blockquote><footer><strong>opencv中的各种滤波函数</strong><cite><a href="https://blog.csdn.net/zoucharming/article/details/70197863" target="_blank" rel="noopener">https://blog.csdn.net/zoucharming/article/details/70197863</a></cite></footer></blockquote><br><blockquote><footer><strong>OpenCV探索之路（三）：滤波操作</strong><cite><a href="https://www.cnblogs.com/skyfsm/p/6873188.html" target="_blank" rel="noopener">https://www.cnblogs.com/skyfsm/p/6873188.html</a></cite></footer></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;本片主要介绍五个常见的滤波器（线性滤波、方框滤波、高斯滤波、中值滤波、双边滤波），文章基本是我翻阅博客整理而成的笔记～目前水平太菜了自己写不了基础知识，只能整理大神们的文章了！&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>了解卷积：深度学习中的卷积之我见</title>
    <link href="http://yoursite.com/2019/03/11/Something-Fundamental-about-Convolution/"/>
    <id>http://yoursite.com/2019/03/11/Something-Fundamental-about-Convolution/</id>
    <published>2019-03-11T12:07:09.000Z</published>
    <updated>2019-03-11T12:40:04.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在学习OpenCV的过程中接触到了几个常见的算子（canny算子、sobel算子、laplace算子），并对其中的卷积产生了非常大的困惑，此为其一；同时，卷积也可以说是深度学习当中最重要的概念，如CNN神经网络（Conventional Neural Net）更是深度学习中最为常见，也是最为优秀的神经网络之一，此为其二。可以说，卷积是一道不得不迈的门槛，迈过去能办事，迈不过去就只能吹牛了。在翻阅许多博客之后，我发现每个人对卷积的理解都不尽相同，每一篇都能让我有或多或少的收获，但没有一篇能让我完全理解，因此我想站在自己的角度上，稍微谈谈我对卷积以及卷积在深度学习中的使用的一些浅见。</p><a id="more"></a><h2 id="二、一维卷积及其意义"><a href="#二、一维卷积及其意义" class="headerlink" title="二、一维卷积及其意义"></a>二、一维卷积及其意义</h2><p>在数学中，卷积地表示是一维的。我们称 (f*g)(n) 为 f,g 的卷积，其连续的定义为：<br>(f∗g)(n)=∫∞−∞f(τ)g(n−τ)dτ<br>其离散的定义为：<br>(f∗g)(n)=∑−∞∞f(τ)g(n−τ)</p><p>好家伙，看是看得懂，可卷积出来的结果究竟是个什么东西？它的意义是什么？我看到的最能让我明白的是这两个答案：<br><blockquote><footer><strong>如何通俗易懂地解释卷积？ - 张俊博的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="noopener">https://www.zhihu.com/question/22298352/answer/34267457</a></cite></footer></blockquote><br><blockquote><footer><strong>卷积为什么叫「卷」积？ - 荆哲的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/54677157/answer/141245297" target="_blank" rel="noopener">https://www.zhihu.com/question/54677157/answer/141245297</a></cite></footer></blockquote></p><p>看完你理解一下就会知道，卷积的一个重要意义就是：一个函数在另一个函数上的加权叠加。在深度学习中，我们把一个函数看作是输入的图像代表的矩阵（Input Image），把另一个图像看作是卷积核（Convolution Kernel），两者卷积，就是输入图像和卷积核的加权叠加，权重越大，卷积值越大，就代表越重要。这是一个陌生的概念，我先按下不提。我之所以会提及一维卷积，是因为一维的卷积更能帮助我们理解卷积的意义：加权叠加。这就是为什么要用卷积的原因所在。</p><h2 id="三、人类视觉原理"><a href="#三、人类视觉原理" class="headerlink" title="三、人类视觉原理"></a>三、人类视觉原理</h2><p>在谈及卷积在深度学习的应用之前，我想先分享一下深度学习神经网络是怎么出现的，这是摘自<br><blockquote><footer><strong>Alex Cai的博客</strong><cite><a href="http://www.cnblogs.com/alexcai/p/5506806.html" target="_blank" rel="noopener">http://www.cnblogs.com/alexcai/p/5506806.html</a></cite></footer></blockquote><br>它更能帮助我们了解神经网络的作用，以及卷积在其中扮演的角色。</p><p>深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。</p><p>1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”，可视皮层是分级的。</p><p>人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例：</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/1.png"><p>对于不同的物体，人类视觉也是通过这样逐层分级，来进行认知的：</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/2.png"><p>我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。</p><p>那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，较低层的识别初级的图像特征，若干底层特征组成更上一层特征，最终通过多个层级的组合，最终在顶层做出分类呢？答案是肯定的，这也是许多深度学习算法（包括CNN）的灵感来源。</p><h2 id="四、深度学习中的卷积"><a href="#四、深度学习中的卷积" class="headerlink" title="四、深度学习中的卷积"></a>四、深度学习中的卷积</h2><p>由上一节可见，机器学习脱胎于人类视觉原理，而卷积的作用，就是把关键细节抽象化，因为同一类事物总是有各种相同或者相似的细节，记得卷积的作用吗？加权叠加可以提取出相同的、我们所需要的细节并强调它，一层层的提取和强调，就可以生成机器识物的“逻辑”。</p><p>在深度学习中，我们所使用的卷积是二维的，因为机器所“看”的图片实质上是一个矩阵，那么相应的，卷积核也是一个矩阵，这个卷积核在 2 维输入数据上“滑动”，对当前输入的部分元素进行矩阵乘法，然后将结果汇为单个输出像素。</p><img src="/2019/03/11/Something-Fundamental-about-Convolution/Convolution.gif"><p>这里曾是让我最百思不得其解的地方，可能是智商限制了我的发挥，很长时间有一个问题困扰着我：一维卷积和二维卷积有什么关系？为什么二维卷积会这么计算而不是别的什么方法？其实稍微转换一下角度就很好理解：把输入图像的矩阵和卷积核排成一行而不是将它以二维的形式放置，就会发现它们其实就是f(x)和g(x)以离散的形式所构成的函数！实质上图像正是以这样一种方式，通过训练得出的卷积核，来抽象出图像的特征：强调个性，抑制共性，抽丝剥茧出一套“逻辑”来。</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>以上是我在一天的学习后所做的总结，本文没有涉及任何高级的操作，只是我对卷积的一些浅显认识过程。我认为，在深度学习中，打好基础，掌握必要概念非常重要，它会对后面的学习起到意想不到的效果！希望能给予想要学习深度学习的读者一个比较清楚的认识！</p><p>参考链接：<br><blockquote><footer><strong>如何通俗易懂地解释卷积？ - 张俊博的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="noopener">https://www.zhihu.com/question/22298352/answer/34267457</a></cite></footer></blockquote><br><blockquote><footer><strong>卷积为什么叫「卷」积？ - 荆哲的回答 - 知乎</strong><cite><a href="https://www.zhihu.com/question/54677157/answer/141245297" target="_blank" rel="noopener">https://www.zhihu.com/question/54677157/answer/141245297</a></cite></footer></blockquote><br><blockquote><footer><strong>Alex Cai的博客</strong><cite><a href="http://www.cnblogs.com/alexcai/p/5506806.html" target="_blank" rel="noopener">http://www.cnblogs.com/alexcai/p/5506806.html</a></cite></footer></blockquote><br>以及所有我看过的博客们！<br>转载请注明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近在学习OpenCV的过程中接触到了几个常见的算子（canny算子、sobel算子、laplace算子），并对其中的卷积产生了非常大的困惑，此为其一；同时，卷积也可以说是深度学习当中最重要的概念，如CNN神经网络（Conventional Neural Net）更是深度学习中最为常见，也是最为优秀的神经网络之一，此为其二。可以说，卷积是一道不得不迈的门槛，迈过去能办事，迈不过去就只能吹牛了。在翻阅许多博客之后，我发现每个人对卷积的理解都不尽相同，每一篇都能让我有或多或少的收获，但没有一篇能让我完全理解，因此我想站在自己的角度上，稍微谈谈我对卷积以及卷积在深度学习中的使用的一些浅见。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenCV Learning Day 1</title>
    <link href="http://yoursite.com/2019/03/10/OpenCV-Learning-Day-1/"/>
    <id>http://yoursite.com/2019/03/10/OpenCV-Learning-Day-1/</id>
    <published>2019-03-10T07:43:23.000Z</published>
    <updated>2019-03-10T08:05:18.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文内容包括："><a href="#本文内容包括：" class="headerlink" title="本文内容包括："></a>本文内容包括：</h2><p>一、erode 图像腐蚀（dilate 图像膨胀）<br>二、blur 均值滤波<br>三、canny边缘检测</p><p>文末提供测试图片</p><a id="more"></a><h2 id="一、erode-图像腐蚀（dilate-图像膨胀）"><a href="#一、erode-图像腐蚀（dilate-图像膨胀）" class="headerlink" title="一、erode 图像腐蚀（dilate 图像膨胀）"></a>一、erode 图像腐蚀（dilate 图像膨胀）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line">imshow(<span class="string">"former"</span>,srcImage);</span><br><span class="line">Mat element = getStructuringElement(MORPH_RECT,Size(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">Mat dstImage;</span><br><span class="line">erode(srcImage,dstImage,element);</span><br><span class="line">imshow(<span class="string">"later"</span>,dstImage);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.imread函数只能读取绝对路径，不能读取相对路径，存在疑问。<br>已解决：cmake编译时出现问题，需在CMakeLists.txt中加入一行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(. DIR_SRCS)</span></span></span><br></pre></td></tr></table></figure><br>对整个文件夹进行扫描即可读取到图片的相对路径。<br>（Xcode肯定没这问题但是我不想用哈哈～谁叫它长得没有VS Code好看）</p><p>2.getStructuringElement<br>函数原型：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat getStructuringElement(int shape, Size esize, Point <span class="built_in">anchor</span> = Point(-<span class="number">1</span>, -<span class="number">1</span>));</span><br></pre></td></tr></table></figure><br>函数的第一个参数表示内核的形状，有三种形状可以选择。<br>矩形：MORPH_RECT;<br>交叉形：MORPH_CORSS;<br>椭圆形：MORPH_ELLIPSE;<br>第二和第三个参数分别是内核的尺寸以及锚点的位置。一般在调用erode以及dilate函数之前，先定义一个Mat类型的变量来获得getStructuringElement函数的返回值。对于锚点的位置，有默认值Point（-1,-1），表示锚点位于中心点。element形状唯一依赖锚点位置，其他情况下，锚点只是影响了形态学运算结果的偏移。</p><p>3.erode 图像腐蚀（dilate 图像膨胀）<br>erode 函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void erode( const Mat&amp; src, Mat&amp; dst, const Mat&amp; element,Point <span class="attribute">anchor</span>=Point(-1,-1), int <span class="attribute">iterations</span>=1,int <span class="attribute">borderType</span>=BORDER_CONSTANT,</span><br><span class="line">const Scalar&amp; <span class="attribute">borderValue</span>=morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure><br>dilate 函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dilate( const Mat&amp; src, Mat&amp; dst, const Mat&amp; element,Point <span class="attribute">anchor</span>=Point(-1,-1), int <span class="attribute">iterations</span>=1,int <span class="attribute">borderType</span>=BORDER_CONSTANT,</span><br><span class="line">const Scalar&amp; <span class="attribute">borderValue</span>=morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure><br>参数：<br>src:原图像。<br>dst：目标图像。<br>element:腐蚀操作的内核。 如果不指定，默认为一个简单的 3x3 矩阵。否则，我们就要明确指定它的形状，可以使用函数getStructuringElement().<br>anchor:默认为Point(-1,-1),内核中心点。省略时为默认值。<br>iterations:腐蚀次数。省略时为默认值1。<br>borderType:推断边缘类型，具体参见borderInterpolate函数。默认为BORDER_DEFAULT，省略时为默认值。<br>borderValue:边缘值，具体可参见createMorphoogyFilter函数。可省略。</p><h2 id="二、blur-均值滤波"><a href="#二、blur-均值滤波" class="headerlink" title="二、blur 均值滤波"></a>二、blur 均值滤波</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line">imshow(<span class="string">"src"</span>,srcImage);</span><br><span class="line">Mat dstImage;</span><br><span class="line">blur(srcImage,dstImage,Size(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">imshow(<span class="string">"dst"</span>,dstImage);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点，去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。<br>函数原型：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void blur(InputArray src, OutputArray dst, Size ksize, Point <span class="built_in">anchor</span>=Point(-<span class="number">1</span>,-<span class="number">1</span>), int borderType=BORDER_DEFAULT);</span><br></pre></td></tr></table></figure><br>参数解释：<br>InputArray src: 输入图像<br>OutputArray dst: 输出图像<br>Size ksize: 滤波模板kernel的尺寸，如Size(3,3)<br>Point anchor=Point(-1, -1): 字面意思是锚点，也就是处理的像素位于kernel的什么位置，默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改<br>int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT</p><h2 id="三、canny边缘检测"><a href="#三、canny边缘检测" class="headerlink" title="三、canny边缘检测"></a>三、canny边缘检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line"><span class="comment">//原图像</span></span><br><span class="line">imshow(<span class="string">"src"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">Mat dstImage,edge,grayImage;</span><br><span class="line"><span class="comment">//创建与srcImage同大小和同类型的矩阵</span></span><br><span class="line">dstImage.create(srcImage.size(),srcImage.type());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成灰度图像</span></span><br><span class="line">cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用滤波函数降噪，这里用的是10*10内核</span></span><br><span class="line">blur(grayImage,edge,Size(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行canny算子</span></span><br><span class="line">Canny(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标图像</span></span><br><span class="line">imshow(<span class="string">"dst"</span>,edge);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.cvtColor颜色空间转换函数<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        InputArray src, <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">        OutputArray dst, <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> code, <span class="comment">// 颜色映射码</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> dstCn = <span class="number">0</span> <span class="comment">// 输出的通道数 (0='automatic')</span></span></span></span><br><span class="line"><span class="function"><span class="params"> )</span></span>;</span><br></pre></td></tr></table></figure><br>cvtColor()支持多种颜色空间之间的转换，目前常见的颜色空间均支持，并且在转换的过程中能够保证数据的类型不变，即转换后的图像的数据类型和位深与源图像一致。</p><p>2.canny算法<br>Canny边缘检测于1986年由JOHN CANNY首次在论文《A Computational Approach to Edge Detection》中提出，就此拉开了Canny边缘检测算法的序幕。Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，目前已广泛应用于各种计算机视觉系统。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv::Canny  (   InputArray  image,</span><br><span class="line"><span class="comment">//输入图像，必须为单通道灰度图</span></span><br><span class="line">OutputArray     edges,</span><br><span class="line"><span class="comment">//输出图像，为单通道黑白图</span></span><br><span class="line"><span class="keyword">double</span>  threshold1,</span><br><span class="line"><span class="keyword">double</span>  threshold2,</span><br><span class="line"><span class="comment">//第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割，即如果一个像素的梯度大于上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个点与高于上限值的像素点连接时我们才保留，否则删除。</span></span><br><span class="line"><span class="keyword">int</span>     apertureSize = <span class="number">3</span>,</span><br><span class="line"><span class="comment">//第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。Sobel 算子与高斯拉普拉斯算子都是常用的边缘算子</span></span><br><span class="line"><span class="keyword">bool</span>    L2gradient = <span class="literal">false</span> </span><br><span class="line">)   </span><br></pre></td></tr></table></figure><br>阈值的大小比最好为2：1或3：1。</p><h2 id="测试图像："><a href="#测试图像：" class="headerlink" title="测试图像："></a>测试图像：</h2><img src="/2019/03/10/OpenCV-Learning-Day-1/Phone.png">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文内容包括：&quot;&gt;&lt;a href=&quot;#本文内容包括：&quot; class=&quot;headerlink&quot; title=&quot;本文内容包括：&quot;&gt;&lt;/a&gt;本文内容包括：&lt;/h2&gt;&lt;p&gt;一、erode 图像腐蚀（dilate 图像膨胀）&lt;br&gt;二、blur 均值滤波&lt;br&gt;三、canny边缘检测&lt;/p&gt;
&lt;p&gt;文末提供测试图片&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac 使用VS Code 通过cmake 配置 OpenCV和Pytorch C++ API</title>
    <link href="http://yoursite.com/2019/03/05/Deep-Learning-Starting/"/>
    <id>http://yoursite.com/2019/03/05/Deep-Learning-Starting/</id>
    <published>2019-03-05T15:16:11.000Z</published>
    <updated>2019-03-12T14:13:37.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>由于pytorch的1.0正式版发布不久，同时较为稳定的c++的API也是在正式版中提供支持，网上的教程不多，因此可供参考的资料只有官方文档和零零散散的博客。不过由于Mac和Linux本身相差不大，一些Linux的配置教程同样值得参考。<br>以下给出链接：<br><blockquote><footer><strong>官方文档</strong><cite><a href="https://pytorch.org/cppdocs/installing.html" target="_blank" rel="noopener">https://pytorch.org/cppdocs/installing.html</a></cite></footer></blockquote><br>Oldpan的个人博客（特别感谢Oldpan老哥的帖子给我的巨大帮助）：<br><blockquote><footer><strong>利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测：</strong><cite><a href="https://oldpan.me/archives/pytorch-c-libtorch-inference" target="_blank" rel="noopener">https://oldpan.me/archives/pytorch-c-libtorch-inference</a></cite></footer></blockquote><br><blockquote><footer><strong>Pytorch源码编译简明指南：</strong><cite><a href="https://m.oldpan.me/archives/pytorch-build-simple-instruction" target="_blank" rel="noopener">https://m.oldpan.me/archives/pytorch-build-simple-instruction</a></cite></footer></blockquote></p><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>所需安装的工具有：<br>1.VS Code：这个官网下载即可<br>2.OpenCV 4.0.1:终端输入<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>opencv</span><br></pre></td></tr></table></figure><br>即可安装<br>3.Pytorch1.0:可参考上面给出的Pytorch源码编译简明指南，首先在终端输入<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">--recursive</span> https://github.com/pytorch/pytorch</span><br></pre></td></tr></table></figure><br>获取最新源码，然后通过编译得到Mac可以读取的.dylib文件（注意：在官方文档中下载的libtorch-shared-with-deps-latest.zip文件解压后所得到的文件夹里的动态库文件是以.so结尾，是Linux下的动态库文件，Mac识别不了）编译时应该先进入到刚刚下载好的Pytorch文件夹（默认的路径应该是/Users/用户名/pytorch）下，然后终端执行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="keyword">cd</span> build</span><br><span class="line"><span class="keyword">python</span> ../tools/build_libtorch.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><br>进行libtorch（即c++ API）的编译，时间较长。<br>4.编译好之后打开VS Code新建一个工程，在这里我引用Oldpan老哥的例子</p><img src="/2019/03/05/Deep-Learning-Starting/1.png"><p>工程名叫simnet，然后在simnet文件夹下新建一个CMakeLists.txt和一个test.cpp（build先不建），CMakeLists.txt中的代码为：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(simnet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)        <span class="comment"># 查找libtorch</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)       <span class="comment"># 查找OpenCV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> Torch_FOUND)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">"Pytorch Not Found!"</span>)</span><br><span class="line"><span class="keyword">endif</span>(<span class="keyword">NOT</span> Torch_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Pytorch status:"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    libraries: $&#123;TORCH_LIBRARIES&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"OpenCV library status:"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    version: $&#123;OpenCV_VERSION&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    libraries: $&#123;OpenCV_LIBS&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(simnet <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(simnet <span class="variable">$&#123;TORCH_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span>) </span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> simnet PROPERTY CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></p><p>test.cpp中的代码为：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include "torch/script.h"</span></span><br><span class="line"><span class="comment">#include "torch/torch.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;memory&gt;</span></span><br><span class="line"></span><br><span class="line">using <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize并保持图像比例不变</span></span><br><span class="line">cv::Mat resize_with_ratio(cv::Mat&amp; img)   </span><br><span class="line">&#123;</span><br><span class="line">cv::Mat temImage;</span><br><span class="line"><span class="keyword">int</span> w = img.cols;</span><br><span class="line"><span class="keyword">int</span> h = img.rows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> t = <span class="number">1.</span>;</span><br><span class="line"><span class="keyword">float</span> len = t * std::max(w, h);</span><br><span class="line"><span class="keyword">int</span> dst_w = <span class="number">224</span>, dst_h = <span class="number">224</span>;</span><br><span class="line">cv::Mat image = cv::Mat(cv::Size(dst_w, dst_h), CV_8UC3, cv::Scalar(<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>));</span><br><span class="line">cv::Mat imageROI;</span><br><span class="line"><span class="keyword">if</span>(len==w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> ratio = (<span class="keyword">float</span>)h/(<span class="keyword">float</span>)w;</span><br><span class="line">cv::resize(img,temImage,cv::Size(<span class="number">224</span>,<span class="number">224</span>*ratio),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">0</span>, ((dst_h<span class="number">-224</span>*ratio)/<span class="number">2</span>), temImage.cols, temImage.rows));</span><br><span class="line">temImage.copyTo(imageROI);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> ratio = (<span class="keyword">float</span>)w/(<span class="keyword">float</span>)h;</span><br><span class="line">cv::resize(img,temImage,cv::Size(<span class="number">224</span>*ratio,<span class="number">224</span>),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">imageROI = image(cv::Rect(((dst_w<span class="number">-224</span>*ratio)/<span class="number">2</span>), <span class="number">0</span>, temImage.cols, temImage.rows));</span><br><span class="line">temImage.copyTo(imageROI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">"usage: example-app &lt;path-to-exported-script-module&gt;\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::VideoCapture stream(<span class="number">0</span>);</span><br><span class="line">cv::namedWindow(<span class="string">"Gesture Detect"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;torch::jit::script::Module&gt; module = torch::jit::load(argv[<span class="number">1</span>]);</span><br><span class="line">module-&gt;to(at::kCUDA);</span><br><span class="line"></span><br><span class="line">cv::Mat frame;</span><br><span class="line">cv::Mat image;</span><br><span class="line">cv::Mat input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">stream&gt;&gt;frame;</span><br><span class="line">image = resize_with_ratio(frame);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"resized image"</span>,image);    <span class="comment">//显示摄像头的数据</span></span><br><span class="line">cv::cvtColor(image, input, cv::COLOR_BGR2RGB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方的代码即将图像转化为Tensor，随后导入模型进行预测</span></span><br><span class="line">torch::Tensor tensor_image = torch::from_blob(input.data, &#123;<span class="number">1</span>,input.rows, input.cols,<span class="number">3</span>&#125;, torch::kByte);</span><br><span class="line">tensor_image = tensor_image.permute(&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">tensor_image = tensor_image.toType(torch::kFloat);</span><br><span class="line">tensor_image = tensor_image.div(<span class="number">255</span>);</span><br><span class="line">tensor_image = tensor_image.to(torch::kCUDA);</span><br><span class="line">torch::Tensor result = module-&gt;forward(&#123;tensor_image&#125;).toTensor();</span><br><span class="line"></span><br><span class="line">auto max_result = result.max(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">auto max_index = std::get&lt;<span class="number">1</span>&gt;(max_result).item&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"><span class="keyword">if</span>(max_index == <span class="number">0</span>)</span><br><span class="line">cv::putText(frame, <span class="string">"paper"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(max_index == <span class="number">1</span>)</span><br><span class="line">cv::putText(frame, <span class="string">"scissors"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cv::putText(frame, <span class="string">"stone"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Gesture Detect"</span>,frame);    <span class="comment">//显示摄像头的数据</span></span><br><span class="line">cv::waitKey(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存。</p><p>5.终端cd进入simnet工程文件夹，然后执行<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="keyword">build</span></span><br><span class="line">cd <span class="keyword">build</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=/absolute/<span class="keyword">path</span>/<span class="keyword">to</span>/pytorch ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><br>其中/absolute/path/to/pytorch是pytorch文件夹的绝对路径，一般是/Users/用户名/pytorch<br>这样就编译完成了<br>可以执行<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./simnet</span></span><br></pre></td></tr></table></figure><br>来运行你的工程了！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>由于这是我第一次写教程，很多地方可能有所疏漏，并且配置的过程中踩了无数的坑，可能很多地方起了效果但是我根本没有注意到，还有前期的一些准备工作我也没有提及（比如说anaconda的安装，pip、conda、brew的安装和更新），这些网上有很多大佬写的非常详尽的教程，大家可以多多参考，我这里只是提供了一个自己的思路，如果没有安装成功还望见谅！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前情&quot;&gt;&lt;a href=&quot;#前情&quot; class=&quot;headerlink&quot; title=&quot;前情&quot;&gt;&lt;/a&gt;前情&lt;/h2&gt;&lt;p&gt;由于pytorch的1.0正式版发布不久，同时较为稳定的c++的API也是在正式版中提供支持，网上的教程不多，因此可供参考的资料只有官方文档和零零散散的博客。不过由于Mac和Linux本身相差不大，一些Linux的配置教程同样值得参考。&lt;br&gt;以下给出链接：&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;官方文档&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://pytorch.org/cppdocs/installing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pytorch.org/cppdocs/installing.html&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;br&gt;Oldpan的个人博客（特别感谢Oldpan老哥的帖子给我的巨大帮助）：&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测：&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://oldpan.me/archives/pytorch-c-libtorch-inference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://oldpan.me/archives/pytorch-c-libtorch-inference&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;Pytorch源码编译简明指南：&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://m.oldpan.me/archives/pytorch-build-simple-instruction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://m.oldpan.me/archives/pytorch-build-simple-instruction&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>《La La Land》：有关闪耀而易碎的、遗憾而完美的那些事</title>
    <link href="http://yoursite.com/2019/01/21/Land/"/>
    <id>http://yoursite.com/2019/01/21/Land/</id>
    <published>2019-01-21T10:41:25.000Z</published>
    <updated>2019-01-21T15:11:33.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="City-of-stars-are-you-shining-for-me"><a href="#City-of-stars-are-you-shining-for-me" class="headerlink" title="City of stars, are you shining for me?"></a>City of stars, are you shining for me?</h1><img src="/2019/01/21/Land/1.jpg"><a id="more"></a><p>LA，los angeles，city of stars，确实太过闪耀，有太多人，哪怕从未踏上洛杉矶的土地，也对那里根种了太多美好的幻想。我想起几年前我拿着我新买的PS4，打开《GTA V》的时候，我的天！主角Michael的家外边就是粼粼的海面和充满“热情”的沙滩，无云而湛蓝的天际延伸至远处渐渐变淡，与海面交融直至分不清楚。坐上红色跑车，手搭在车窗上，沿着海岸线一路向北，深红色的岩石蒸腾着热气，视线延伸向上看见绿色————是棕榈树————阳光刺眼，模模糊糊，看不真切；渐入钢铁丛林，阳光也是热辣的吓人，大片大片的反光，大片大片的明媚，西装革履的男人，潮流青年，穿休闲服遛狗的人，酒鬼，或昂首挺胸，或散散漫漫，或失魂落魄，穿梭在层层叠叠的阴影和光斑之间，完美融进这这城市里，一如他们迥然的处境和各不相同的命运。也许是Rockstar太过顶级的美工，又有可能是他们早年的作品圣安第列斯已经满足了我的杀戮欲望，现在我规规矩矩地在马路上开着我的车，老老实实的等着红灯熄灭，绿灯闪烁，循规蹈矩的和其他市民一般驾驶。再往上开，房子渐渐的又变矮了，地势升高，一块巨大的标牌从山顶慢慢向我挪来。我慢慢驶近，在不经意间，它突然变得明亮起来。</p><p>啊，HOLLY WOOD。</p><p>闪亮的灯牌提醒我天色已晚。我下了车，站在富人区的山顶上，眺望着整个圣洛都。细小闪耀的灯光如同沙粒，连着川流不息的车流，成了江成了河，向我诉说这座钢之巨人自他从这片泥土地里诞生起便永不入睡。是啊，它是如此勤奋地活着，连同它身体里的人们，仿佛都是永不入睡的，为了梦想，为了家庭，为了生活，抑或是吸了毒嗨了药，who cares？圣洛都的天空，是我见过的最美的天空————渐变色的，难以形容————或者可以想象一下，你现在正在一个晚宴上，和你心仪的人交谈，总有那么一两个时候你会觉得羞涩，心里有头小鹿撞来撞去，眼神不知道该往哪里看；于是你只好低头盯着你手里拿着的酒杯，因为这样显得你优雅而有礼貌，你开始端详葡萄酒的颜色：深红的葡萄酒被晚宴上昏暗的光线一打，自底向上由浅入深，不断的变换着色彩，可能是浅粉色，可能是淡蓝色，可能是深紫色；你挪动酒杯，颜色也跟着变化————是了，这就是LA的夜空，不仅仅是渐变的，柔和的，绚丽的，同时，它也是暧昧的，易碎的，不可告人的。</p><p>后来我打通了游戏，我最后一次看着Michael，Franklin，Trevor站在一起，看着车子渐渐沉进海底，三个人各自说着像总结一样的话，仿佛是隔着屏幕告诉我们他们的故事到这里就结束了，从今往后他们三个再在哪里相见，以什么样的方式相见，都不再关我的事，自北扬克顿拉开帷幕的故事到这里收场，生活还要继续；后来，因为学习，我（被强迫）收起了我的PS4，到那个时候我已经能轻车熟路的开遍圣洛都的大街小巷，我已然成为了一个老圣洛都人；可是那一晚，我打开我新买的PS4，打开我新买的《GTA V》，逛了逛海滩，坐上我的红色跑车，一路向北……那一幕幕带给我的震撼，我将永远不会忘记。因为是从那个时候起，我真正地将游戏打心底里视为一种艺术，而不是什么害人的消遣，到后来，我从网上知道原来GTA系列是描述美国梦的，我总是不由自主地和那个夜晚联系在一起——繁华的，易碎的，暧昧的，不可告人的……大概就是这样的吧。</p><p>我写了这么长的铺垫，其实是想告诉你，为什么我会对这部电影感触如此之深：不仅仅是因为我再次看到了那些似曾相识的场景，美丽的难以忘怀；而且我还看到了另一个故事，有关美国梦的故事，美好的令人心碎。一如这部电影的画面，我明知现实生活中不可能发生这样的故事，却根本不愿意去质疑。就让我带着迷蒙的的眼神，盯着那只葡萄酒杯；就让我微醺的脸色，更浓一分吧。</p><p>就当我做了一个梦，而我选择再不复醒。</p><p>还没写完先放放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;City-of-stars-are-you-shining-for-me&quot;&gt;&lt;a href=&quot;#City-of-stars-are-you-shining-for-me&quot; class=&quot;headerlink&quot; title=&quot;City of stars, are you shining for me?&quot;&gt;&lt;/a&gt;City of stars, are you shining for me?&lt;/h1&gt;&lt;img src=&quot;/2019/01/21/Land/1.jpg&quot;&gt;
    
    </summary>
    
      <category term="Film Comment" scheme="http://yoursite.com/categories/Film-Comment/"/>
    
    
  </entry>
  
</feed>
