<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caesar Bao&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-10T08:05:18.852Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Caesar Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV Learning Day 1</title>
    <link href="http://yoursite.com/2019/03/10/OpenCV-Learning-Day-1/"/>
    <id>http://yoursite.com/2019/03/10/OpenCV-Learning-Day-1/</id>
    <published>2019-03-10T07:43:23.000Z</published>
    <updated>2019-03-10T08:05:18.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文内容包括："><a href="#本文内容包括：" class="headerlink" title="本文内容包括："></a>本文内容包括：</h2><p>一、erode 图像腐蚀（dilate 图像膨胀）<br>二、blur 均值滤波<br>三、canny边缘检测</p><p>文末提供测试图片</p><a id="more"></a><h2 id="一、erode-图像腐蚀（dilate-图像膨胀）"><a href="#一、erode-图像腐蚀（dilate-图像膨胀）" class="headerlink" title="一、erode 图像腐蚀（dilate 图像膨胀）"></a>一、erode 图像腐蚀（dilate 图像膨胀）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line">imshow(<span class="string">"former"</span>,srcImage);</span><br><span class="line">Mat element = getStructuringElement(MORPH_RECT,Size(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">Mat dstImage;</span><br><span class="line">erode(srcImage,dstImage,element);</span><br><span class="line">imshow(<span class="string">"later"</span>,dstImage);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.imread函数只能读取绝对路径，不能读取相对路径，存在疑问。<br>已解决：cmake编译时出现问题，需在CMakeLists.txt中加入一行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(. DIR_SRCS)</span></span></span><br></pre></td></tr></table></figure><br>对整个文件夹进行扫描即可读取到图片的相对路径。<br>（Xcode肯定没这问题但是我不想用哈哈～谁叫它长得没有VS Code好看）</p><p>2.getStructuringElement<br>函数原型：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat getStructuringElement(int shape, Size esize, Point <span class="built_in">anchor</span> = Point(-<span class="number">1</span>, -<span class="number">1</span>));</span><br></pre></td></tr></table></figure><br>函数的第一个参数表示内核的形状，有三种形状可以选择。<br>矩形：MORPH_RECT;<br>交叉形：MORPH_CORSS;<br>椭圆形：MORPH_ELLIPSE;<br>第二和第三个参数分别是内核的尺寸以及锚点的位置。一般在调用erode以及dilate函数之前，先定义一个Mat类型的变量来获得getStructuringElement函数的返回值。对于锚点的位置，有默认值Point（-1,-1），表示锚点位于中心点。element形状唯一依赖锚点位置，其他情况下，锚点只是影响了形态学运算结果的偏移。</p><p>3.erode 图像腐蚀（dilate 图像膨胀）<br>erode 函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void erode( const Mat&amp; src, Mat&amp; dst, const Mat&amp; element,Point <span class="attribute">anchor</span>=Point(-1,-1), int <span class="attribute">iterations</span>=1,int <span class="attribute">borderType</span>=BORDER_CONSTANT,</span><br><span class="line">const Scalar&amp; <span class="attribute">borderValue</span>=morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure><br>dilate 函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dilate( const Mat&amp; src, Mat&amp; dst, const Mat&amp; element,Point <span class="attribute">anchor</span>=Point(-1,-1), int <span class="attribute">iterations</span>=1,int <span class="attribute">borderType</span>=BORDER_CONSTANT,</span><br><span class="line">const Scalar&amp; <span class="attribute">borderValue</span>=morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure><br>参数：<br>src:原图像。<br>dst：目标图像。<br>element:腐蚀操作的内核。 如果不指定，默认为一个简单的 3x3 矩阵。否则，我们就要明确指定它的形状，可以使用函数getStructuringElement().<br>anchor:默认为Point(-1,-1),内核中心点。省略时为默认值。<br>iterations:腐蚀次数。省略时为默认值1。<br>borderType:推断边缘类型，具体参见borderInterpolate函数。默认为BORDER_DEFAULT，省略时为默认值。<br>borderValue:边缘值，具体可参见createMorphoogyFilter函数。可省略。</p><h2 id="二、blur-均值滤波"><a href="#二、blur-均值滤波" class="headerlink" title="二、blur 均值滤波"></a>二、blur 均值滤波</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line">imshow(<span class="string">"src"</span>,srcImage);</span><br><span class="line">Mat dstImage;</span><br><span class="line">blur(srcImage,dstImage,Size(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">imshow(<span class="string">"dst"</span>,dstImage);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点，去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。<br>函数原型：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void blur(InputArray src, OutputArray dst, Size ksize, Point <span class="built_in">anchor</span>=Point(-<span class="number">1</span>,-<span class="number">1</span>), int borderType=BORDER_DEFAULT);</span><br></pre></td></tr></table></figure><br>参数解释：<br>InputArray src: 输入图像<br>OutputArray dst: 输出图像<br>Size ksize: 滤波模板kernel的尺寸，如Size(3,3)<br>Point anchor=Point(-1, -1): 字面意思是锚点，也就是处理的像素位于kernel的什么位置，默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改<br>int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT</p><h2 id="三、canny边缘检测"><a href="#三、canny边缘检测" class="headerlink" title="三、canny边缘检测"></a>三、canny边缘检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat srcImage = imread(<span class="string">"Phone.png"</span>);</span><br><span class="line"><span class="comment">//原图像</span></span><br><span class="line">imshow(<span class="string">"src"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">Mat dstImage,edge,grayImage;</span><br><span class="line"><span class="comment">//创建与srcImage同大小和同类型的矩阵</span></span><br><span class="line">dstImage.create(srcImage.size(),srcImage.type());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成灰度图像</span></span><br><span class="line">cvtColor(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用滤波函数降噪，这里用的是10*10内核</span></span><br><span class="line">blur(grayImage,edge,Size(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行canny算子</span></span><br><span class="line">Canny(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标图像</span></span><br><span class="line">imshow(<span class="string">"dst"</span>,edge);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.cvtColor颜色空间转换函数<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        InputArray src, <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">        OutputArray dst, <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> code, <span class="comment">// 颜色映射码</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> dstCn = <span class="number">0</span> <span class="comment">// 输出的通道数 (0='automatic')</span></span></span></span><br><span class="line"><span class="function"><span class="params"> )</span></span>;</span><br></pre></td></tr></table></figure><br>cvtColor()支持多种颜色空间之间的转换，目前常见的颜色空间均支持，并且在转换的过程中能够保证数据的类型不变，即转换后的图像的数据类型和位深与源图像一致。</p><p>2.canny算法<br>Canny边缘检测于1986年由JOHN CANNY首次在论文《A Computational Approach to Edge Detection》中提出，就此拉开了Canny边缘检测算法的序幕。Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，目前已广泛应用于各种计算机视觉系统。<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv::Canny  (   InputArray  image,</span><br><span class="line"><span class="comment">//输入图像，必须为单通道灰度图</span></span><br><span class="line">OutputArray     edges,</span><br><span class="line"><span class="comment">//输出图像，为单通道黑白图</span></span><br><span class="line"><span class="keyword">double</span>  threshold1,</span><br><span class="line"><span class="keyword">double</span>  threshold2,</span><br><span class="line"><span class="comment">//第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接，大的阈值用来控制强边缘的初始分割，即如果一个像素的梯度大于上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个点与高于上限值的像素点连接时我们才保留，否则删除。</span></span><br><span class="line"><span class="keyword">int</span>     apertureSize = <span class="number">3</span>,</span><br><span class="line"><span class="comment">//第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。Sobel 算子与高斯拉普拉斯算子都是常用的边缘算子</span></span><br><span class="line"><span class="keyword">bool</span>    L2gradient = <span class="literal">false</span> </span><br><span class="line">)   </span><br></pre></td></tr></table></figure><br>阈值的大小比最好为2：1或3：1。</p><h2 id="测试图像："><a href="#测试图像：" class="headerlink" title="测试图像："></a>测试图像：</h2><img src="/2019/03/10/OpenCV-Learning-Day-1/Phone.png">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文内容包括：&quot;&gt;&lt;a href=&quot;#本文内容包括：&quot; class=&quot;headerlink&quot; title=&quot;本文内容包括：&quot;&gt;&lt;/a&gt;本文内容包括：&lt;/h2&gt;&lt;p&gt;一、erode 图像腐蚀（dilate 图像膨胀）&lt;br&gt;二、blur 均值滤波&lt;br&gt;三、canny边缘检测&lt;/p&gt;
&lt;p&gt;文末提供测试图片&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac 使用VS Code 通过cmake 配置 OpenCV和Pytorch C++ API</title>
    <link href="http://yoursite.com/2019/03/05/Deep-Learning-Starting/"/>
    <id>http://yoursite.com/2019/03/05/Deep-Learning-Starting/</id>
    <published>2019-03-05T15:16:11.000Z</published>
    <updated>2019-03-10T07:58:16.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>由于pytorch的1.0正式版发布不久，同时较为稳定的c++的API也是在正式版中提供支持，网上的教程不多，因此可供参考的资料只有官方文档和零零散散的博客。不过由于Mac和Linux本身相差不大，一些Linux的配置教程同样值得参考。<br>以下给出链接：<br><blockquote><footer><strong>官方文档</strong><cite><a href="https://pytorch.org/cppdocs/installing.html" target="_blank" rel="noopener">https://pytorch.org/cppdocs/installing.html</a></cite></footer></blockquote><br>Oldpan的个人博客（特别感谢Oldpan老哥的帖子给我的巨大帮助）：<br><blockquote><footer><strong>利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测：</strong><cite><a href="https://oldpan.me/archives/pytorch-c-libtorch-inference" target="_blank" rel="noopener">https://oldpan.me/archives/pytorch-c-libtorch-inference</a></cite></footer></blockquote><br><blockquote><footer><strong>Pytorch源码编译简明指南：</strong><cite><a href="https://m.oldpan.me/archives/pytorch-build-simple-instruction" target="_blank" rel="noopener">https://m.oldpan.me/archives/pytorch-build-simple-instruction</a></cite></footer></blockquote></p><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>所需安装的工具有：<br>1.VS Code：这个官网下载即可<br>2.OpenCV 4.0.1:终端输入<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>opencv</span><br></pre></td></tr></table></figure><br>即可安装<br>3.Pytorch1.0:可参考上面给出的Pytorch源码编译简明指南，首先在终端输入<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">--recursive</span> https://github.com/pytorch/pytorch</span><br></pre></td></tr></table></figure><br>获取最新源码，然后通过编译得到Mac可以读取的.dylib文件（注意：在官方文档中下载的libtorch-shared-with-deps-latest.zip文件解压后所得到的文件夹里的动态库文件是以.so结尾，是Linux下的动态库文件，Mac识别不了）编译时应该先进入到刚刚下载好的Pytorch文件夹（默认的路径应该是/Users/用户名/pytorch）下，然后终端执行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="keyword">cd</span> build</span><br><span class="line"><span class="keyword">python</span> ../tools/build_libtorch.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><br>进行libtorch（即c++ API）的编译，时间较长。<br>4.编译好之后打开VS Code新建一个工程，在这里我引用Oldpan老哥的例子</p><img src="/2019/03/05/Deep-Learning-Starting/1.png"><p>工程名叫simnet，然后在simnet文件夹下新建一个CMakeLists.txt和一个test.cpp（build先不建），CMakeLists.txt中的代码为：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(simnet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)        <span class="comment"># 查找libtorch</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)       <span class="comment"># 查找OpenCV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> Torch_FOUND)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">"Pytorch Not Found!"</span>)</span><br><span class="line"><span class="keyword">endif</span>(<span class="keyword">NOT</span> Torch_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Pytorch status:"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    libraries: $&#123;TORCH_LIBRARIES&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"OpenCV library status:"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    version: $&#123;OpenCV_VERSION&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    libraries: $&#123;OpenCV_LIBS&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(simnet <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(simnet <span class="variable">$&#123;TORCH_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBS&#125;</span>) </span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> simnet PROPERTY CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></p><p>test.cpp中的代码为：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include "torch/script.h"</span></span><br><span class="line"><span class="comment">#include "torch/torch.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;memory&gt;</span></span><br><span class="line"></span><br><span class="line">using <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize并保持图像比例不变</span></span><br><span class="line">cv::Mat resize_with_ratio(cv::Mat&amp; img)   </span><br><span class="line">&#123;</span><br><span class="line">cv::Mat temImage;</span><br><span class="line"><span class="keyword">int</span> w = img.cols;</span><br><span class="line"><span class="keyword">int</span> h = img.rows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> t = <span class="number">1.</span>;</span><br><span class="line"><span class="keyword">float</span> len = t * std::max(w, h);</span><br><span class="line"><span class="keyword">int</span> dst_w = <span class="number">224</span>, dst_h = <span class="number">224</span>;</span><br><span class="line">cv::Mat image = cv::Mat(cv::Size(dst_w, dst_h), CV_8UC3, cv::Scalar(<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>));</span><br><span class="line">cv::Mat imageROI;</span><br><span class="line"><span class="keyword">if</span>(len==w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> ratio = (<span class="keyword">float</span>)h/(<span class="keyword">float</span>)w;</span><br><span class="line">cv::resize(img,temImage,cv::Size(<span class="number">224</span>,<span class="number">224</span>*ratio),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">imageROI = image(cv::Rect(<span class="number">0</span>, ((dst_h<span class="number">-224</span>*ratio)/<span class="number">2</span>), temImage.cols, temImage.rows));</span><br><span class="line">temImage.copyTo(imageROI);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> ratio = (<span class="keyword">float</span>)w/(<span class="keyword">float</span>)h;</span><br><span class="line">cv::resize(img,temImage,cv::Size(<span class="number">224</span>*ratio,<span class="number">224</span>),<span class="number">0</span>,<span class="number">0</span>,cv::INTER_LINEAR);</span><br><span class="line">imageROI = image(cv::Rect(((dst_w<span class="number">-224</span>*ratio)/<span class="number">2</span>), <span class="number">0</span>, temImage.cols, temImage.rows));</span><br><span class="line">temImage.copyTo(imageROI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">"usage: example-app &lt;path-to-exported-script-module&gt;\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::VideoCapture stream(<span class="number">0</span>);</span><br><span class="line">cv::namedWindow(<span class="string">"Gesture Detect"</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;torch::jit::script::Module&gt; module = torch::jit::load(argv[<span class="number">1</span>]);</span><br><span class="line">module-&gt;to(at::kCUDA);</span><br><span class="line"></span><br><span class="line">cv::Mat frame;</span><br><span class="line">cv::Mat image;</span><br><span class="line">cv::Mat input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">stream&gt;&gt;frame;</span><br><span class="line">image = resize_with_ratio(frame);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"resized image"</span>,image);    <span class="comment">//显示摄像头的数据</span></span><br><span class="line">cv::cvtColor(image, input, cv::COLOR_BGR2RGB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方的代码即将图像转化为Tensor，随后导入模型进行预测</span></span><br><span class="line">torch::Tensor tensor_image = torch::from_blob(input.data, &#123;<span class="number">1</span>,input.rows, input.cols,<span class="number">3</span>&#125;, torch::kByte);</span><br><span class="line">tensor_image = tensor_image.permute(&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">tensor_image = tensor_image.toType(torch::kFloat);</span><br><span class="line">tensor_image = tensor_image.div(<span class="number">255</span>);</span><br><span class="line">tensor_image = tensor_image.to(torch::kCUDA);</span><br><span class="line">torch::Tensor result = module-&gt;forward(&#123;tensor_image&#125;).toTensor();</span><br><span class="line"></span><br><span class="line">auto max_result = result.max(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">auto max_index = std::get&lt;<span class="number">1</span>&gt;(max_result).item&lt;<span class="keyword">float</span>&gt;();</span><br><span class="line"><span class="keyword">if</span>(max_index == <span class="number">0</span>)</span><br><span class="line">cv::putText(frame, <span class="string">"paper"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(max_index == <span class="number">1</span>)</span><br><span class="line">cv::putText(frame, <span class="string">"scissors"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cv::putText(frame, <span class="string">"stone"</span>, &#123;<span class="number">40</span>, <span class="number">50</span>&#125;, cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Gesture Detect"</span>,frame);    <span class="comment">//显示摄像头的数据</span></span><br><span class="line">cv::waitKey(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存。</p><p>5.终端cd进入simnet工程文件夹，然后执行<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="keyword">build</span></span><br><span class="line">cd <span class="keyword">build</span></span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=/absolute/<span class="keyword">path</span>/<span class="keyword">to</span>/pytorch ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><br>其中/absolute/path/to/pytorch是pytorch文件夹的绝对路径，一般是/Users/用户名/pytorch<br>这样就编译完成了<br>可以执行<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./simnet</span></span><br></pre></td></tr></table></figure><br>来运行你的工程了！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>由于这是我第一次写教程，很多地方可能有所疏漏，并且配置的过程中踩了无数的坑，可能很多地方起了效果但是我根本没有注意到，还有前期的一些准备工作我也没有提及（比如说anaconda的安装，pip、conda、brew的安装和更新），这些网上有很多大佬写的非常详尽的教程，大家可以多多参考，我这里只是提供了一个自己的思路，如果没有安装成功还望见谅！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前情&quot;&gt;&lt;a href=&quot;#前情&quot; class=&quot;headerlink&quot; title=&quot;前情&quot;&gt;&lt;/a&gt;前情&lt;/h2&gt;&lt;p&gt;由于pytorch的1.0正式版发布不久，同时较为稳定的c++的API也是在正式版中提供支持，网上的教程不多，因此可供参考的资料只有官方文档和零零散散的博客。不过由于Mac和Linux本身相差不大，一些Linux的配置教程同样值得参考。&lt;br&gt;以下给出链接：&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;官方文档&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://pytorch.org/cppdocs/installing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pytorch.org/cppdocs/installing.html&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;br&gt;Oldpan的个人博客（特别感谢Oldpan老哥的帖子给我的巨大帮助）：&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测：&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://oldpan.me/archives/pytorch-c-libtorch-inference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://oldpan.me/archives/pytorch-c-libtorch-inference&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;&lt;footer&gt;&lt;strong&gt;Pytorch源码编译简明指南：&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://m.oldpan.me/archives/pytorch-build-simple-instruction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://m.oldpan.me/archives/pytorch-build-simple-instruction&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>《La La Land》：有关闪耀而易碎的、遗憾而完美的那些事</title>
    <link href="http://yoursite.com/2019/01/21/Land/"/>
    <id>http://yoursite.com/2019/01/21/Land/</id>
    <published>2019-01-21T10:41:25.000Z</published>
    <updated>2019-01-21T15:11:33.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="City-of-stars-are-you-shining-for-me"><a href="#City-of-stars-are-you-shining-for-me" class="headerlink" title="City of stars, are you shining for me?"></a>City of stars, are you shining for me?</h1><img src="/2019/01/21/Land/1.jpg"><a id="more"></a><p>LA，los angeles，city of stars，确实太过闪耀，有太多人，哪怕从未踏上洛杉矶的土地，也对那里根种了太多美好的幻想。我想起几年前我拿着我新买的PS4，打开《GTA V》的时候，我的天！主角Michael的家外边就是粼粼的海面和充满“热情”的沙滩，无云而湛蓝的天际延伸至远处渐渐变淡，与海面交融直至分不清楚。坐上红色跑车，手搭在车窗上，沿着海岸线一路向北，深红色的岩石蒸腾着热气，视线延伸向上看见绿色————是棕榈树————阳光刺眼，模模糊糊，看不真切；渐入钢铁丛林，阳光也是热辣的吓人，大片大片的反光，大片大片的明媚，西装革履的男人，潮流青年，穿休闲服遛狗的人，酒鬼，或昂首挺胸，或散散漫漫，或失魂落魄，穿梭在层层叠叠的阴影和光斑之间，完美融进这这城市里，一如他们迥然的处境和各不相同的命运。也许是Rockstar太过顶级的美工，又有可能是他们早年的作品圣安第列斯已经满足了我的杀戮欲望，现在我规规矩矩地在马路上开着我的车，老老实实的等着红灯熄灭，绿灯闪烁，循规蹈矩的和其他市民一般驾驶。再往上开，房子渐渐的又变矮了，地势升高，一块巨大的标牌从山顶慢慢向我挪来。我慢慢驶近，在不经意间，它突然变得明亮起来。</p><p>啊，HOLLY WOOD。</p><p>闪亮的灯牌提醒我天色已晚。我下了车，站在富人区的山顶上，眺望着整个圣洛都。细小闪耀的灯光如同沙粒，连着川流不息的车流，成了江成了河，向我诉说这座钢之巨人自他从这片泥土地里诞生起便永不入睡。是啊，它是如此勤奋地活着，连同它身体里的人们，仿佛都是永不入睡的，为了梦想，为了家庭，为了生活，抑或是吸了毒嗨了药，who cares？圣洛都的天空，是我见过的最美的天空————渐变色的，难以形容————或者可以想象一下，你现在正在一个晚宴上，和你心仪的人交谈，总有那么一两个时候你会觉得羞涩，心里有头小鹿撞来撞去，眼神不知道该往哪里看；于是你只好低头盯着你手里拿着的酒杯，因为这样显得你优雅而有礼貌，你开始端详葡萄酒的颜色：深红的葡萄酒被晚宴上昏暗的光线一打，自底向上由浅入深，不断的变换着色彩，可能是浅粉色，可能是淡蓝色，可能是深紫色；你挪动酒杯，颜色也跟着变化————是了，这就是LA的夜空，不仅仅是渐变的，柔和的，绚丽的，同时，它也是暧昧的，易碎的，不可告人的。</p><p>后来我打通了游戏，我最后一次看着Michael，Franklin，Trevor站在一起，看着车子渐渐沉进海底，三个人各自说着像总结一样的话，仿佛是隔着屏幕告诉我们他们的故事到这里就结束了，从今往后他们三个再在哪里相见，以什么样的方式相见，都不再关我的事，自北扬克顿拉开帷幕的故事到这里收场，生活还要继续；后来，因为学习，我（被强迫）收起了我的PS4，到那个时候我已经能轻车熟路的开遍圣洛都的大街小巷，我已然成为了一个老圣洛都人；可是那一晚，我打开我新买的PS4，打开我新买的《GTA V》，逛了逛海滩，坐上我的红色跑车，一路向北……那一幕幕带给我的震撼，我将永远不会忘记。因为是从那个时候起，我真正地将游戏打心底里视为一种艺术，而不是什么害人的消遣，到后来，我从网上知道原来GTA系列是描述美国梦的，我总是不由自主地和那个夜晚联系在一起——繁华的，易碎的，暧昧的，不可告人的……大概就是这样的吧。</p><p>我写了这么长的铺垫，其实是想告诉你，为什么我会对这部电影感触如此之深：不仅仅是因为我再次看到了那些似曾相识的场景，美丽的难以忘怀；而且我还看到了另一个故事，有关美国梦的故事，美好的令人心碎。一如这部电影的画面，我明知现实生活中不可能发生这样的故事，却根本不愿意去质疑。就让我带着迷蒙的的眼神，盯着那只葡萄酒杯；就让我微醺的脸色，更浓一分吧。</p><p>就当我做了一个梦，而我选择再不复醒。</p><p>还没写完先放放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;City-of-stars-are-you-shining-for-me&quot;&gt;&lt;a href=&quot;#City-of-stars-are-you-shining-for-me&quot; class=&quot;headerlink&quot; title=&quot;City of stars, are you shining for me?&quot;&gt;&lt;/a&gt;City of stars, are you shining for me?&lt;/h1&gt;&lt;img src=&quot;/2019/01/21/Land/1.jpg&quot;&gt;
    
    </summary>
    
      <category term="Film Comment" scheme="http://yoursite.com/categories/Film-Comment/"/>
    
    
  </entry>
  
</feed>
