<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caesar Bao&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-26T07:28:34.889Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Caesar Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过python实现官网监控、音乐播放、邮件提醒的简易程序</title>
    <link href="http://yoursite.com/2020/03/26/PythonQiangbudaoFanxin/"/>
    <id>http://yoursite.com/2020/03/26/PythonQiangbudaoFanxin/</id>
    <published>2020-03-26T07:18:00.000Z</published>
    <updated>2020-03-26T07:28:34.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本弟弟是一个大二计算机专业学生，因为准备考研而起了买个iPad pro的念头，怎奈家境贫寒（那你能帮帮我吗？）只能起了买官翻的念头。但是官翻更新没有规律，经常手动刷新容易错过，因此受到吧里老哥的启发，用python写了一个监控官网的小程序，成功帮群里的几位老哥抢到翻新，证明了这个程序的效果。<br><img src="/2020/03/26/PythonQiangbudaoFanxin/1.JPG"></p><a id="more"></a><h2 id="1-尝试前"><a href="#1-尝试前" class="headerlink" title="1.尝试前"></a>1.尝试前</h2><p>第一，需要注意的是，由于本弟弟不会封装，因此尝试前请务必安装python3的环境，不可以因为没装环境运行不了留言或者私信骂我啥b！<br>博主环境：macOS+pycharm+python3.7.4<br>代码上import的包都可以用pip工具安装～<br>第二，由于程序写的很简单，有的时候可能会根据不同地区不同家庭的网络状况而造成更新不及时的问题，博主也是失败了三次才成功抢到～不可以因为通知晚了没抢到留言或者私信骂我啥b！<br>第三、博主分享这个程序，是希望能够激发各位懂行的老哥的兴趣，并探讨和交流，觉得有效果的可以捐赠我鼓励我！</p><h2 id="2-开始！"><a href="#2-开始！" class="headerlink" title="2.开始！"></a>2.开始！</h2><h3 id="一、发邮件函数"><a href="#一、发邮件函数" class="headerlink" title="一、发邮件函数"></a>一、发邮件函数</h3><p>如果你没有办法一直蹲在电脑前，就需要用到发邮件来通知你官网的更新。以QQ邮箱为例，这需要邮箱打开SMTP服务，具体可以进行百度，打开后获取授权码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(title, article, receiver)</span>:</span></span><br><span class="line">    host = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 这是QQ邮箱SMTP服务器的host，其他邮箱有不同可具体查询</span></span><br><span class="line">    user = <span class="string">'XXXXXXXXX@qq.com'</span><span class="comment">#这是邮箱号</span></span><br><span class="line">    password = <span class="string">'XXXXXXXXXXXXXX'</span><span class="comment">#这是授权码，注意不是邮箱的密码或者QQ的密码！</span></span><br><span class="line">    sender = user</span><br><span class="line">    coding = <span class="string">'utf8'</span></span><br><span class="line">    message = MIMEText(article, <span class="string">'plain'</span>, coding)</span><br><span class="line">    message[<span class="string">'From'</span>] = Header(sender, coding)</span><br><span class="line">    message[<span class="string">'To'</span>] = Header(receiver, coding)</span><br><span class="line">    message[<span class="string">'subject'</span>] = Header(title, coding)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mail_client = smtplib.SMTP_SSL(host, <span class="number">465</span>)<span class="comment">#部分邮箱信道不同，又有可能没有开启SSL服务，具体查询</span></span><br><span class="line">        mail_client.connect(host)</span><br><span class="line">        mail_client.login(user, password)</span><br><span class="line">        mail_client.sendmail(sender, receiver, message.as_string())</span><br><span class="line">        mail_client.close()</span><br><span class="line">        print(<span class="string">'邮件已成功发送给:'</span> + receiver)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'发送失败!'</span>)</span><br></pre></td></tr></table></figure><br>二、循环爬取网页信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">"Get Work!"</span>)</span><br><span class="line">    localtime = time.asctime(time.localtime(time.time()))  <span class="comment"># 报时，免得程序卡住不知道～</span></span><br><span class="line">    print(localtime)</span><br><span class="line">    url = <span class="string">'https://www.apple.com.cn/shop/refurbished/ipad'</span>  <span class="comment"># 这个是iPad翻新页面</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 3578.98 Safari/537.36'</span>&#125;  <span class="comment"># 添加headers防止官网认为是爬虫而屏蔽访问</span></span><br><span class="line">    req = urllib.request.Request(url, headers=headers)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rsp = urllib.request.urlopen(req)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    html = rsp.read().decode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)</span><br><span class="line">    <span class="comment"># print(html)</span></span><br><span class="line"></span><br><span class="line">    html = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> html.find_all(<span class="string">'a'</span>):</span><br><span class="line">        info_link = link.get(<span class="string">'href'</span>)</span><br><span class="line">        info_text = link.get_text(strip=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># print(info_text)</span></span><br><span class="line">        <span class="comment"># print(info_link + '\n')</span></span><br><span class="line">        <span class="keyword">if</span> info_text == <span class="string">"翻新 11 英寸 iPad Pro 无线局域网机型 64GB - 银色"</span>:</span><br><span class="line">            print(<span class="string">'Got 翻新 11 英寸 iPad Pro 无线局域网机型 64GB - 银色!'</span>)</span><br><span class="line">            <span class="comment"># playsound('BGM.mp3')</span></span><br><span class="line">            print(<span class="string">"https://www.apple.com.cn"</span> + info_link)</span><br><span class="line">            send_mail(info_text, <span class="string">"https://www.apple.com.cn"</span> + info_link, <span class="string">'XXXXXXXXX@qq.com'</span>)</span><br><span class="line">    print(<span class="string">'Done!'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 数字决定几秒爬取一次</span></span><br></pre></td></tr></table></figure><br>理论上说，这个小程序可以通知官翻网站上任何产品，比如说要买Mac，可以将url修改成Mac页面。<br>博主拿“翻新 11 英寸 iPad Pro 无线局域网机型 64GB - 银色”为例，需要注意的是，程序的原理是爬取网页的信息，并进行查找和比对，因此想要的这个商品的名字要与官网产品的名字完全相同（包括空格）！<br>如果你觉得邮件通知还是比较慢，并且可以在电脑前等待，你可以将 </p><p>#playsound(‘BGM.mp3’)前的#号和空格去掉，那么程序在爬取到对应信息后会以播放音乐的形式通知你！（缺点是音乐不播放完不会执行下一步～）<br>BGM博主不会提供，可以自行下载一个自己喜欢的音乐，放在python程序的根目录即可～<br>三、完整代码分享<br>分享代码之前，相信大家也已经看出来了，实际上能够正确运行这个程序并不容易，对于程序的种种限制也一定会深感麻烦，博主也对并非这个专业的吧友们的烦恼感到理解，希望有大神能够将程序封装成易使用的图形化界面造福吧友～<br>如果有老哥因为我分享的程序而成功抢到心仪的产品，也希望能够打赏我，鼓励我，并且分享这篇博客给大家让更多的人看到！<br><img src="/2020/03/26/PythonQiangbudaoFanxin/2.JPG"><br><img src="/2020/03/26/PythonQiangbudaoFanxin/3.JPG"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(title, article, receiver)</span>:</span></span><br><span class="line">    host = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 这是QQ邮箱SMTP服务器的host，其他邮箱有不同可具体查询</span></span><br><span class="line">    user = <span class="string">'XXXXXXXXX@qq.com'</span><span class="comment">#这是邮箱号</span></span><br><span class="line">    password = <span class="string">'XXXXXXXXXXXXXX'</span><span class="comment">#这是授权码，注意不是邮箱的密码或者QQ的密码！</span></span><br><span class="line">    sender = user</span><br><span class="line">    coding = <span class="string">'utf8'</span></span><br><span class="line">    message = MIMEText(article, <span class="string">'plain'</span>, coding)</span><br><span class="line">    message[<span class="string">'From'</span>] = Header(sender, coding)</span><br><span class="line">    message[<span class="string">'To'</span>] = Header(receiver, coding)</span><br><span class="line">    message[<span class="string">'subject'</span>] = Header(title, coding)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mail_client = smtplib.SMTP_SSL(host, <span class="number">465</span>)<span class="comment">#部分邮箱信道不同，又有可能没有开启SSL服务，具体查询</span></span><br><span class="line">        mail_client.connect(host)</span><br><span class="line">        mail_client.login(user, password)</span><br><span class="line">        mail_client.sendmail(sender, receiver, message.as_string())</span><br><span class="line">        mail_client.close()</span><br><span class="line">        print(<span class="string">'邮件已成功发送给:'</span> + receiver)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'发送失败!'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(<span class="string">"Get Work!"</span>)</span><br><span class="line">    localtime = time.asctime(time.localtime(time.time()))  <span class="comment"># 报时，免得程序卡住不知道～</span></span><br><span class="line">    print(localtime)</span><br><span class="line">    url = <span class="string">'https://www.apple.com.cn/shop/refurbished/ipad'</span>  <span class="comment"># 这个是iPad翻新页面</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 3578.98 Safari/537.36'</span>&#125;  <span class="comment"># 添加headers防止官网认为是爬虫而屏蔽访问</span></span><br><span class="line">    req = urllib.request.Request(url, headers=headers)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rsp = urllib.request.urlopen(req)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    html = rsp.read().decode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)</span><br><span class="line">    <span class="comment"># print(html)</span></span><br><span class="line"></span><br><span class="line">    html = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> html.find_all(<span class="string">'a'</span>):</span><br><span class="line">        info_link = link.get(<span class="string">'href'</span>)</span><br><span class="line">        info_text = link.get_text(strip=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># print(info_text)</span></span><br><span class="line">        <span class="comment"># print(info_link + '\n')</span></span><br><span class="line">        <span class="keyword">if</span> info_text == <span class="string">"翻新 11 英寸 iPad Pro 无线局域网机型 64GB - 银色"</span>:</span><br><span class="line">            print(<span class="string">'Got 翻新 11 英寸 iPad Pro 无线局域网机型 64GB - 银色!'</span>)</span><br><span class="line">            <span class="comment"># playsound('BGM.mp3')</span></span><br><span class="line">            print(<span class="string">"https://www.apple.com.cn"</span> + info_link)</span><br><span class="line">            send_mail(info_text, <span class="string">"https://www.apple.com.cn"</span> + info_link, <span class="string">'XXXXXXXXX@qq.com'</span>)</span><br><span class="line">    print(<span class="string">'Done!'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 数字决定几秒爬取一次</span></span><br></pre></td></tr></table></figure><br>未经允许不得转载！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本弟弟是一个大二计算机专业学生，因为准备考研而起了买个iPad pro的念头，怎奈家境贫寒（那你能帮帮我吗？）只能起了买官翻的念头。但是官翻更新没有规律，经常手动刷新容易错过，因此受到吧里老哥的启发，用python写了一个监控官网的小程序，成功帮群里的几位老哥抢到翻新，证明了这个程序的效果。&lt;br&gt;&lt;img src=&quot;/2020/03/26/PythonQiangbudaoFanxin/1.JPG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>实战MNIST手写数字识别</title>
    <link href="http://yoursite.com/2019/04/12/Pytorch-MNIST/"/>
    <id>http://yoursite.com/2019/04/12/Pytorch-MNIST/</id>
    <published>2019-04-12T08:08:10.000Z</published>
    <updated>2019-04-12T12:13:06.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>读取MNIST数据集实现手写数字的识别</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="title">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.utils.data.dataloader <span class="keyword">as</span> Data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="title">train_data</span> = torchvision.datasets.<span class="type">MNIST</span>(</span><br><span class="line">    './mnist',</span><br><span class="line">    train=<span class="type">True</span>,</span><br><span class="line">    transform=torchvision.transforms.<span class="type">ToTensor</span>(),</span><br><span class="line">    download=<span class="type">True</span>)</span><br><span class="line"><span class="title">test_data</span> = torchvision.datasets.<span class="type">MNIST</span>(</span><br><span class="line">    './mnist', train=<span class="type">False</span>, transform=torchvision.transforms.<span class="type">ToTensor</span>())</span><br><span class="line"><span class="title">print</span>(<span class="string">"train_data:"</span>, train_data.<span class="class"><span class="keyword">data</span>.size())</span></span><br><span class="line"><span class="title">print</span>(<span class="string">"train_labels:"</span>, train_data.targets.size())</span><br><span class="line"><span class="title">print</span>(<span class="string">"test_data:"</span>, test_data.<span class="class"><span class="keyword">data</span>.size())</span></span><br><span class="line"></span><br><span class="line"><span class="title">train_loader</span> = <span class="type">Data</span>.<span class="type">DataLoader</span>(dataset=train_data, batch_size=<span class="number">64</span>, shuffle=<span class="type">True</span>)</span><br><span class="line"><span class="title">test_loader</span> = <span class="type">Data</span>.<span class="type">DataLoader</span>(dataset=test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Net</span>(<span class="title">torch</span>.<span class="title">nn</span>.<span class="type">Module</span>):</span></span><br><span class="line"><span class="class">    def __init__(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        super(<span class="type">Net</span>, <span class="title">self</span>).__init__()</span></span><br><span class="line"><span class="class">        self.conv1 = torch.nn.<span class="type">Sequential</span>(</span></span><br><span class="line"><span class="class">            <span class="title">torch</span>.<span class="title">nn</span>.<span class="type">Conv2d</span>(1, 32, 3, 1, 1), torch.nn.<span class="type">ReLU</span>(),</span></span><br><span class="line"><span class="class">            torch.nn.<span class="type">MaxPool2d</span>(2))</span></span><br><span class="line"><span class="class">        self.conv2 = torch.nn.<span class="type">Sequential</span>(</span></span><br><span class="line"><span class="class">            <span class="title">torch</span>.<span class="title">nn</span>.<span class="type">Conv2d</span>(32, 64, 3, 1, 1), torch.nn.<span class="type">ReLU</span>(),</span></span><br><span class="line"><span class="class">            torch.nn.<span class="type">MaxPool2d</span>(2))</span></span><br><span class="line"><span class="class">        self.conv3 = torch.nn.<span class="type">Sequential</span>(</span></span><br><span class="line"><span class="class">            <span class="title">torch</span>.<span class="title">nn</span>.<span class="type">Conv2d</span>(64, 64, 3, 1, 1), torch.nn.<span class="type">ReLU</span>(),</span></span><br><span class="line"><span class="class">            torch.nn.<span class="type">MaxPool2d</span>(2))</span></span><br><span class="line"><span class="class">        self.dense = torch.nn.<span class="type">Sequential</span>(</span></span><br><span class="line"><span class="class">            <span class="title">torch</span>.<span class="title">nn</span>.<span class="type">Linear</span>(64 * 3 * 3, 128), torch.nn.<span class="type">ReLU</span>(),</span></span><br><span class="line"><span class="class">            torch.nn.<span class="type">Linear</span>(128, 10))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    def forward(<span class="title">self</span>, <span class="title">x</span>):</span></span><br><span class="line"><span class="class">        conv1_out = self.conv1(<span class="title">x</span>)</span></span><br><span class="line"><span class="class">        conv2_out = self.conv2(<span class="title">conv1_out</span>)</span></span><br><span class="line"><span class="class">        conv3_out = self.conv3(<span class="title">conv2_out</span>)</span></span><br><span class="line"><span class="class">        res = conv3_out.view(<span class="title">conv3_out</span>.<span class="title">size</span>(0), -1)</span></span><br><span class="line"><span class="class">        out = self.dense(<span class="title">res</span>)</span></span><br><span class="line"><span class="class">        return out</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">model = <span class="type">Net</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">optimizer = torch.optim.<span class="type">Adam</span>(<span class="title">model</span>.<span class="title">parameters</span>())</span></span><br><span class="line"><span class="class">loss_func = torch.nn.<span class="type">CrossEntropyLoss</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">for epoch in range(1):</span></span><br><span class="line"><span class="class">    print('<span class="title">epoch</span> &#123;&#125;'.<span class="title">format</span>(<span class="title">epoch</span> + 1))</span></span><br><span class="line"><span class="class">    train_loss = 0.</span></span><br><span class="line"><span class="class">    train_acc = 0.</span></span><br><span class="line"><span class="class">    for batch_x, batch_y in train_loader:</span></span><br><span class="line"><span class="class">        batch_x, batch_y = <span class="type">Variable</span>(<span class="title">batch_x</span>), <span class="type">Variable</span>(<span class="title">batch_y</span>)</span></span><br><span class="line"><span class="class">        out = model(<span class="title">batch_x</span>)</span></span><br><span class="line"><span class="class">        loss = loss_func(<span class="title">out</span>, <span class="title">batch_y</span>)</span></span><br><span class="line"><span class="class">        train_loss += loss.item()</span></span><br><span class="line"><span class="class">        pred = torch.max(<span class="title">out</span>, 1)[1]</span></span><br><span class="line"><span class="class">        train_correct = (<span class="title">pred</span> == <span class="title">batch_y</span>).sum()</span></span><br><span class="line"><span class="class">        train_acc += train_correct.item()</span></span><br><span class="line"><span class="class">        optimizer.zero_grad()</span></span><br><span class="line"><span class="class">        loss.backward()</span></span><br><span class="line"><span class="class">        optimizer.step()</span></span><br><span class="line"><span class="class">    print('<span class="type">Train</span> <span class="type">Loss</span>: &#123;:.6<span class="title">f</span>&#125;, <span class="type">Acc</span>: &#123;:.6<span class="title">f</span>&#125;'.<span class="title">format</span>(</span></span><br><span class="line"><span class="class">        <span class="title">train_loss</span> / (<span class="title">len</span>(<span class="title">train_data</span>)), train_acc / (<span class="title">len</span>(<span class="title">train_data</span>))))</span></span><br><span class="line"><span class="class">    model.eval()</span></span><br><span class="line"><span class="class">    eval_loss = 0.</span></span><br><span class="line"><span class="class">    eval_acc = 0.</span></span><br><span class="line"><span class="class">    for batch_x, batch_y in test_loader:</span></span><br><span class="line"><span class="class">        with torch.no_grad():</span></span><br><span class="line"><span class="class">            batch_x = <span class="type">Variable</span>(<span class="title">batch_x</span>)</span></span><br><span class="line"><span class="class">        with torch.no_grad():</span></span><br><span class="line"><span class="class">            batch_y = <span class="type">Variable</span>(<span class="title">batch_y</span>)</span></span><br><span class="line"><span class="class">        out = model(<span class="title">batch_x</span>)</span></span><br><span class="line"><span class="class">        loss = loss_func(<span class="title">out</span>, <span class="title">batch_y</span>)</span></span><br><span class="line"><span class="class">        eval_loss += loss.item()</span></span><br><span class="line"><span class="class">        pred = torch.max(<span class="title">out</span>, 1)[1]</span></span><br><span class="line"><span class="class">        num_correct = (<span class="title">pred</span> == <span class="title">batch_y</span>).sum()</span></span><br><span class="line"><span class="class">        eval_acc += num_correct.item()</span></span><br><span class="line"><span class="class">    print('<span class="type">Test</span> <span class="type">Loss</span>: &#123;:.6<span class="title">f</span>&#125;, <span class="type">Acc</span>: &#123;:.6<span class="title">f</span>&#125;'.<span class="title">format</span>(<span class="title">eval_loss</span> / (<span class="title">len</span>(<span class="title">test_data</span>)),</span></span><br><span class="line"><span class="class">        eval_acc / (<span class="title">len</span>(<span class="title">test_data</span>))))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">data_loader_test = torch.utils.data.<span class="type">DataLoader</span>(</span></span><br><span class="line"><span class="class"><span class="title">dataset</span>=<span class="title">test_data</span>, <span class="title">batch_size</span>=4, <span class="title">shuffle</span>=<span class="type">True</span>)</span></span><br><span class="line"><span class="class">x_test, y_test = next(<span class="title">iter</span>(<span class="title">data_loader_test</span>))</span></span><br><span class="line"><span class="class">inputs = <span class="type">Variable</span>(<span class="title">x_test</span>)</span></span><br><span class="line"><span class="class">pred = model(<span class="title">inputs</span>)</span></span><br><span class="line"><span class="class">_, pred = torch.max(<span class="title">pred</span>, 1)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">print('<span class="type">Predict</span> <span class="type">Label</span> <span class="title">is</span>:', [<span class="title">i</span> <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">pred</span>.<span class="title">data</span>])</span></span><br><span class="line"><span class="class">print('<span class="type">Real</span> <span class="type">Label</span> <span class="title">is</span>:', [<span class="title">i</span> <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">y_test</span>])</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">img = torchvision.utils.make_grid(<span class="title">x_test</span>)</span></span><br><span class="line"><span class="class">img = img.numpy().transpose(1, 2, 0)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">plt.imshow(<span class="title">img</span>)</span></span><br><span class="line"><span class="class">plt.show()</span></span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">train_data</span>: <span class="selector-tag">torch</span><span class="selector-class">.Size</span>(<span class="selector-attr">[60000, 28, 28]</span>)</span><br><span class="line"><span class="selector-tag">train_labels</span>: <span class="selector-tag">torch</span><span class="selector-class">.Size</span>(<span class="selector-attr">[60000]</span>)</span><br><span class="line"><span class="selector-tag">test_data</span>: <span class="selector-tag">torch</span><span class="selector-class">.Size</span>(<span class="selector-attr">[10000, 28, 28]</span>)</span><br><span class="line"><span class="selector-tag">epoch</span> 1</span><br><span class="line"><span class="selector-tag">Train</span> <span class="selector-tag">Loss</span>: 0<span class="selector-class">.003245</span>, <span class="selector-tag">Acc</span>: 0<span class="selector-class">.934217</span></span><br><span class="line"><span class="selector-tag">Test</span> <span class="selector-tag">Loss</span>: 0<span class="selector-class">.001147</span>, <span class="selector-tag">Acc</span>: 0<span class="selector-class">.973900</span></span><br><span class="line"><span class="selector-tag">Predict</span> <span class="selector-tag">Label</span> <span class="selector-tag">is</span>: <span class="selector-attr">[tensor(0), tensor(2), tensor(9), tensor(4)]</span></span><br><span class="line"><span class="selector-tag">Real</span> <span class="selector-tag">Label</span> <span class="selector-tag">is</span>: <span class="selector-attr">[tensor(0), tensor(2), tensor(9), tensor(4)]</span></span><br></pre></td></tr></table></figure><h3 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h3><img src="/2019/04/12/Pytorch-MNIST/1.jpg"><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>实质上网络并不复杂（那么，为什么咕咕咕？）具体是由三个卷积层和一个全连接层组成，由于数据集被分成了一个个包，每个包的格式为[64, 1, 28, 28]，64是包含了64张图，1代表通道，MNIST的图像都是单通道黑白图，28是图像的长和宽。<br>下面，我先介绍一下网络里的相关函数，再进行分析：</p><h3 id="class-torch-nn-Conv2d"><a href="#class-torch-nn-Conv2d" class="headerlink" title="class torch.nn.Conv2d()"></a>class torch.nn.Conv2d()</h3><p>二维卷积函数<br>in_channels(int) – 输入信号的通道<br>out_channels(int) – 卷积产生的通道<br>kernel_size(int or tuple) - 卷积核的尺寸<br>stride(int or tuple, optional) - 卷积步长<br>padding(int or tuple, optional) - 输入的每一条边补充0的层数<br>常见的是这前五个参数，输入信号的通道和卷积产生的通道决定了要产生几个卷积核，kernel_size和stride是卷积核的参数，padding是由于在卷积后周围一圈的像素点会因为没有卷积而消失，因此需要人为的补充一圈像素，保持图像尺寸不变。</p><h3 id="torch-nn-ReLU"><a href="#torch-nn-ReLU" class="headerlink" title="torch.nn.ReLU()"></a>torch.nn.ReLU()</h3><p>激活函数，本质是max(0, x)，可以看出目的是实现完全抑制负数，成比例促进正数，是一种对神经元的模仿。</p><h3 id="class-torch-nn-MaxPool2d"><a href="#class-torch-nn-MaxPool2d" class="headerlink" title="class torch.nn.MaxPool2d()"></a>class torch.nn.MaxPool2d()</h3><p>二维池化函数<br>kernel_size(int or tuple) - max pooling的窗口大小<br>stride(int or tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size<br>padding(int or tuple, optional) - 输入的每一条边补充0的层数<br>最大池化比较好理解，在池化过程中保留最大值，可以说是在放大需要特征，消除不必要特征。</p><h2 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h2><p>conv1，conv2，conv3都是由一个卷积函数，一个激励函数以及一个池化函数组成，数据集在进入conv1时的格式为[1, 28, 28]，卷积后变为[32, 28, 28]，池化后变为[32, 14, 14]，<br>同理，在经过conv2层后格式为[64, 7, 7]，在经过conv3层后变为[64, 3, 3]；而dense层则是全连接层，目的是为了进行线性变换，使最后产生的值只有10个，这十个值可以说是模拟出来的概率，即针对0-9每一个数字的概率，值越大就代表是这个对应数字的可能性越大。<br>这点怎么看呢？<br>在训练过程中有一行代码是实现训练值和真实值的比较：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred = torch.<span class="built_in">max</span>(<span class="keyword">out</span>, <span class="number">1</span>)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><h3 id="torch-max"><a href="#torch-max" class="headerlink" title="torch.max()"></a>torch.max()</h3><p>第一个参数是输入Tensor，第二个参数是选择行和列，0代表比较每一列的最大值，1代表比较每一行的最大值；而max返回两个值，第一个是最大值，第二个如果选择比较行最大值，那么就返回最大值所在列，如果选择比较列最大值，那么就返回最大值所在行。后面可以指定单独返回哪个值，[0]返回最大值，[1]返回位置。<br>代码展示的就是比较行最大值，并返回最大值所在列，我打印一些测试值数据和经过max之后的数据出来：<br>测试值数据：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">-4.3027</span>, <span class="number">-0.9863</span>, <span class="number">2.6202</span>, <span class="number">1.2236</span>, <span class="number">-5.9825</span>, <span class="number">-2.1526</span>, <span class="number">-15.2012</span>,</span><br><span class="line"><span class="number">12.2280</span>, <span class="number">-2.6344</span>, <span class="number">3.1522</span>],</span><br><span class="line">[ <span class="number">2.3235</span>, <span class="number">2.6725</span>, <span class="number">13.7567</span>, <span class="number">2.4374</span>, <span class="number">-7.5948</span>, <span class="number">-7.6910</span>, <span class="number">-2.6478</span>,</span><br><span class="line"><span class="number">-6.4028</span>, <span class="number">4.3079</span>, <span class="number">-6.4800</span>],</span><br><span class="line">[ <span class="number">-2.2610</span>, <span class="number">8.7104</span>, <span class="number">-0.7275</span>, <span class="number">-2.9841</span>, <span class="number">1.5691</span>, <span class="number">-2.3972</span>, <span class="number">-1.0289</span>,</span><br><span class="line"><span class="number">-0.6307</span>, <span class="number">0.1610</span>, <span class="number">-2.7338</span>]])</span><br></pre></td></tr></table></figure><br>max之后的数据：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><br>可以看到测试值数据的最大值正好出现在7，2，1的位置。</p><h2 id="深度学习真有趣"><a href="#深度学习真有趣" class="headerlink" title="深度学习真有趣"></a>深度学习真有趣</h2><p>（那你为什么咕咕咕？）<br><img src="/2019/04/12/Pytorch-MNIST/2.GIF"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;读取MNIST数据集实现手写数字的识别&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>logistic回归模型</title>
    <link href="http://yoursite.com/2019/04/08/Pytorch-A-LogisticRegression-Model/"/>
    <id>http://yoursite.com/2019/04/08/Pytorch-A-LogisticRegression-Model/</id>
    <published>2019-04-08T09:17:15.000Z</published>
    <updated>2019-04-08T11:35:31.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始涉及logistic回归，主要解决分类问题，贴一个学到的简单二分类，看书写的代码问题很大，问题比较多，踩坑踩死我……<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/2.jpg"></p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="title">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="title">with</span> open('<span class="class"><span class="keyword">data</span>.txt', 'r') as f:</span></span><br><span class="line">    data_list = f.readlines()</span><br><span class="line">    data_list = [i.split('\n')[<span class="number">0</span>] for i <span class="keyword">in</span> data_list]</span><br><span class="line">    data_list = [i.split(',') for i <span class="keyword">in</span> data_list]</span><br><span class="line">    <span class="class"><span class="keyword">data</span> = [(<span class="title">float</span>(<span class="title">i</span>[0]), float(<span class="title">i</span>[1]), float(<span class="title">i</span>[2])) for i in data_list]</span></span><br><span class="line">    <span class="class"><span class="keyword">data</span> = torch.<span class="type">Tensor</span>(<span class="title">data</span>)</span></span><br><span class="line">    x_data = <span class="class"><span class="keyword">data</span>[:, 0:2]</span></span><br><span class="line">    y_data = <span class="class"><span class="keyword">data</span>[:, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">LogisticRegression</span>(<span class="title">nn</span>.<span class="type">Module</span>):</span></span><br><span class="line"><span class="class">    def __init__(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        super(<span class="type">LogisticRegression</span>, <span class="title">self</span>).__init__()</span></span><br><span class="line"><span class="class">        self.lr = nn.<span class="type">Linear</span>(2, 1)</span></span><br><span class="line"><span class="class">        self.sm = nn.<span class="type">Sigmoid</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    def forward(<span class="title">self</span>, <span class="title">x</span>):</span></span><br><span class="line"><span class="class">        x = self.lr(<span class="title">x</span>)</span></span><br><span class="line"><span class="class">        x = self.sm(<span class="title">x</span>)</span></span><br><span class="line"><span class="class">        return x</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">logistic_model = <span class="type">LogisticRegression</span>()</span></span><br><span class="line"><span class="class">loss_fn = nn.<span class="type">BCELoss</span>()</span></span><br><span class="line"><span class="class">optimizer = optim.<span class="type">SGD</span>(<span class="title">logistic_model</span>.<span class="title">parameters</span>(), lr=1e-3, momentum=0.9)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">for epoch in range(50000):</span></span><br><span class="line"><span class="class">    x = <span class="type">Variable</span>(<span class="title">x_data</span>)</span></span><br><span class="line"><span class="class">    y = <span class="type">Variable</span>(<span class="title">y_data</span>.<span class="title">unsqueeze</span>(1))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    out = logistic_model(<span class="title">x</span>)</span></span><br><span class="line"><span class="class">    loss = loss_fn(<span class="title">out</span>, <span class="title">y</span>)</span></span><br><span class="line"><span class="class">    print_loss = loss.data.item()</span></span><br><span class="line"><span class="class">    mask = out.ge(0.5).float()</span></span><br><span class="line"><span class="class">    correct = (<span class="title">mask</span> == <span class="title">y</span>).sum()</span></span><br><span class="line"><span class="class">    acc = correct.data.item() / x.size(0)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    optimizer.zero_grad()</span></span><br><span class="line"><span class="class">    loss.backward()</span></span><br><span class="line"><span class="class">    optimizer.step()</span></span><br><span class="line"><span class="class">    if (<span class="title">epoch</span> + 1) % 1000 == 0:</span></span><br><span class="line"><span class="class">        print('*' * 10)</span></span><br><span class="line"><span class="class">        print('<span class="title">epoch</span>&#123;&#125;'.<span class="title">format</span>(<span class="title">epoch</span> + 1))</span></span><br><span class="line"><span class="class">        print('<span class="title">loss</span> <span class="title">is</span>:&#123;:.4<span class="title">f</span>&#125;'.<span class="title">format</span>(<span class="title">print_loss</span>))</span></span><br><span class="line"><span class="class">        print('<span class="title">acc</span> <span class="title">is</span>:&#123;:.4<span class="title">f</span>&#125;'.<span class="title">format</span>(<span class="title">acc</span>))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">x0 = list(<span class="title">filter</span>(<span class="title">lambda</span> <span class="title">x</span>: <span class="title">x</span>[-1] == 0.0, <span class="title">data</span>))</span></span><br><span class="line"><span class="class">x1 = list(<span class="title">filter</span>(<span class="title">lambda</span> <span class="title">x</span>: <span class="title">x</span>[-1] == 1.0, <span class="title">data</span>))</span></span><br><span class="line"><span class="class">plot_x0_0 = [i[0] for i in x0]</span></span><br><span class="line"><span class="class">plot_x0_1 = [i[1] for i in x0]</span></span><br><span class="line"><span class="class">plot_x1_0 = [i[0] for i in x1]</span></span><br><span class="line"><span class="class">plot_x1_1 = [i[1] for i in x1]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">plt.plot(<span class="title">plot_x0_0</span>, <span class="title">plot_x0_1</span>, '<span class="title">ro'</span>, <span class="title">label</span>='<span class="title">x_0'</span>)</span></span><br><span class="line"><span class="class">plt.plot(<span class="title">plot_x1_0</span>, <span class="title">plot_x1_1</span>, '<span class="title">bo'</span>, <span class="title">label</span>='<span class="title">x_1'</span>)</span></span><br><span class="line"><span class="class">plt.legend(<span class="title">loc</span>='<span class="title">best'</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">w0, w1 = logistic_model.lr.weight[0]</span></span><br><span class="line"><span class="class">w0 = w0.item()</span></span><br><span class="line"><span class="class">w1 = w1.item()</span></span><br><span class="line"><span class="class">b = logistic_model.lr.bias.item()</span></span><br><span class="line"><span class="class">plot_x = np.arange(30, 100, 0.1)</span></span><br><span class="line"><span class="class">plot_y = (-<span class="title">w0</span> * <span class="title">plot_x</span> - <span class="title">b</span>) / w1</span></span><br><span class="line"><span class="class">plt.plot(<span class="title">plot_x</span>, <span class="title">plot_y</span>)</span></span><br><span class="line"><span class="class">plt.show()</span></span><br></pre></td></tr></table></figure><h3 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34.62365962451697</span>,<span class="number">78.0246928153624</span>,<span class="number">0</span></span><br><span class="line"><span class="number">30.2867107622687</span>,<span class="number">43.89499752400101</span>,<span class="number">0</span></span><br><span class="line"><span class="number">35.84740876993872</span>,<span class="number">72.90219802708364</span>,<span class="number">0</span></span><br><span class="line"><span class="number">60.18259938620976</span>,<span class="number">86.3855209546826</span>,<span class="number">1</span></span><br><span class="line"><span class="number">79.0327360507101</span>,<span class="number">75.3443764369103</span>,<span class="number">1</span></span><br><span class="line"><span class="number">45.08327747668339</span>,<span class="number">56.3163717815305</span>,<span class="number">0</span></span><br><span class="line"><span class="number">61.10666453684766</span>,<span class="number">96.51142588489624</span>,<span class="number">1</span></span><br><span class="line"><span class="number">75.02474556738889</span>,<span class="number">46.55401354116538</span>,<span class="number">1</span></span><br><span class="line"><span class="number">76.09878670226257</span>,<span class="number">87.42056971926803</span>,<span class="number">1</span></span><br><span class="line"><span class="number">84.43281996120035</span>,<span class="number">43.53339331072109</span>,<span class="number">1</span></span><br><span class="line"><span class="number">95.86155507093572</span>,<span class="number">38.22527805795094</span>,<span class="number">0</span></span><br><span class="line"><span class="number">75.01365838958247</span>,<span class="number">30.60326323428011</span>,<span class="number">0</span></span><br><span class="line"><span class="number">82.30705337399482</span>,<span class="number">76.48196330235604</span>,<span class="number">1</span></span><br><span class="line"><span class="number">69.36458875970939</span>,<span class="number">97.71869196188608</span>,<span class="number">1</span></span><br><span class="line"><span class="number">39.53833914367223</span>,<span class="number">76.03681085115882</span>,<span class="number">0</span></span><br><span class="line"><span class="number">53.9710521485623</span>,<span class="number">89.20735013750265</span>,<span class="number">1</span></span><br><span class="line"><span class="number">69.07014406283025</span>,<span class="number">52.74046973016765</span>,<span class="number">1</span></span><br><span class="line"><span class="number">67.9468554771161746</span>,<span class="number">67.857410673128</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">*********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch5000</span></span><br><span class="line"><span class="strong">loss is:0.5205</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch10000</span></span><br><span class="line"><span class="strong">loss is:0.4586</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch15000</span></span><br><span class="line"><span class="strong">loss is:0.4240</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch20000</span></span><br><span class="line"><span class="strong">loss is:0.4026</span></span><br><span class="line"><span class="strong">acc is:0.8333</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch25000</span></span><br><span class="line"><span class="strong">loss is:0.3885</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch30000</span></span><br><span class="line"><span class="strong">loss is:0.3786</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch35000</span></span><br><span class="line"><span class="strong">loss is:0.3714</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch40000</span></span><br><span class="line"><span class="strong">loss is:0.3661</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch45000</span></span><br><span class="line"><span class="strong">loss is:0.3620</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch50000</span></span><br><span class="line"><span class="strong">loss is:0.3589</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/1.jpg"><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="一、sigmoid-激活函数"><a href="#一、sigmoid-激活函数" class="headerlink" title="一、sigmoid()激活函数"></a>一、sigmoid()激活函数</h3><p>logistic回归最核心的部分在于sigmoid激活函数，实质上这个训练模型很简单，隐藏层只有一层，再在隐藏层上面加一个sigmoid激活函数就输出到输出层了，sigmoid我放个图：<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/sigmoid.jpg"><br>在经过sigmoid激活之后所有输出值都会介于0到1之间，因为sigmoid函数在原点处变化的非常快，并且在向坐标轴两侧传播时会非常快的趋向0和1，因此作为分类问题的激活函数非常合适。</p><h3 id="二、BCELoss-二分类交叉熵函数"><a href="#二、BCELoss-二分类交叉熵函数" class="headerlink" title="二、BCELoss()二分类交叉熵函数"></a>二、BCELoss()二分类交叉熵函数</h3><p>BCELoss()公式：<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/BCELoss.jpg"><br>在BCELoss()函数中，第一个参数必须在0到1之间，因此一般是要配合sigmoid()函数进行使用。<br>BCELoss()函数与MSELoss()函数的区别在于BCELoss()能够区别正负数，在计算值相加平均的过程中有些误差会消失，但是MSELoss()不能区别正负数，因此误差不会消失。因此分类问题BCELoss较好。<br>还有一点，由于sigmoid函数存在在向坐标轴两侧传播时会非常快的趋向0和1的特性，会导致梯度不明显甚至梯度消失的问题，不利于反向传播。在使用交叉熵作为损失函数后，反向传播的梯度不与sigmoid函数的导数有关，这就从一定程度上避免了梯度下降。<br>但但但但是，在我孱弱短小的数据集下，MSELoss()函数的成绩实现了反超：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">*********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch5000</span></span><br><span class="line"><span class="strong">loss is:0.2167</span></span><br><span class="line"><span class="strong">acc is:0.6111</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch10000</span></span><br><span class="line"><span class="strong">loss is:0.1857</span></span><br><span class="line"><span class="strong">acc is:0.8333</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch15000</span></span><br><span class="line"><span class="strong">loss is:0.1663</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch20000</span></span><br><span class="line"><span class="strong">loss is:0.1538</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch25000</span></span><br><span class="line"><span class="strong">loss is:0.1453</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch30000</span></span><br><span class="line"><span class="strong">loss is:0.1392</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch35000</span></span><br><span class="line"><span class="strong">loss is:0.1348</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch40000</span></span><br><span class="line"><span class="strong">loss is:0.1314</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch45000</span></span><br><span class="line"><span class="strong">loss is:0.1288</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch50000</span></span><br><span class="line"><span class="strong">loss is:0.1267</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br></pre></td></tr></table></figure><br>效果图：<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/4.jpg"><br>实质上，在BCELoss()函数的训练过程中accuracy曾达到过0.8889：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch5000</span></span><br><span class="line"><span class="strong">loss is:0.5468</span></span><br><span class="line"><span class="strong">acc is:0.7778</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch10000</span></span><br><span class="line"><span class="strong">loss is:0.4722</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br><span class="line"><span class="strong">*</span>********<span class="strong">*</span></span><br><span class="line"><span class="strong">epoch15000</span></span><br><span class="line"><span class="strong">loss is:0.4320</span></span><br><span class="line"><span class="strong">acc is:0.8889</span></span><br></pre></td></tr></table></figure><br>效果图<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/5.jpg"><br>但它的误差要大得多，因此这个成绩被“修正”了……<br><img src="/2019/04/08/Pytorch-A-LogisticRegression-Model/3.jpg"><br>具体原因我还分析不出来，估计是测试集样本太少的原因。</p><h3 id="三、41行的ge-函数"><a href="#三、41行的ge-函数" class="headerlink" title="三、41行的ge()函数"></a>三、41行的ge()函数</h3><p>这是在python3中出现的新函数<br>lt(a, b) 相当于 a &lt; b<br>le(a,b) 相当于 a &lt;= b<br>eq(a,b) 相当于 a == b<br>ne(a,b) 相当于 a != b<br>gt(a,b) 相当于 a &gt; b<br>ge(a, b)相当于 a&gt;= b<br>41行代码的功能是如果大于0.5就返回1，反之返回0。返回值是0和1而不是bool类型。</p><h3 id="四、偷懒不存在的"><a href="#四、偷懒不存在的" class="headerlink" title="四、偷懒不存在的"></a>四、偷懒不存在的</h3><p>matplotlib()图像我是拷贝的，具体实现不太清楚，待我仔细研究研究有空单独写一写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开始涉及logistic回归，主要解决分类问题，贴一个学到的简单二分类，看书写的代码问题很大，问题比较多，踩坑踩死我……&lt;br&gt;&lt;img src=&quot;/2019/04/08/Pytorch-A-LogisticRegression-Model/2.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>多维线性回归模型</title>
    <link href="http://yoursite.com/2019/04/03/Multivariable-Linear-Regression-Model/"/>
    <id>http://yoursite.com/2019/04/03/Multivariable-Linear-Regression-Model/</id>
    <published>2019-04-03T10:36:09.000Z</published>
    <updated>2019-04-03T13:33:26.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今儿个是多维线性回归模型～</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_features</span><span class="params">(x)</span>:</span></span><br><span class="line">    x = x.unsqueeze(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> torch.cat([x**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span> + <span class="number">1</span>)], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">W_target = torch.FloatTensor([<span class="number">0.5</span>, <span class="number">3</span>, <span class="number">2.4</span>]).unsqueeze(<span class="number">1</span>)</span><br><span class="line">b_target = torch.FloatTensor([<span class="number">0.9</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x.mm(W_target) + b_target[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batch</span><span class="params">(batch_size=<span class="number">32</span>, random=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> random <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        random = torch.randn(batch_size)</span><br><span class="line">    x = make_features(random)</span><br><span class="line">    y = f(x)</span><br><span class="line">    <span class="keyword">return</span> Variable(x), Variable(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">poly_model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.poly = nn.Linear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.poly(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">model = poly_model()</span><br><span class="line"></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">epoch = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    batch_x, batch_y = get_batch()</span><br><span class="line"></span><br><span class="line">    output = model(batch_x)</span><br><span class="line">    loss = criterion(output, batch_y)</span><br><span class="line">    print_loss = loss.item()</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    optimizer.step()</span><br><span class="line">    epoch += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> print_loss &lt; <span class="number">1e-3</span>:</span><br><span class="line">        Break</span><br><span class="line"></span><br><span class="line">print(<span class="string">"the number of epoches :"</span>, epoch)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_format</span><span class="params">(weight, bias, n)</span>:</span></span><br><span class="line">    func = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        func += <span class="string">' &#123;:.2f&#125; * x^&#123;&#125; +'</span>.format(weight[i - <span class="number">1</span>], i)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'y ='</span> + func + <span class="string">' &#123;:.2f&#125;'</span>.format(bias[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">predict_weight = model.poly.weight.data.numpy().flatten()</span><br><span class="line">predict_bias = model.poly.bias.data.numpy().flatten()</span><br><span class="line">print(<span class="string">'predicted function :'</span>, func_format(predict_weight, predict_bias, <span class="number">3</span>))</span><br><span class="line">real_W = W_target.numpy().flatten()</span><br><span class="line">real_b = b_target.numpy().flatten()</span><br><span class="line">print(<span class="string">'real function :'</span>, func_format(real_W, real_b, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">x = [random.randint(<span class="number">-200</span>, <span class="number">200</span>) * <span class="number">0.01</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">x = np.array(sorted(x))</span><br><span class="line">feature_x, y = get_batch(random=torch.from_numpy(x).float())</span><br><span class="line">y = y.data.numpy()</span><br><span class="line">plt.plot(x, y, <span class="string">'ro'</span>, label=<span class="string">'Original data'</span>)</span><br><span class="line"></span><br><span class="line">model.eval()</span><br><span class="line">x_sample = np.arange(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">0.01</span>)</span><br><span class="line">x, y = get_batch(random=torch.from_numpy(x_sample).float())</span><br><span class="line">y = model(x)</span><br><span class="line">y_sample = y.data.numpy()</span><br><span class="line">plt.plot(x_sample, y_sample, label=<span class="string">'Fitting Line'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> epoches : <span class="number">1727</span></span><br><span class="line">predicted <span class="function"><span class="keyword">function</span> : <span class="title">y</span> = <span class="title">2</span><span class="number">.41</span> * <span class="title">x</span>^<span class="title">3</span> + <span class="title">2</span><span class="number">.99</span> * <span class="title">x</span>^<span class="title">2</span> + <span class="title">0</span><span class="number">.45</span> * <span class="title">x</span>^<span class="title">1</span> + <span class="title">0</span><span class="number">.93</span></span></span><br><span class="line">real <span class="function"><span class="keyword">function</span> : <span class="title">y</span> = <span class="title">2</span><span class="number">.40</span> * <span class="title">x</span>^<span class="title">3</span> + <span class="title">3</span><span class="number">.00</span> * <span class="title">x</span>^<span class="title">2</span> + <span class="title">0</span><span class="number">.50</span> * <span class="title">x</span>^<span class="title">1</span> + <span class="title">0</span><span class="number">.90</span></span></span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/2019/04/03/Multivariable-Linear-Regression-Model/1.jpg"><p>这个效果图在matplotlib中的实现要比一维线性回归模型要难一些，具体是：<br>80-84行先随机给一些在拟合方程上的点集，命名为’Original data’；<br>86-92行描绘出预测曲线，可以比较直观的看重合度。预测曲线在x轴上位于-2到2之间，x轴上的各点之间相差0.01，主要是为了曲线更加平滑。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="一、unsqueeze"><a href="#一、unsqueeze" class="headerlink" title="一、unsqueeze()"></a>一、unsqueeze()</h3><p>这里先介绍squeeze()函数，squeeze()中的参数0、1分别代表第零、第一维度，也就是行和列，理所应当的，squeeze(0)表示如果第零维度值为1，则去掉，否则不变。我写个例子：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line"><span class="selector-tag">a</span> = torch.randn(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">a</span>.squeeze(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">-0.2699</span>],</span><br><span class="line">[ <span class="number">0.3355</span>],</span><br><span class="line">[<span class="number">-0.3069</span>]])</span><br><span class="line">tensor([<span class="number">-0.2699</span>, <span class="number">0.3355</span>, <span class="number">-0.3069</span>])</span><br></pre></td></tr></table></figure><br>我感觉就是差不多行列变换，在行或者列为1的情况下。<br>unsqueeze()就是反向操作，咋变过来的就咋变回去：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line"><span class="selector-tag">a</span> = torch.randn(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">a</span>.squeeze(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">a</span>.unsqueeze(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="string">[[-0.4933],</span></span><br><span class="line"><span class="string">[ 0.0155],</span></span><br><span class="line"><span class="string">[-0.5852]]</span>)</span><br><span class="line">tensor([<span class="number">-0.4933</span>, <span class="number">0.0155</span>, <span class="number">-0.5852</span>])</span><br><span class="line">tensor(<span class="string">[[-0.4933],</span></span><br><span class="line"><span class="string">[ 0.0155],</span></span><br><span class="line"><span class="string">[-0.5852]]</span>)</span><br></pre></td></tr></table></figure></p><h3 id="二、torch-cat"><a href="#二、torch-cat" class="headerlink" title="二、torch.cat()"></a>二、torch.cat()</h3><p>torch.cat()就是讲Tensor拼接在一起，有没有想到C里的strcat()，差不多～cat全称是concatnate<br>torch.cat()放两个参数，第一个是放需要拼接的Tensor，可以这样：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C=torch.cat<span class="comment">((A,B)</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>比较常见，也可以是测试代码里的这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cat([x**<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span> + <span class="number">1</span>)], <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>这里是通过循环的形式拼接三个Tensor。<br>第二个参数是横向或者纵向拼接，事实上还是按照第零维度或者第一维度比较好理解：0代表行与行拼接，1代表列与列拼接。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>具体思路和一维线性回归差不多，就是前期前向传播构成计算图是函数与函数之间相互嵌套比较复杂。<br>这个我发现一个以前没有注意到的点：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">x</span><span class="selector-class">.mm</span>(<span class="selector-tag">W_target</span>) + <span class="selector-tag">b_target</span><span class="selector-attr">[0]</span></span><br></pre></td></tr></table></figure><br>其中x为32行3列，W_target为3行1列，b_target只有一个元素，照道理矩阵加法不能成立，但是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy</span><br><span class="line">x = torch.ones(<span class="number">3</span>)</span><br><span class="line">x = x.unsqueeze(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(x)</span></span></span><br><span class="line">x = torch.cat([x**<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>)], <span class="number">1</span>)</span><br><span class="line">W_target = torch.FloatTensor([<span class="number">0.5</span>, <span class="number">3</span>, <span class="number">2.4</span>]).unsqueeze(<span class="number">1</span>)</span><br><span class="line">b_target = torch.FloatTensor([<span class="number">0.9</span>])</span><br><span class="line">y = x.mm(W_target)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(y)</span></span></span><br><span class="line">y += b_target[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(y)</span></span></span><br></pre></td></tr></table></figure><br>结果为：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="string">[[1.],</span></span><br><span class="line"><span class="string">[1.],</span></span><br><span class="line"><span class="string">[1.]]</span>)</span><br><span class="line">tensor(<span class="string">[[5.9000],</span></span><br><span class="line"><span class="string">[5.9000],</span></span><br><span class="line"><span class="string">[5.9000]]</span>)</span><br><span class="line">tensor(<span class="string">[[6.8000],</span></span><br><span class="line"><span class="string">[6.8000],</span></span><br><span class="line"><span class="string">[6.8000]]</span>)</span><br></pre></td></tr></table></figure><br>实际上是每行都加了b！<br><img src="/2019/04/03/Multivariable-Linear-Regression-Model/2.jpg"><br>比较神奇~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今儿个是多维线性回归模型～&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>一维线性回归模型</title>
    <link href="http://yoursite.com/2019/04/02/One-Dimensional-Linear-Regression-Model/"/>
    <id>http://yoursite.com/2019/04/02/One-Dimensional-Linear-Regression-Model/</id>
    <published>2019-04-02T12:38:34.000Z</published>
    <updated>2019-04-03T13:33:29.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来今天是开始读取MNIST数据集完成手写数字识别的，但是遇到很大问题，MNIST的图像通道不一样导致运行错误。所以转向简单一点的线性模型来做做看。</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.optim as optim</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from torch.autograd import <span class="symbol">Variable</span></span><br><span class="line"></span><br><span class="line">x_train = np.array(</span><br><span class="line">    [[<span class="number">3.3</span>], [<span class="number">4.4</span>], [<span class="number">5.5</span>], [<span class="number">6.71</span>], [<span class="number">6.93</span>], [<span class="number">4.168</span>], [<span class="number">9.779</span>], [<span class="number">6.182</span>], [<span class="number">7.59</span>],</span><br><span class="line">    [<span class="number">2.167</span>], [<span class="number">7.042</span>], [<span class="number">10.791</span>], [<span class="number">5.313</span>], [<span class="number">7.997</span>], [<span class="number">3.1</span>]],</span><br><span class="line">    dtype=np.float32)</span><br><span class="line">y_train = np.array(</span><br><span class="line">    [[<span class="number">1.7</span>], [<span class="number">2.76</span>], [<span class="number">2.09</span>], [<span class="number">3.19</span>], [<span class="number">1.694</span>], [<span class="number">1.573</span>], [<span class="number">3.366</span>], [<span class="number">2.596</span>], [<span class="number">2.53</span>],</span><br><span class="line">    [<span class="number">1.221</span>], [<span class="number">2.827</span>], [<span class="number">3.465</span>], [<span class="number">1.65</span>], [<span class="number">2.904</span>], [<span class="number">1.3</span>]],</span><br><span class="line">    dtype=np.float32)</span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">class <span class="symbol">LinearRegression</span>(nn.<span class="symbol">Module</span>):</span><br><span class="line">    def <span class="symbol">__init__</span>(self):</span><br><span class="line">        super(<span class="symbol">LinearRegression</span>, self).<span class="symbol">__init__</span>()</span><br><span class="line">        self.linear = nn.<span class="symbol">Linear</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        return out</span><br><span class="line"></span><br><span class="line">model = <span class="symbol">LinearRegression</span>()</span><br><span class="line"></span><br><span class="line">loss_fn = nn.<span class="symbol">MSELoss</span>()</span><br><span class="line">optimizer = optim.<span class="symbol">SGD</span>(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">epoch_n = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    inputs = <span class="symbol">Variable</span>(x_train)</span><br><span class="line">    target = <span class="symbol">Variable</span>(y_train)</span><br><span class="line"></span><br><span class="line">    out = model(inputs)</span><br><span class="line">    loss = loss_fn(out, target)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    if epoch <span class="comment">% 100 == 0:</span></span><br><span class="line">        print(<span class="string">"Epoch[&#123;&#125;/&#123;&#125;], Loss:&#123;:.6f&#125;"</span>.format(epoch, epoch_n, loss.item())</span><br><span class="line"></span><br><span class="line">model.eval()</span><br><span class="line">predict = model(<span class="symbol">Variable</span>(x_train))</span><br><span class="line">predict = predict.data.numpy()</span><br><span class="line">plt.plot(x_train.numpy(), y_train.numpy(), <span class="string">"ro"</span>, label=<span class="string">"Original Data"</span>)</span><br><span class="line">plt.plot(x_train.numpy(), predict, label=<span class="string">"Fitting Line"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[0/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1.168603</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[100/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.179088</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[200/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.178578</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[300/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.178095</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[400/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.177635</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[500/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.177198</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[600/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.176784</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[700/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.176390</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[800/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.176015</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-attr">[900/1000]</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.175660</span></span><br></pre></td></tr></table></figure><h3 id="matplotlib图像"><a href="#matplotlib图像" class="headerlink" title="matplotlib图像"></a>matplotlib图像</h3><img src="/2019/04/02/One-Dimensional-Linear-Regression-Model/1.jpg"><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>先给几个横坐标和预期纵坐标，然后将numpy的ndarray形式转换成torch的tensor形式。<br>接着定义一个类继承自torch.nn.Module，用于前向传播，<strong>init</strong>()和forward()两个函数是自定义类的主要函数。在<strong>init</strong>()中添加一句super(LinearRegression, self).<strong>init</strong>()用于继承父类的初始化函数。<strong>init</strong>()中主要是对神经网络的模块进行声明，具体函数实现则是在forward()中。自定义类中的成员都通过self指针来进行访问，所以参数列表中都包含了self。<br>在这里误差函数还是使用MSELoss()用于计算均方误差，因为有的点可能在直线下面，我们不允许有负数存在；优化函数则使用SGD()，具体不知道为什么，但是换成Adam()运行效果没有SGD()好。<br>开始训练时要把节点用Variable()纳入计算图中，不然计算不了梯度。<br>optimizer.zero_grad()用于梯度置零，否则会造成结果不收敛。<br>loss.backward()计算梯度。<br>optimizer.step()更新梯度。</p><p>打印结果后可以整一个matplotlib的图出来看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来今天是开始读取MNIST数据集完成手写数字识别的，但是遇到很大问题，MNIST的图像通道不一样导致运行错误。所以转向简单一点的线性模型来做做看。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>走向自动化：神经网络训练模型加入torch.nn和torch.optim</title>
    <link href="http://yoursite.com/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/"/>
    <id>http://yoursite.com/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/</id>
    <published>2019-04-01T11:45:11.000Z</published>
    <updated>2019-04-03T06:44:55.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将尝试在上一篇博客的训练模型的基础上加入torch.nn包以及torch.optim包来优化我的训练模型，使其在更少的训练次数里得到更好的优化结果。</p><a id="more"></a><h2 id="一、torch-nn包"><a href="#一、torch-nn包" class="headerlink" title="一、torch.nn包"></a>一、torch.nn包</h2><p>Pytorch中torch.nn包提供了很多实现神经网络的具体功能的类，具体本文就不展开讲了，以后肯定会涉及到，本文主要介绍在训练模型里用到的相关函数。<br>测试代码<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">batch_n = 100</span><br><span class="line">hidden_layer = 100</span><br><span class="line">input_data = 1000</span><br><span class="line">output_data = 10</span><br><span class="line"></span><br><span class="line">x = Variable(torch.randn(batch_n, input_data), requires_grad=False)</span><br><span class="line">y = Variable(torch.randn(batch_n, output_data), requires_grad=False)</span><br><span class="line"></span><br><span class="line">models = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(input_data, hidden_layer),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(hidden_layer, output_data))</span><br><span class="line"></span><br><span class="line">epoch_n = 10000</span><br><span class="line">learning_rate = 1e-4</span><br><span class="line">loss_fn = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred = models(x)</span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    if epoch % 1000 == 0:</span><br><span class="line">        print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.item()))</span><br><span class="line">    models.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    for param in models.parameters():</span><br><span class="line">        param.data -= param.grad.data * learning_rate</span><br></pre></td></tr></table></figure><br>测试结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.9800</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.9122</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8534</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8013</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7544</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7119</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6727</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6366</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6031</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.5715</span></span><br></pre></td></tr></table></figure></p><h3 id="1-torch-nn-Sequential"><a href="#1-torch-nn-Sequential" class="headerlink" title="1.torch.nn.Sequential"></a>1.torch.nn.Sequential</h3><p>Sequential类是一种序列容器，通过在容器中嵌套各种实现神经网络中具体功能的类，来完成神经网络模型的搭建。如果说上一篇博客提到的Variable类是将前向传播中的计算过程变成一张计算图，那么Sequential类就是将计算图封装在容器里，更为特殊的是，计算图的每一个步骤在容器里都有自己的名字，因此每一个步骤都可以当作模块单独拿出来调用。模块的命名方式可以是按照数字序列从零开始命名，也可以import一个OrderedDict包以有序字典的形式命名，这种方法的话对每个模块可以自己命名，有点类似于python列表和字典的区别。例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line">models = torch<span class="selector-class">.nn</span><span class="selector-class">.Sequential</span>(</span><br><span class="line">    OrderedDict([</span><br><span class="line">        (<span class="string">"Line1"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.Linear</span>(input_data, hidden_layer)),</span><br><span class="line">        (<span class="string">"ReLU1"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.ReLU</span>()),</span><br><span class="line">        (<span class="string">"Line2"</span>, torch<span class="selector-class">.nn</span><span class="selector-class">.Linear</span>(hidden_layer, output_data))])</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="2-torch-nn-Linear"><a href="#2-torch-nn-Linear" class="headerlink" title="2.torch.nn.Linear"></a>2.torch.nn.Linear</h3><p>torch.nn.Linear用于定义模型的线性层，即完成不同层之间的线性变换（如模型中输入层和隐藏层以及隐藏层和输出层的线性变换）。Linear有三个参数，分别是输入特征数，输出特征数以及是否使用偏置（默认为True）。Linear会自动生成权重参数和偏置（默认情况），因此在模型中不需要单独定义如w1w2之类的权重参数，并且Linear提供比原先自定义权重参数时使用的randn随机正太分布更好的参数初始化方法，让人放心～</p><h3 id="3-torch-nn-ReLU"><a href="#3-torch-nn-ReLU" class="headerlink" title="3.torch.nn.ReLU"></a>3.torch.nn.ReLU</h3><p>一看名字就是激活函数，先挖一个坑，以后一起讲，不讲可以打我，话放在这里了。</p><h3 id="4-仨常见损失函数"><a href="#4-仨常见损失函数" class="headerlink" title="4.仨常见损失函数"></a>4.仨常见损失函数</h3><p>torch.nn.MSELoss：均方误差函数<br>torch.nn.L1Loss：平均绝对误差函数<br>torch.nn.CrossEntropyLoss：交叉熵函数<br>仨在定义类的对象时都不需要传参，只要在使用实例时输入维度一样的参数即可计算（交叉熵函数要满足交叉熵的计算条件）</p><h3 id="5-torch-nn-parameter"><a href="#5-torch-nn-parameter" class="headerlink" title="5.torch.nn.parameter"></a>5.torch.nn.parameter</h3><p>有点搞不明白，所以看了一下官方的docs：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">r"""A kind of Tensor that is to be considered a module parameter.</span><br><span class="line"></span><br><span class="line">Parameters are :class:`~torch.Tensor` subclasses, that have a</span><br><span class="line">very special property when used <span class="keyword">with</span> :<span class="keyword">class</span>:<span class="string">`Module`</span> s - <span class="keyword">when</span> they<span class="string">'re</span></span><br><span class="line"><span class="string">assigned as Module attributes they are automatically added to the list of</span></span><br><span class="line"><span class="string">its parameters, and will appear e.g. in :meth:`~Module.parameters` iterator.</span></span><br><span class="line"><span class="string">Assigning a Tensor doesn'</span>t have such effect. This <span class="keyword">is</span> because one might</span><br><span class="line">want <span class="keyword">to</span> <span class="keyword">cache</span> <span class="keyword">some</span> <span class="keyword">temporary</span> state, <span class="keyword">like</span> <span class="keyword">last</span> hidden state <span class="keyword">of</span> the RNN, <span class="keyword">in</span></span><br><span class="line">the model. <span class="keyword">If</span> there was <span class="keyword">no</span> such <span class="keyword">class</span> <span class="keyword">as</span> :<span class="keyword">class</span>:<span class="string">`Parameter`</span>, these</span><br><span class="line">temporaries would <span class="keyword">get</span> registered too.</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line"><span class="keyword">data</span> (Tensor): parameter tensor.</span><br><span class="line">requires_grad (<span class="built_in">bool</span>, optional): <span class="keyword">if</span> the parameter requires gradient. See</span><br><span class="line">:<span class="keyword">ref</span>:<span class="string">`excluding-subgraphs`</span> <span class="keyword">for</span> more details. <span class="keyword">Default</span>: <span class="string">`True`</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><br>看着像是一个迭代器，也就是说在使用torch.nn包中的类进行神经网络的搭建之后，网络的参数都会保存在parameters()函数当中，访问models中的参数是对models.parameters()进行遍历完成的，然后才对每个遍历的参数进行更新。</p><h3 id="6"><a href="#6" class="headerlink" title="6.???"></a>6.???</h3><p>我一开始在看代码的时候发现<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">models</span><span class="selector-class">.zero_grad</span>()</span><br></pre></td></tr></table></figure><br>这个梯度置零的函数放的位置不太对，然后试着把它注释掉，结果一运行发现：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1.0549</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2391</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2478</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.1410</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.1171</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0837</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0743</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0634</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0581</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9000</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.0590</span></span><br></pre></td></tr></table></figure><br>误差降低了十倍？<br>这超出了我的知识范围……希望以后有能力解答这个问题……<br><img src="/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/1.jpg"></p><h2 id="二、torch-optim"><a href="#二、torch-optim" class="headerlink" title="二、torch.optim"></a>二、torch.optim</h2><p>我的训练模型到现在仍在自定义学习速率，这是因为输出层只有一个比较简单导致的。如果网络一复杂仍然自定义学习速率来进行权重参数的更新是非常不现实的，torch.optim包中正好提供了很多自动优化的类，下面介绍其中的Adam类。</p><p>测试代码<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">batch_n = 100</span><br><span class="line">hidden_layer = 100</span><br><span class="line">input_data = 1000</span><br><span class="line">output_data = 10</span><br><span class="line"></span><br><span class="line">x = Variable(torch.randn(batch_n, input_data), requires_grad=False)</span><br><span class="line">y = Variable(torch.randn(batch_n, output_data), requires_grad=False)</span><br><span class="line"></span><br><span class="line">models = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(input_data, hidden_layer), torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(hidden_layer, output_data))</span><br><span class="line"></span><br><span class="line">epoch_n = 100</span><br><span class="line">learning_rate = 1e-4</span><br><span class="line">loss_fn = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.Adam(models.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred = models(x)</span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    if epoch % 10 == 0:</span><br><span class="line">        print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.item()))</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><br>测试结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1.0926</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.8934</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:20</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.7386</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:30</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.6166</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:40</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.5177</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:50</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.4355</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:60</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.3654</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:70</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.3050</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:80</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2525</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:90</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:0.2068</span></span><br></pre></td></tr></table></figure><br>仅仅100次就达到了比优化前10000次更好的效果</p><h3 id="1-torch-optim-Adam"><a href="#1-torch-optim-Adam" class="headerlink" title="1.torch.optim.Adam"></a>1.torch.optim.Adam</h3><p>torch.optim.Adam类有两个参数，分别是需要被优化的参数和学习速率（默认为1e-2）。Adam的表现之所以这么优秀，是因为它可以做到使学习速率自适应调节，达到最好的速率。<br>加入优化算法，每次训练的梯度更新可以写成<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.<span class="built_in">step</span>()</span><br></pre></td></tr></table></figure></p><h3 id="2"><a href="#2" class="headerlink" title="2.???"></a>2.???</h3><p>注释掉梯度置零函数<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">optimizer</span><span class="selector-class">.zero_grad</span>()</span><br></pre></td></tr></table></figure><br>好像训练效果又好了那么一点点……<br><img src="/2019/04/01/Pytorch-A-Simple-Neural-Networks-With-torch-nn-and-torch-optim/2.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将尝试在上一篇博客的训练模型的基础上加入torch.nn包以及torch.optim包来优化我的训练模型，使其在更少的训练次数里得到更好的优化结果。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>简单训练模型加入autograd实现自动梯度计算</title>
    <link href="http://yoursite.com/2019/03/31/Pytorch-A-Simple-Neural-Networks-With-Autograd/"/>
    <id>http://yoursite.com/2019/03/31/Pytorch-A-Simple-Neural-Networks-With-Autograd/</id>
    <published>2019-03-31T10:40:23.000Z</published>
    <updated>2019-03-31T11:25:05.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天的训练模型将在昨天的训练模型基础上做出改进，通过Pytorch中的autograd包替代后向传播中的手动链式求导，实现自动梯度功能。<br>（昨天的后向传播部分写的非常简略，主要是里面有个.t()函数一直查不出来是干啥用的……感觉自己理解的也非常模糊，只知道是在求偏导数……幸好有autograd可以掩盖我的无知……）</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> torch</span><br><span class="line"></span><br><span class="line">from torch.autograd <span class="built_in">import</span> Variable</span><br><span class="line"><span class="attr">batch_n</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">hidden_layer</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">input_data</span> = <span class="number">1000</span></span><br><span class="line"><span class="attr">output_data</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">x</span> = Variable(torch.randn(batch_n, input_data), <span class="attr">requires_grad=False)</span></span><br><span class="line"><span class="attr">y</span> = Variable(torch.randn(batch_n, output_data), <span class="attr">requires_grad=False)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">w1</span> = Variable(torch.randn(input_data, hidden_layer), <span class="attr">requires_grad=True)</span></span><br><span class="line"><span class="attr">w2</span> = Variable(torch.randn(hidden_layer, output_data), <span class="attr">requires_grad=True)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">epoch_n</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">learning_rate</span> = <span class="number">1</span>e-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">for epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line">    <span class="attr">y_pred</span> = x.mm(w1).clamp(<span class="attr">min=0).mm(w2)</span></span><br><span class="line">    <span class="attr">loss</span> = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    w1.data <span class="attr">-=</span> learning_rate * w1.grad.data</span><br><span class="line">    w2.data <span class="attr">-=</span> learning_rate * w2.grad.data</span><br><span class="line"></span><br><span class="line">    w1.grad.data.zero_()</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:46125084.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:97735776.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:353886400.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:681477440.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:70418120.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:19572480.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:10264789.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:6297184.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:4209952.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2988804.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2225728.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:11</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1726369.1250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:12</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1387307.2500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:13</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1149427.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:14</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:977541.5625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:15</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:849593.3125</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:16</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:751535.7500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:17</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:674315.6875</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:18</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:611959.5625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:19</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:560407.1250</span></span><br></pre></td></tr></table></figure><br>由于在定义输入层和输出层时使用的是randn随即正态分布函数，运行结果会有很大不同，我挑了一组比较明显的结果。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>torch.grad包u实现自动梯度的过程大致为先通过定义的Tensor类型数据变量在前向传播中生成计算图，然后根据计算图和输出结果计算出每个参数需要更新的梯度，并通过后向传播完成对参数的梯度更新。<br>开头需要导入torch.grad包中的Variable类从而对Tensor数据类型变量进行封装。在计算图中，每个节点都应该是Variable类型的对象，这样才能应用自动梯度的功能。<br>requires_grad一看名字就知道，决定了Variable类型是否需要计算梯度，w1、w2是权重参数，所以为True。<br>.backward()函数根据我们自己设置的需求求出梯度值并保留，再结合学习速率对权重参数进行更新，最后通过.zero_()函数对grad.data进行置零，否则梯度值会一直累加，影响后边儿计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天的训练模型将在昨天的训练模型基础上做出改进，通过Pytorch中的autograd包替代后向传播中的手动链式求导，实现自动梯度功能。&lt;br&gt;（昨天的后向传播部分写的非常简略，主要是里面有个.t()函数一直查不出来是干啥用的……感觉自己理解的也非常模糊，只知道是在求偏导数……幸好有autograd可以掩盖我的无知……）&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>入门神经网络训练模型搭建</title>
    <link href="http://yoursite.com/2019/03/30/Pytorch-A-Simple-Neural-Networks/"/>
    <id>http://yoursite.com/2019/03/30/Pytorch-A-Simple-Neural-Networks/</id>
    <published>2019-03-30T12:54:32.000Z</published>
    <updated>2019-03-31T11:25:17.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天试着搭建一个小的神经网络训练模型，通过训练会使预测值和真实值逐渐逼近。</p><a id="more"></a><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#一次输入数据的数量 即100组数据</span></span><br><span class="line"><span class="attr">batch_n</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#每组数据的数据特征数</span></span><br><span class="line"><span class="attr">input_data</span> = <span class="number">1000</span></span><br><span class="line"><span class="comment">#数据经过隐藏层后保留的数据特征的个数（只考虑一层隐藏层）</span></span><br><span class="line"><span class="attr">hidden_layer</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#每组输出数据的数据特征数</span></span><br><span class="line"><span class="attr">output_data</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入层和输出层</span></span><br><span class="line"><span class="attr">x</span> = torch.randn(batch_n, input_data)</span><br><span class="line"><span class="attr">y</span> = torch.randn(batch_n, output_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入层到隐藏层的权重参数和隐藏层到输出层的权重参数</span></span><br><span class="line"><span class="attr">w1</span> = torch.randn(input_data, hidden_layer)</span><br><span class="line"><span class="attr">w2</span> = torch.randn(hidden_layer, output_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练次数</span></span><br><span class="line"><span class="attr">epoch_n</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">#学习速率</span></span><br><span class="line"><span class="attr">learning_rate</span> = <span class="number">1</span>e-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">for epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line">    <span class="attr">h1</span> = x.mm(w1)</span><br><span class="line">    <span class="attr">h1</span> = h1.clamp(<span class="attr">min=0)</span></span><br><span class="line">    <span class="attr">y_pred</span> = h1.mm(w2)</span><br><span class="line"></span><br><span class="line">    <span class="attr">loss</span> = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;"</span>.format(epoch, loss))</span><br><span class="line"></span><br><span class="line">    <span class="attr">grad_y_pred</span> = <span class="number">2</span> * (y_pred - y)</span><br><span class="line">    <span class="attr">grad_w2</span> = h1.t().mm(grad_y_pred)</span><br><span class="line"></span><br><span class="line">    <span class="attr">grad_h</span> = grad_y_pred.clone()</span><br><span class="line">    <span class="attr">grad_h</span> = grad_h.mm(w2.t())</span><br><span class="line">    grad_h.clamp_(<span class="attr">min=0)</span></span><br><span class="line">    <span class="attr">grad_w1</span> = x.t().mm(grad_h)</span><br><span class="line"></span><br><span class="line">    w1 <span class="attr">-=</span> learning_rate * grad_w1</span><br><span class="line">    w2 <span class="attr">-=</span> learning_rate * grad_w2</span><br></pre></td></tr></table></figure><p>测试结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:58291408.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:1</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:159056992.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:2</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:521834688.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:3</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:522471264.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:4</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:4316087.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:5</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:3243381.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:6</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2620373.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:7</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:2226943.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:8</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1957315.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:9</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1758743.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:10</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1603234.8750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:11</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1475709.2500</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:12</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1367604.5000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:13</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1273678.0000</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:14</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1190754.3750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:15</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1116698.3750</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:16</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:1049910.6250</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:17</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:989398.0625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:18</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:934201.0625</span></span><br><span class="line"><span class="selector-tag">Epoch</span><span class="selector-pseudo">:19</span>, <span class="selector-tag">Loss</span><span class="selector-pseudo">:883768.8750</span></span><br></pre></td></tr></table></figure></p><h2 id="一、前向传播"><a href="#一、前向传播" class="headerlink" title="一、前向传播"></a>一、前向传播</h2><p>26-28行其实就是用输入层进入隐藏层再进入输出层的整个过程了，通过mm函数（注意不是mul函数）实现了数据特征从1000到100到10的变化，在计算过程中还对矩阵的乘积使用clamp函数进行裁剪，将小于0的数赋值为0（clamp函数本来有3个参数，分别是需要进行裁剪的Tensor变量，裁剪的上边界和下边界，在这里需要裁剪的变量是其本身，只定义下边界不定义上边界是为了实现ReLU激活函数的功能，但并不完全等于ReLU激活函数）<br>30-31行计算损失函数并打印，这里使用的是均方误差的计算方法，给个图：<br><img src="/2019/03/30/Pytorch-A-Simple-Neural-Networks/1.jpg"><br>求出来是真实值和预测值的差值的平方和。</p><h2 id="二、后向传播"><a href="#二、后向传播" class="headerlink" title="二、后向传播"></a>二、后向传播</h2><p>后向传播主要是为了对权重值w进行优化。<br>33-39行grad_w1和grad_w2是更新的权重梯度值。（梯度就是多元函数的偏导数以向量形式表示）<br>41-42行在得到参数的梯度值之后，按照设置好的学习速率对权重值进行更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天试着搭建一个小的神经网络训练模型，通过训练会使预测值和真实值逐渐逼近。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>基本是最终版本的小工程</title>
    <link href="http://yoursite.com/2019/03/27/OpenCV-Learning-Day-17/"/>
    <id>http://yoursite.com/2019/03/27/OpenCV-Learning-Day-17/</id>
    <published>2019-03-27T06:37:24.000Z</published>
    <updated>2019-03-31T11:25:30.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天角度定位的问题解决了……角度还是算不出来，我调整了几个函数，在图像旋转之后再次使用Rotate()函数得到外接矩形的点阵信息，然后标记ROI图形区域裁剪图像并用imwrite()函数读出。</p><a id="more"></a><h2 id="基本是最终版本的测试代码"><a href="#基本是最终版本的测试代码" class="headerlink" title="基本是最终版本的测试代码"></a>基本是最终版本的测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> angle;</span><br><span class="line">Point2f rect[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Mat&amp; img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutImage</span><span class="params">(Mat&amp; img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveImage</span><span class="params">(Mat&amp; img,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBorder</span><span class="params">(Mat&amp; src,Mat&amp; dst,<span class="keyword">int</span> B,<span class="keyword">int</span> G,<span class="keyword">int</span> R)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        makeBorder(images[i],images[i],<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        Rotate(images[i],images[i],angle);</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        <span class="comment">//drawLine(images[i]);</span></span><br><span class="line">        cutImage(images[i]);</span><br><span class="line">        saveImage(images[i],i);</span><br><span class="line">        imshow(<span class="string">"image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(dstImage, dstImage, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(dstImage, dstImage, <span class="number">254</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="comment">//imshow("srcImage", dstImage);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(dstImage, contours, hierarcy, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line">    sort(contours.begin(),contours.end(),ContoursSortFunction);</span><br><span class="line">    contours.erase(contours.begin());</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i])); </span><br><span class="line">        box[i].points(rect); </span><br><span class="line">        angle = box[i].angle;</span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; 4; j++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; rect[j] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (contourArea(contour1) &gt; contourArea(contour2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>&#123;</span><br><span class="line">    makeBorder(src,dst,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//rotate</span></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">( (<span class="keyword">float</span>)(dst.cols/<span class="number">2</span>) , (<span class="keyword">float</span>) (dst.rows/<span class="number">2</span>))</span></span>;</span><br><span class="line">    Mat affine_matrix = getRotationMatrix2D( center, angle, <span class="number">1.0</span> );</span><br><span class="line">    warpAffine(dst, dst, affine_matrix, dst.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Mat&amp; img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        line(img, rect[i], rect[(i+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">2</span>,LINE_AA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutImage</span><span class="params">(Mat&amp; img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = rect[<span class="number">2</span>].x - rect[<span class="number">1</span>].x;</span><br><span class="line">    <span class="keyword">int</span> height = rect[<span class="number">0</span>].y - rect[<span class="number">1</span>].y;</span><br><span class="line">    Mat ROI = img(Rect(rect[<span class="number">1</span>].x,rect[<span class="number">1</span>].y,width,height));</span><br><span class="line">    ROI.copyTo(img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveImage</span><span class="params">(Mat&amp; img,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(path,<span class="string">"./outputImages/%d.jpg"</span>,i);</span><br><span class="line">    imwrite(path,img);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBorder</span><span class="params">(Mat&amp; src,Mat&amp; dst,<span class="keyword">int</span> B,<span class="keyword">int</span> G,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxBorder =(<span class="keyword">int</span>) (max(src.cols, src.rows)* <span class="number">1.414</span>);</span><br><span class="line">    <span class="keyword">int</span> dx = (maxBorder - src.cols)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> dy = (maxBorder - src.rows)/<span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, dy, dy, dx, dx, BORDER_CONSTANT,Scalar(B,G,R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>测试图没啥好看的，老师发的零件图片，效果图也不贴了（不是我懒）<br>并无新函数，但就这玩意儿我写了三天……后面算是整理的比较清楚了，功能基本上都写在函数里了，就酱。<br>开始学习Pytorch。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天角度定位的问题解决了……角度还是算不出来，我调整了几个函数，在图像旋转之后再次使用Rotate()函数得到外接矩形的点阵信息，然后标记ROI图形区域裁剪图像并用imwrite()函数读出。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>warpAffine()函数实现最小外接矩形和原始图像平行</title>
    <link href="http://yoursite.com/2019/03/26/OpenCV-Learning-Day-16/"/>
    <id>http://yoursite.com/2019/03/26/OpenCV-Learning-Day-16/</id>
    <published>2019-03-26T12:26:09.000Z</published>
    <updated>2019-03-31T11:25:42.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来今天想一并吧图像的旋转和裁剪给一起完成了，但是图像在旋转之后的坐标定位一直有问题，所以今天只好放出在昨天的博客的基础上做的图像旋转的函数，旋转之后目标图像的最小外接矩形是和原始图像平行的，为的是设置ROI为裁剪图像做准备。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> angle;</span><br><span class="line">Point pointlu;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">        Rotate(images[i],images[i],angle);</span><br><span class="line">        imshow(<span class="string">"image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(dstImage, dstImage, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(dstImage, dstImage, <span class="number">254</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="comment">//imshow("srcImage", dstImage);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(dstImage, contours, hierarcy, RETR_LIST, CHAIN_APPROX_NONE);</span><br><span class="line">    sort(contours.begin(),contours.end(),ContoursSortFunction);</span><br><span class="line">    contours.erase(contours.begin());</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); <span class="comment">//定义最小外接矩形集合</span></span><br><span class="line">    Point2f rect[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i])); <span class="comment">//计算每个轮廓最小外接矩形</span></span><br><span class="line">        box[i].points(rect); <span class="comment">//把最小外接矩形四个端点复制给rect数组</span></span><br><span class="line">        angle = box[i].angle;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            line(srcImg, rect[j], rect[(j+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)); <span class="comment">//绘制最小外接矩形每条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ContoursSortFunction</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; contour1,<span class="built_in">vector</span>&lt;Point&gt; contour2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (contourArea(contour1) &gt; contourArea(contour2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(Mat &amp;src,Mat &amp;dst,<span class="keyword">float</span> angle)</span></span>&#123;</span><br><span class="line">    <span class="comment">//fill</span></span><br><span class="line">    <span class="keyword">int</span> maxBorder =(<span class="keyword">int</span>) (max(src.cols, src.rows)* <span class="number">1.414</span>); <span class="comment">//即为sqrt(2)*max</span></span><br><span class="line">    <span class="keyword">int</span> dx = (maxBorder - src.cols)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> dy = (maxBorder - src.rows)/<span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src, dst, dy, dy, dx, dx, BORDER_CONSTANT,Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//rotate</span></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">( (<span class="keyword">float</span>)(dst.cols/<span class="number">2</span>) , (<span class="keyword">float</span>) (dst.rows/<span class="number">2</span>))</span></span>;</span><br><span class="line">    Mat affine_matrix = getRotationMatrix2D( center, angle, <span class="number">1.0</span> );<span class="comment">//求得旋转矩阵</span></span><br><span class="line">    warpAffine(dst, dst, affine_matrix, dst.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、copyMakeBorder-边缘扩充函数"><a href="#一、copyMakeBorder-边缘扩充函数" class="headerlink" title="一、copyMakeBorder()边缘扩充函数"></a>一、copyMakeBorder()边缘扩充函数</h2><p>函数原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyMakeBorder</span>(<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; src, Mat&amp; dst,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> top, <span class="keyword">int</span> bottom, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType, <span class="keyword">const</span> Scalar&amp; <span class="keyword">value</span>=Scalar(</span>)</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>第一个参数和第二个参数分别是输入图像和输出图像<br>top、bottom、left、right参数非常明显，分别是顶端、底部、左边和右边所需填充的距离<br>borderType：扩充边缘的类型，就是外插的类型，OpenCV中给出以下几种方式<br>BORDER_REPLICATE 对边界像素进行复制<br>BORDER_REFLECT 对感兴趣的图像中的像素在两边分别进行复制，也就是左右各复制一次<br>BORDER_REFLECT_101 只复制一次，左右各占一半<br>BORDER_WRAP 外包装（？）<br>BORDER_CONSTANT 常量，选择这种方式的时候，需要用到最后一个参数为扩充的边缘选择颜色</p><h2 id="二、warpAffine-旋转函数"><a href="#二、warpAffine-旋转函数" class="headerlink" title="二、warpAffine()旋转函数"></a>二、warpAffine()旋转函数</h2><p>函数原型：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void warpAffine(</span><br><span class="line">    InputArray src,</span><br><span class="line">    OutputArray dst,</span><br><span class="line">    InputArray M,</span><br><span class="line">    Size dsize,</span><br><span class="line">    int flags = INTER_LINEAR,</span><br><span class="line">    int <span class="keyword">borderMode </span>= <span class="keyword">BORDER_CONSTANT,</span></span><br><span class="line"><span class="keyword"> </span>   const <span class="keyword">Scalar </span>&amp; <span class="keyword">borderValue </span>= <span class="keyword">Scalar() </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>src: 输入图像<br>dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致<br>M: 2X3的变换矩阵<br>dsize: 指定图像输出尺寸<br>flags: 插值算法标识符，有默认值INTER_LINEAR<br>borderMode: 边界像素模式，有默认值BORDER_CONSTANT<br>borderValue: 边界取值，有默认值Scalar()即0</p><h2 id="三、getRotationMatrix2D-旋转图像矩阵取得函数"><a href="#三、getRotationMatrix2D-旋转图像矩阵取得函数" class="headerlink" title="三、getRotationMatrix2D()旋转图像矩阵取得函数"></a>三、getRotationMatrix2D()旋转图像矩阵取得函数</h2><p>warpAffine()函数的InputArrey M的取得需要用到这个函数<br>函数原型：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat getRotationMatrix2D(</span><br><span class="line">    Point2f center, </span><br><span class="line">    <span class="keyword">double</span> angle, </span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">scale</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>center: Point2f类型，表示原图像的旋转中心<br>angle: double类型，表示图像旋转角度，角度为正则表示逆时针旋转，角度为负表示逆时针旋转（坐标原点是图像左上角）<br>scale: 缩放系数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来今天想一并吧图像的旋转和裁剪给一起完成了，但是图像在旋转之后的坐标定位一直有问题，所以今天只好放出在昨天的博客的基础上做的图像旋转的函数，旋转之后目标图像的最小外接矩形是和原始图像平行的，为的是设置ROI为裁剪图像做准备。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>最小外接矩形（不完美）</title>
    <link href="http://yoursite.com/2019/03/25/OpenCV-Learning-Day-15/"/>
    <id>http://yoursite.com/2019/03/25/OpenCV-Learning-Day-15/</id>
    <published>2019-03-25T13:56:14.000Z</published>
    <updated>2019-03-31T11:25:52.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节结合前面一章的批处理函数glob()，进行图像的最小外接矩形的描绘（实际效果不太完美）。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/DeepLearning/OpenCV/*.jpeg"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        minRect(images[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minRect</span><span class="params">(Mat&amp; srcImg)</span></span>&#123; </span><br><span class="line">    Mat dstImage = srcImg.clone();</span><br><span class="line">    cvtColor(srcImg, srcImg, COLOR_BGR2GRAY);</span><br><span class="line">    threshold(srcImg, srcImg, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; hierarcy;</span><br><span class="line">    findContours(srcImg, contours, hierarcy, RETR_EXTERNAL, CHAIN_APPROX_NONE);</span><br><span class="line">    <span class="built_in">vector</span>&lt;RotatedRect&gt; box(contours.size()); <span class="comment">//定义最小外接矩形集合</span></span><br><span class="line">    Point2f rect[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;contours.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        box[i] = minAreaRect(Mat(contours[i]));  <span class="comment">//计算每个轮廓最小外接矩形</span></span><br><span class="line">        box[i].points(rect);  <span class="comment">//把最小外接矩形四个端点复制给rect数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            line(dstImage, rect[j], rect[(j+<span class="number">1</span>)%<span class="number">4</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, LINE_AA);  <span class="comment">//绘制最小外接矩形每条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Image"</span>,dstImage);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br>（可以看到第二张图明显识别出了问题……）<br><img src="/2019/03/25/OpenCV-Learning-Day-15/1.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/2.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/3.jpg"><br><img src="/2019/03/25/OpenCV-Learning-Day-15/4.jpg"></p><h2 id="一、findContours-轮廓扫描函数"><a href="#一、findContours-轮廓扫描函数" class="headerlink" title="一、findContours()轮廓扫描函数"></a>一、findContours()轮廓扫描函数</h2><p>函数原型：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">findContours( </span><br><span class="line">    InputOutputArray image, </span><br><span class="line">    OutputArrayOfArrays contours,           </span><br><span class="line">    OutputArray hierarchy, </span><br><span class="line">    int mode,            </span><br><span class="line">    int <span class="function"><span class="keyword">method</span>, </span></span><br><span class="line"><span class="function">    <span class="title">Point</span> <span class="title">offset</span>=<span class="title">Point</span><span class="params">()</span></span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>第一个参数是输入图像，这里有很大一个坑，输入图像必须是八位单通道图像（即8UC1），在函数中被认为是一个二值化图像（即所有非零元素都被视作是相等的，非0即1），但如果mode是CV_RETR_CCOMP 或者 CV_RETR_FLOODFILL，输入图像也可以是32位的整型图像(CV_32SC1)。<br>第二个参数是二维vector数组，这里将使用找到的轮廓的列表进行填充（即，这将是一个contours的vector,其中contours[i]表示一个特定的轮廓，这样，contours[i][j]将表示contour[i]的一个特定的端点）。<br>第三个参数可以指定，也可以不提指定。如果指定的话，输出hierarchy，将会描述输出轮廓树的结构信息。（Vec4i是Vec&lt;int,4&gt;的别名，定义了一个“向量内每一个元素包含了4个int型变量”的向量）<br>第四个参数将会告诉OpenCV你想用何种方式来对轮廓进行提取<br>RETR_EXTERNAL：表示只提取最外面的轮廓；<br>RETR_LIST：表示提取所有轮廓并将其放入列表；<br>RETR_CCOMP:表示提取所有轮廓并将组织成一个两层结构，其中顶层轮廓是外部轮廓，第二层轮廓是“洞”的轮廓；<br>RETR_TREE：表示提取所有轮廓并组织成轮廓嵌套的完整层级结构。<br>第五个参数给出轮廓如何呈现的方法<br>CHAIN_APPROX_NONE：将轮廓中的所有点的编码转换成点；<br>CHAIN_APPROX_SIMPLE：压缩水平、垂直和对角直线段，仅保留它们的端点；</p><p>CHAIN_APPROX_TC89_L1 or CHAIN_APPROX_TC89_KCOS：应用Teh-Chin链近似算法中的一种风格</p><h2 id="二、minAreaRect-函数"><a href="#二、minAreaRect-函数" class="headerlink" title="二、minAreaRect()函数"></a>二、minAreaRect()函数</h2><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RotatedRect minAreaRect(<span class="name">InputArray</span> points)</span><br></pre></td></tr></table></figure><br>第一个参数可以输入点阵容器（vector）或者Mat类型的图像，这里很坑的是，如果参数是Mat类型必须满足depth == CV_32F || depth == CV_32S，且checkVector(2)才可以，否则会报错（minAreaRect()中主要调用的求凸包的函数convexHull()会检查Mat满不满足上面的条件）。<br>Mat::depth()函数：求矩阵中元素的一个通道的数据类型，这个值和type是相关的。<br>Mat::checkVector()函数：当Mat的channels,depth,和连续性  满足checkVector的参数内容时,返回(int)(total()*channels()/_elemChannels), 否则返回-1。checkVector(2)，要求矩阵的列数位2。<br>（我就是因为minAreaRect()中的Mat类总是报错才怒转findContours()函数的，然而测试代码的视线效果并不完美，有待改进）</p><h2 id="三、RotatedRect类"><a href="#三、RotatedRect类" class="headerlink" title="三、RotatedRect类"></a>三、RotatedRect类</h2><p>RotatedRect类常用于配合minAreaRect()函数的计算（因为minAreaRect()函数的返回类型就是RotatedRect类）<br>函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">RotatedRect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! various constructors</span></span><br><span class="line">    RotatedRect();</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> Point2f&amp; center, <span class="keyword">const</span> Size2f&amp; size, <span class="keyword">float</span> angle);</span><br><span class="line">    RotatedRect(<span class="keyword">const</span> CvBox2D&amp; box);</span><br><span class="line">    <span class="comment">//! returns 4 vertices of the rectangle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">points</span><span class="params">(Point2f pts[])</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! returns the minimal up-right rectangle containing the rotated rectangle</span></span><br><span class="line">    <span class="function">Rect <span class="title">boundingRect</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! conversion to the old-style CvBox2D structure</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">CvBox2D</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Point2f center; <span class="comment">//&lt; the rectangle mass center</span></span><br><span class="line">    Size2f size; <span class="comment">//&lt; width and height of the rectangle</span></span><br><span class="line">    <span class="keyword">float</span> angle; <span class="comment">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>RotatedRect类中定义了矩形的中心点center、尺寸size（包括width、height）、旋转角度angle共3个成员变量；<br>points()函数用于求矩形的4个顶点，boundingRect()函数求包含最小外接矩形的，与坐标轴平行（或垂直）的最小矩形。<br>参考博文：<br><blockquote><footer><strong>OpenCV 中boundingRect、minAreaRect的用法区别</strong><cite><a href="https://blog.csdn.net/u013925378/article/details/84563011" target="_blank" rel="noopener">blog.csdn.net/u013925378/article/details/84563011</a></cite></footer></blockquote><br><blockquote><footer><strong>Opencv轮廓检测findContours分析（层次结构）</strong><cite><a href="https://www.jianshu.com/p/4bc3349b4611" target="_blank" rel="noopener">www.jianshu.com/p/4bc3349b4611</a></cite></footer></blockquote><br><blockquote><footer><strong>【OpenCV3】图像轮廓查找与绘制——cv::findContours()与cv::drawContours()详解</strong><cite><a href="https://blog.csdn.net/guduruyu/article/details/69220296" target="_blank" rel="noopener">blog.csdn.net/guduruyu/article/details/69220296</a></cite></footer></blockquote><br><blockquote><footer><strong>Opencv RotatedRect类中的points、angle、width、height等详解</strong><cite><a href="https://blog.csdn.net/mailzst1/article/details/83141632" target="_blank" rel="noopener">blog.csdn.net/mailzst1/article/details/83141632</a></cite></footer></blockquote></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章节结合前面一章的批处理函数glob()，进行图像的最小外接矩形的描绘（实际效果不太完美）。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>批处理函数和二值化函数</title>
    <link href="http://yoursite.com/2019/03/24/OpenCV-Learning-Day-14/"/>
    <id>http://yoursite.com/2019/03/24/OpenCV-Learning-Day-14/</id>
    <published>2019-03-24T12:45:28.000Z</published>
    <updated>2019-03-31T11:25:57.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图像批处理，管进不管出。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"/Users/cezarbao/Desktop/TestImages/*.bmp"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;images;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt;srcImages;</span><br><span class="line">    glob(path,srcImages,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">size_t</span> cnt = srcImages.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        images.push_back(imread(srcImages[i]));</span><br><span class="line">        <span class="comment">//cvtColor(images[i],images[i],COLOR_BGR2GRAY);</span></span><br><span class="line">        <span class="comment">//blur(images[i],images[i],Size(5,5));</span></span><br><span class="line">        threshold(images[i],images[i],<span class="number">170</span>,<span class="number">255</span>,THRESH_BINARY);</span><br><span class="line">        imshow(<span class="string">"Image"</span>,images[i]);</span><br><span class="line">        waitKey(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一、glob-批处理函数"><a href="#一、glob-批处理函数" class="headerlink" title="一、glob()批处理函数"></a>一、glob()批处理函数</h2><p>glob()函数可以批处理指定文件夹中的图像，函数目的是将pattern路径下的所用文件名存进&amp;result中<br>函数原型：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glob(<span class="built_in">String</span> pattern, vector&lt;<span class="built_in">String</span>&gt; &amp;result, <span class="built_in">bool</span> recursive = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><br>第一个参数是文件夹的绝对路径<br>第二个参数是存放图片名称和路径的vector容器，需要注意的是该容器必须是OpenCV的String类<br>第三个参数默认是false，当recursive为false时，仅仅遍历指定文件夹内符合模式的文件，当recursive为true时，会同时遍历指定文件夹的子文件夹</p><h2 id="二、threshold-二值化函数"><a href="#二、threshold-二值化函数" class="headerlink" title="二、threshold()二值化函数"></a>二、threshold()二值化函数</h2><p>函数原型：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double threshold(</span><br><span class="line">    InputArray src, </span><br><span class="line">    OutputArray dst, </span><br><span class="line">    double thresh, </span><br><span class="line">    double maxval, </span><br><span class="line">    int type</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数和第二个参数分别为输入图像和输出图像<br>thresh参数表示阈值<br>maxval参数表示与THRESH_BINARY和THRESH_BINARY_INV阈值类型一起使用设置的最大值。<br>type参数表示阈值类型：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_BINARY</span> //如果 src(x,y)&gt;threshold ,dst(x,y) = max_value; 否则,dst（x,y）=0;</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_BINARY_INV</span> //如果 src(x,y)&gt;threshold,dst(x,y) = 0; 否则,dst(x,y) = max_value.</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TRUNC</span> //如果 src(x,y)&gt;threshold，dst(x,y) = max_value; 否则dst(x,y) = src(x,y).</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TOZERO</span> //如果src(x,y)&gt;threshold，dst(x,y) = src(x,y) ; 否则 dst(x,y) = 0。</span><br><span class="line"><span class="keyword">type</span>=<span class="type">CV_THRESH_TOZERO_INV</span> //如果 src(x,y)&gt;threshold，dst(x,y) = 0 ; 否则dst(x,y) = src(x,y)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图像批处理，管进不管出。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>离散傅里叶变换函数的补充</title>
    <link href="http://yoursite.com/2019/03/23/OpenCV-Learning-Day-13/"/>
    <id>http://yoursite.com/2019/03/23/OpenCV-Learning-Day-13/</id>
    <published>2019-03-23T13:30:58.000Z</published>
    <updated>2019-03-31T11:26:02.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的上一篇的博客的关于傅里叶变换的一些函数补充，理解不易，且行且珍惜～</p><a id="more"></a><p>测试代码在上一篇。<br>原图：<br><img src="/2019/03/23/OpenCV-Learning-Day-13/1.jpg"><br>测试图；<br><img src="/2019/03/23/OpenCV-Learning-Day-13/2.jpg"></p><h2 id="一、getOptimalDFTSize-函数"><a href="#一、getOptimalDFTSize-函数" class="headerlink" title="一、getOptimalDFTSize()函数"></a>一、getOptimalDFTSize()函数</h2><p>返回给定向量尺寸经过DFT变换后结果的最优尺寸大小。其函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOptimalDFTSize</span><span class="params">(<span class="keyword">int</span> vecsize)</span></span></span><br></pre></td></tr></table></figure><br>int vecsize: 输入向量尺寸大小(vector size)<br>DFT变换在一个向量尺寸上不是一个单调函数，当计算两个数组卷积或对一个数组进行光学分析，它常常会用0扩充一些数组来得到稍微大点的数组以达到比原来数组计算更快的目的。一个尺寸是2阶指数（2,4,8,16,32……）的数组计算速度最快，一个数组尺寸是2、3、5的倍数（例如：300 = 5*5*3*2*2）同样有很高的处理效率。<br>getOptimalDFTSize()函数返回大于或等于vecsize的最小数值N，这样尺寸为N的向量进行DFT变换能得到更高的处理效率。在当前N通过p，q，r等一些整数得出N = 2^p*3^q*5^r.<br>这个函数不能直接用于DCT（离散余弦变换）最优尺寸的估计，可以通过getOptimalDFTSize((vecsize+1)/2)*2得到。</p><h2 id="二、magnitude-函数"><a href="#二、magnitude-函数" class="headerlink" title="二、magnitude()函数"></a>二、magnitude()函数</h2><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void magnitude(<span class="name">InputArray</span> x, InputArray y, OutputArray magnitude)</span><br></pre></td></tr></table></figure><br>InputArray x: 浮点型数组的x坐标矢量，也就是实部<br>InputArray y: 浮点型数组的y坐标矢量，必须和x尺寸相同<br>OutputArray magnitude: 与x类型和尺寸相同的输出数组 </p><h2 id="三、copyMakeBorder"><a href="#三、copyMakeBorder" class="headerlink" title="三、copyMakeBorder()"></a>三、copyMakeBorder()</h2><p>扩充图像边界，其函数定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyMakeBorder</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray src, </span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray dst, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> top, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> bottom, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> left, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> right, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Scalar&amp; <span class="keyword">value</span>=Scalar(</span>)</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><br>InputArray src: 输入图像<br>OutputArray dst: 输出图像，与src图像有相同的类型，其尺寸应为Size(src.cols+left+right, src.rows+top+bottom)<br>int类型的top、bottom、left、right: 在图像的四个方向上扩充像素的值<br>int borderType: 边界类型，由borderInterpolate()来定义，常见的取值为BORDER_CONSTANT<br>const Scalar&amp; value = Scalar(): 如果边界类型为BORDER_CONSTANT则表示为边界值</p><h2 id="四、normalize-函数"><a href="#四、normalize-函数" class="headerlink" title="四、normalize() 函数"></a>四、normalize() 函数</h2><p>归一化就是把要处理的数据经过某种算法的处理限制在所需要的范围内。首先归一化是为了后面数据处理的方便，其次归一化能够保证程序运行时收敛加快。归一化的具体作用是归纳同意样本的统计分布性，归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布，在机器学习算法的数据预处理阶段，归一化也是非常重要的步骤。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void normalize(</span><br><span class="line">    InputArray src, </span><br><span class="line">    OutputArray dst, </span><br><span class="line">    double <span class="attribute">alpha</span>=1, </span><br><span class="line">    double <span class="attribute">beta</span>=0, </span><br><span class="line">    int <span class="attribute">norm_type</span>=NORM_L2, </span><br><span class="line">    int <span class="attribute">dtype</span>=-1, </span><br><span class="line">    InputArray <span class="attribute">mask</span>=noArray()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>InputArray src: 输入图像<br>OutputArray dst: 输出图像，尺寸大小和src相同<br>double alpha = 1: range normalization模式的最小值<br>double beta = 0: range normalization模式的最大值，不用于norm normalization(范数归一化)模式<br>int norm_type = NORM_L2: 归一化的类型，主要有  NORM_INF: 归一化数组的C-范数（绝对值的最大值）<br>NORM_L1: 归一化数组的L1-范数（绝对值的和）<br>NORM_L2: 归一化数组的L2-范数（欧几里得）<br>NORM_MINMAX: 数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。<br>int dtype = -1: 当该参数为负数时，输出数组的类型与输入数组的类型相同，否则输出数组与输入数组只是通道数相同，而depth = CV_MAT_DEPTH(dtype)<br>InputArray mask = noArray(): 操作掩膜版，用于指示函数是否仅仅对指定的元素进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我的上一篇的博客的关于傅里叶变换的一些函数补充，理解不易，且行且珍惜～&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>离散傅里叶变换</title>
    <link href="http://yoursite.com/2019/03/22/OpenCV-Learning-Day-12/"/>
    <id>http://yoursite.com/2019/03/22/OpenCV-Learning-Day-12/</id>
    <published>2019-03-22T12:26:13.000Z</published>
    <updated>2019-03-31T11:26:07.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节学习离散傅里叶变换，好难啊～分两天学习</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcIamge = imread(<span class="string">"3.jpg"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!srcIamge.data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcIamge);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = getOptimalDFTSize(srcIamge.rows);</span><br><span class="line">    <span class="keyword">int</span> n = getOptimalDFTSize(srcIamge.cols);</span><br><span class="line"></span><br><span class="line">    Mat padded;</span><br><span class="line">    copyMakeBorder(srcIamge,padded,<span class="number">0</span>,m - srcIamge.rows,<span class="number">0</span>,n - srcIamge.cols,BORDER_CONSTANT,Scalar::all(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Mat planes[] = &#123;Mat_&lt;<span class="keyword">float</span>&gt;(padded),Mat::zeros(padded.size(),CV_32F)&#125;;</span><br><span class="line">    Mat complexI;</span><br><span class="line">    merge(planes,<span class="number">2</span>,complexI);</span><br><span class="line"></span><br><span class="line">    dft(complexI,complexI);</span><br><span class="line"></span><br><span class="line">    split(complexI,planes);</span><br><span class="line">    magnitude(planes[<span class="number">0</span>],planes[<span class="number">1</span>],planes[<span class="number">0</span>]);</span><br><span class="line">    Mat magnitudeImage = planes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    magnitudeImage = magnitudeImage(Rect(<span class="number">0</span>,<span class="number">0</span>,magnitudeImage.cols &amp; <span class="number">-2</span>,magnitudeImage.rows &amp; <span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">int</span> cx = magnitudeImage.cols / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cy = magnitudeImage.rows / <span class="number">2</span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q0</span><span class="params">(magnitudeImage, Rect(<span class="number">0</span>,<span class="number">0</span>,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q1</span><span class="params">(magnitudeImage, Rect(cx,<span class="number">0</span>,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q2</span><span class="params">(magnitudeImage, Rect(<span class="number">0</span>,cy,cx,cy))</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">q3</span><span class="params">(magnitudeImage, Rect(cx,cy,cx,cy))</span></span>;</span><br><span class="line"></span><br><span class="line">    Mat tmp;</span><br><span class="line">    q0.copyTo(tmp);</span><br><span class="line">    q3.copyTo(q0);</span><br><span class="line">    tmp.copyTo(q3);</span><br><span class="line">    q1.copyTo(tmp);</span><br><span class="line">    q2.copyTo(q1);</span><br><span class="line">    tmp.copyTo(q2);</span><br><span class="line"></span><br><span class="line">    normalize(magnitudeImage,magnitudeImage,<span class="number">0</span>,<span class="number">1</span>,NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,magnitudeImage);</span><br><span class="line">    waitKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一：dft-函数"><a href="#一：dft-函数" class="headerlink" title="一：dft()函数"></a>一：dft()函数</h2><p>参数解释：<br>第一个参数为输入图像，可以是实数或虚数<br>第二个参数为输出图像，其大小和类型取决于第三个参数flags<br>第三个参数为转换的标识符，有默认值0.其可取的值如下所示：<br>DFT_INVERSE: 用一维或二维逆变换取代默认的正向变换<br>DFT_SCALE: 缩放比例标识符，根据数据元素个数平均求出其缩放结果，如有N个元素，则输出结果以1/N缩放输出，常与DFT_INVERSE搭配使用。<br>DFT_ROWS: 对输入矩阵的每行进行正向或反向的傅里叶变换；此标识符可在处理多种适量的的时候用于减小资源的开销，这些处理常常是三维或高维变换等复杂操作。<br>DFT_COMPLEX_OUTPUT: 对一维或二维的实数数组进行正向变换，这样的结果虽然是复数阵列，但拥有复数的共轭对称性（CCS），可以以一个和原数组尺寸大小相同的实数数组进行填充，这是最快的选择也是函数默认的方法。你可能想要得到一个全尺寸的复数数组（像简单光谱分析等等），通过设置标志位可以使函数生成一个全尺寸的复数输出数组。<br>DFT_REAL_OUTPUT: 对一维二维复数数组进行逆向变换，这样的结果通常是一个尺寸相同的复数矩阵，但是如果输入矩阵有复数的共轭对称性（比如是一个带有DFT_COMPLEX_OUTPUT标识符的正变换结果），便会输出实数矩阵。<br>int nonzeroRows = 0: 当这个参数不为0，函数会假设只有输入数组（没有设置DFT_INVERSE）的第一行或第一个输出数组（设置了DFT_INVERSE）包含非零值。这样的话函数就可以对其他的行进行更高效的处理节省一些时间，这项技术尤其是在采用DFT计算矩阵卷积时非常有效。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本节学习离散傅里叶变换，好难啊～分两天学习&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>亮度和对比度调节</title>
    <link href="http://yoursite.com/2019/03/21/OpenCV-Learning-Day-11/"/>
    <id>http://yoursite.com/2019/03/21/OpenCV-Learning-Day-11/</id>
    <published>2019-03-21T07:01:34.000Z</published>
    <updated>2019-03-31T11:26:12.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_ContrastAndBright</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHelpText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nContrastValue;</span><br><span class="line"><span class="keyword">int</span> g_nBrightValue;</span><br><span class="line">Mat g_srcImage, g_dstImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g_srcImage = imread(<span class="string">"1.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage.data)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_dstImage = Mat::zeros(g_srcImage.size(), g_srcImage.type());</span><br><span class="line"></span><br><span class="line">    g_nContrastValue = <span class="number">80</span>;</span><br><span class="line">    g_nBrightValue = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Output"</span>,WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    createTrackbar(<span class="string">"Contrast:"</span>,<span class="string">"Output"</span>,&amp;g_nContrastValue,<span class="number">300</span>,on_ContrastAndBright);</span><br><span class="line">    createTrackbar(<span class="string">"Bright:"</span>,<span class="string">"Output"</span>,&amp;g_nBrightValue,<span class="number">200</span>,on_ContrastAndBright);</span><br><span class="line"></span><br><span class="line">    on_ContrastAndBright(g_nContrastValue,<span class="number">0</span>);</span><br><span class="line">    on_ContrastAndBright(g_nBrightValue,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">char</span>(waitKey(<span class="number">1</span>)) != <span class="string">'q'</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_ContrastAndBright</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    namedWindow(<span class="string">"Input"</span>,WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; g_srcImage.rows; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; g_srcImage.cols; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)&#123;</span><br><span class="line">                g_dstImage.at&lt;Vec3b&gt;(y,x)[c] = saturate_cast&lt;uchar&gt;</span><br><span class="line">                ((g_nContrastValue*<span class="number">0.01</span>) * (g_srcImage.at&lt;Vec3b&gt;(y,x)[c]) + g_nBrightValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Input"</span>,g_srcImage);</span><br><span class="line">    imshow(<span class="string">"Output"</span>,g_dstImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原图：<br><img src="/2019/03/21/OpenCV-Learning-Day-11/1.jpg"><br>测试图；<br><img src="/2019/03/21/OpenCV-Learning-Day-11/2.jpg"><br>感觉图片上的时间硬是调早了两个小时……</p><h2 id="1-Mat-zeros-和Mat-ones"><a href="#1-Mat-zeros-和Mat-ones" class="headerlink" title="1.Mat::zeros()和Mat::ones()"></a>1.Mat::zeros()和Mat::ones()</h2><p>Mat::zeros()相当于创建了一张全黑的图，图像矩阵上每个像素点的每个通道全设置为0。<br>Mat::ones()则是将图像矩阵上每个像素点的第一个通道设置为1，其余通道设置为0。</p><h2 id="2-saturate-cast防止数据溢出"><a href="#2-saturate-cast防止数据溢出" class="headerlink" title="2.saturate_cast防止数据溢出"></a>2.saturate_cast防止数据溢出</h2><p>原理如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">data</span>&lt;<span class="number">0</span>) <span class="keyword">data</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">data</span>&gt;<span class="number">255</span>) <span class="keyword">data</span>=<span class="number">255</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-Mat类中的at函数"><a href="#3-Mat类中的at函数" class="headerlink" title="3.Mat类中的at函数"></a>3.Mat类中的at函数</h2><p>在测试代码中，函数实现亮度和对比度的调节是通过Mat类中的at函数遍历各个像素点并修改来实现的，但这不是最有效率的做法，在测试图像素为4000✖1900左右，在调节亮度和对比度时就会变得非常卡了。还有一种指针的做法和一种迭代器的做法，可以参考我之前的博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要介&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>图像通道的分离与合并</title>
    <link href="http://yoursite.com/2019/03/20/OpenCV-Learning-Day-10/"/>
    <id>http://yoursite.com/2019/03/20/OpenCV-Learning-Day-10/</id>
    <published>2019-03-20T07:13:13.000Z</published>
    <updated>2019-03-26T02:22:00.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不要问，就是水，前言说没就会没。</p><a id="more"></a><h2 id="一、通道的分离（split-函数）和合并（merge-函数）"><a href="#一、通道的分离（split-函数）和合并（merge-函数）" class="headerlink" title="一、通道的分离（split()函数）和合并（merge()函数）"></a>一、通道的分离（split()函数）和合并（merge()函数）</h2><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"2.jpg"</span>);</span><br><span class="line">    Mat ImageBlue, ImageGreen, ImageRed;</span><br><span class="line">    Mat mergeImage;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt;channels;</span><br><span class="line">    split(srcImage,channels);</span><br><span class="line"></span><br><span class="line">    ImageBlue = channels.at(<span class="number">0</span>);</span><br><span class="line">    imshow(<span class="string">"Blue Channel"</span>,ImageBlue);</span><br><span class="line"></span><br><span class="line">    ImageGreen = channels.at(<span class="number">1</span>);</span><br><span class="line">    imshow(<span class="string">"Green Channel"</span>,ImageGreen);</span><br><span class="line"></span><br><span class="line">    ImageRed = channels.at(<span class="number">2</span>);</span><br><span class="line">    imshow(<span class="string">"Red Channel"</span>,ImageRed);</span><br><span class="line"></span><br><span class="line">    merge(channels,mergeImage);</span><br><span class="line">    imshow(<span class="string">"mergeImage"</span>,mergeImage);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br>蓝色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/1.jpg"><br>绿色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/2.jpg"><br>红色通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/3.jpg"><br>合并通道：<br><img src="/2019/03/20/OpenCV-Learning-Day-10/4.jpg"></p><h3 id="1-split-函数：图像通道的分离"><a href="#1-split-函数：图像通道的分离" class="headerlink" title="1.split()函数：图像通道的分离"></a>1.split()函数：图像通道的分离</h3><p>函数原型：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void split(<span class="name">InputArray</span> m, OutputArrayOfArrays mv)</span><br></pre></td></tr></table></figure><br>第一个参数为输入图像<br>第二个参数是函数的输出数组或者vector容器</p><h3 id="2-merge-函数：图像通道的合并"><a href="#2-merge-函数：图像通道的合并" class="headerlink" title="2.merge()函数：图像通道的合并"></a>2.merge()函数：图像通道的合并</h3><p>函数原型：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">merge</span>(InputArrayOfArrays <span class="keyword">mv</span>, OutputArray dst)</span><br></pre></td></tr></table></figure><br>可以看出merge的两个参数和split函数正好相反：<br>第一个参数是保存函数通道的数组或者vector容器<br>第二个参数为输出图像</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不要问，就是水，前言说没就会没。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>通过访问图像像素减少图像颜色数量</title>
    <link href="http://yoursite.com/2019/03/19/OpenCV-Learning-Day-9/"/>
    <id>http://yoursite.com/2019/03/19/OpenCV-Learning-Day-9/</id>
    <published>2019-03-19T10:54:55.000Z</published>
    <updated>2019-03-31T11:26:23.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于你可以自己看下面的内容，所以没有前言。</p><a id="more"></a><p>该测试代码实现的功能是减少图像种颜色的数量，将256×256×256转换成26×26×26从而提高程序运行速度。实现该功能需要用到访问图像像素的函数和计时的函数。<br>效果图：<br><img src="/2019/03/19/OpenCV-Learning-Day-9/1.jpg"><br><img src="/2019/03/19/OpenCV-Learning-Day-9/2.jpg"><br>测试代码：</p><h2 id="一、main函数："><a href="#一、main函数：" class="headerlink" title="一、main函数："></a>一、main函数：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorReduce</span><span class="params">(Mat&amp; inputImage,Mat&amp; outputImage,<span class="keyword">int</span> div)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage = imread(<span class="string">"1.jpg"</span>);</span><br><span class="line">    imshow(<span class="string">"srcImage"</span>,srcImage);</span><br><span class="line"></span><br><span class="line">    Mat dstImage;</span><br><span class="line">    dstImage.create(srcImage.rows,srcImage.cols,srcImage.type());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> time0 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line"></span><br><span class="line">    colorReduce(srcImage,dstImage,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    time0 = ((<span class="keyword">double</span>)getTickCount() - time0) / getTickFrequency();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time: "</span> &lt;&lt; time0 &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dstImage"</span>,dstImage);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-计时函数"><a href="#1-计时函数" class="headerlink" title="1.计时函数"></a>1.计时函数</h3><p>getTickCount()函数返回CPU自某个事件以来走过的时钟周期数<br>getTickFrequency()函数返回CPU一秒钟走过的时钟周期数<br>两者组合如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> time0 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line">time0 = ((<span class="keyword">double</span>)getTickCount() - time0) / getTickFrequency();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time: "</span> &lt;&lt; time0 &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><br>即可实现对colorReduce()函数的计时。</p><h3 id="2-static-cast函数"><a href="#2-static-cast函数" class="headerlink" title="2.static_cast函数"></a>2.static_cast函数</h3><p>强制类型转换，即在程序员知情的情况下进行转换，系统不会报错。</p><h2 id="二、实现colorReduce-函数的三种方法"><a href="#二、实现colorReduce-函数的三种方法" class="headerlink" title="二、实现colorReduce()函数的三种方法"></a>二、实现colorReduce()函数的三种方法</h2><h3 id="1-指针访问"><a href="#1-指针访问" class="headerlink" title="1.指针访问"></a>1.指针访问</h3><p>函数代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> colorReduce(<span class="type">Mat</span>&amp; inputImage,<span class="type">Mat</span>&amp; outputImage,<span class="built_in">int</span> <span class="keyword">div</span>)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    <span class="built_in">int</span> rowNumber = outputImage.rows;</span><br><span class="line">    <span class="built_in">int</span> colNumber = outputImage.cols * outputImage.channels();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; rowNumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar* data = outputImage.<span class="keyword">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; colNumber; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mat类中的ptr函数<br>可以返回第i行的首地址，如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">uchar</span>* <span class="class"><span class="keyword">data</span> = outputImage.ptr&lt;uchar&gt;(<span class="title">i</span>);</span></span><br></pre></td></tr></table></figure></p><h3 id="2-迭代器iterator"><a href="#2-迭代器iterator" class="headerlink" title="2.迭代器iterator"></a>2.迭代器iterator</h3><p>函数代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> colorReduce(<span class="type">Mat</span>&amp; inputImage,<span class="type">Mat</span>&amp; outputImage,<span class="built_in">int</span> <span class="keyword">div</span>)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    <span class="type">Mat_</span>&lt;<span class="type">Vec3b</span>&gt;::<span class="keyword">iterator</span> it = outputImage.begin&lt;<span class="type">Vec3b</span>&gt;();</span><br><span class="line">    <span class="type">Mat_</span>&lt;<span class="type">Vec3b</span>&gt;::<span class="keyword">iterator</span> itend = outputImage.<span class="keyword">end</span>&lt;<span class="type">Vec3b</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;it != itend; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        (*it)[<span class="number">0</span>] = (*it)[<span class="number">0</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        (*it)[<span class="number">1</span>] = (*it)[<span class="number">1</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">        (*it)[<span class="number">2</span>] = (*it)[<span class="number">2</span>] / <span class="keyword">div</span> * <span class="keyword">div</span> + <span class="keyword">div</span> / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL 迭代器嘻嘻嘻…自己找</p><h3 id="3-动态地址计算"><a href="#3-动态地址计算" class="headerlink" title="3.动态地址计算"></a>3.动态地址计算</h3><p>函数代码：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void colorReduce(Mat&amp; inputImage,Mat&amp; outputImage,int div)&#123;</span><br><span class="line">    outputImage = inputImage.clone();</span><br><span class="line">    int rowNumber = outputImage.rows;</span><br><span class="line">    int colNumber = outputImage.cols;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; rowNumber; <span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; colNumber; <span class="built_in">j</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">0</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">0</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">1</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">1</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">            outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">2</span>] = outputImage.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[<span class="number">2</span>] / div * div + div / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mat类中的at函数可以读取和修改图像矩阵中对应坐标的元素，但是必须在编译时知道图像的数据类型，at函数本身不会进行任何数据类型的转换，因此需要确保我们指定的数据类型要和图像矩阵中的数据类型相同。<br>一般形式：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.at&lt;Vec3b&gt;(<span class="built_in">i</span>,<span class="built_in">j</span>)[channel] = value;</span><br></pre></td></tr></table></figure><br>在本程序给出的图像是三通道的，因此是Vec3b，表示三个八位数的向量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于你可以自己看下面的内容，所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>简单图形绘制</title>
    <link href="http://yoursite.com/2019/03/18/OpenCV-Learning-Day-8/"/>
    <id>http://yoursite.com/2019/03/18/OpenCV-Learning-Day-8/</id>
    <published>2019-03-18T11:37:25.000Z</published>
    <updated>2019-03-31T11:26:28.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看毛星云大大的教程的测试代码就把我看晕了……所以没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_WIDTH 600</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME1 <span class="meta-string">"Picture1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME2 <span class="meta-string">"Picture2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFilledCircle</span><span class="params">(Mat img,Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Mat img,Point start,Point end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPolygon</span><span class="params">(Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat atomImage = Mat::zeros(WINDOW_WIDTH,WINDOW_WIDTH,CV_8UC3);</span><br><span class="line">    Mat rookImage = Mat::zeros(WINDOW_WIDTH,WINDOW_WIDTH,CV_8UC3);</span><br><span class="line"></span><br><span class="line">    DrawEllipse(atomImage,<span class="number">90</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">0</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">45</span>);</span><br><span class="line">    DrawEllipse(atomImage,<span class="number">-45</span>);</span><br><span class="line"></span><br><span class="line">    DrawFilledCircle(atomImage,Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH/<span class="number">2</span>));</span><br><span class="line">    DrawPolygon(rookImage);</span><br><span class="line"></span><br><span class="line">    rectangle(rookImage,</span><br><span class="line">    Point(<span class="number">0</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),</span><br><span class="line">    Point(WINDOW_WIDTH,WINDOW_WIDTH),</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    <span class="number">8</span>);</span><br><span class="line">    <span class="number">9</span>)</span><br><span class="line">    DrawLine(rookImage,Point(<span class="number">0</span>,<span class="number">15</span>*WINDOW_WIDTH/<span class="number">16</span>),Point(WINDOW_WIDTH,<span class="number">15</span>*WINDOW_WIDTH/<span class="number">16</span>));</span><br><span class="line">    DrawLine(rookImage,Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH));</span><br><span class="line">    DrawLine(rookImage,Point(WINDOW_WIDTH/<span class="number">2</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH));</span><br><span class="line">    DrawLine(rookImage,Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>),Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">    imshow(WINDOW_NAME1,atomImage);</span><br><span class="line">    moveWindow(WINDOW_NAME1,<span class="number">0</span>,<span class="number">200</span>);</span><br><span class="line">    imshow(WINDOW_NAME2,rookImage);</span><br><span class="line">    moveWindow(WINDOW_NAME2,WINDOW_WIDTH,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Mat img, <span class="keyword">double</span> angle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ellipse(img,</span><br><span class="line">    Point(WINDOW_WIDTH/<span class="number">2</span>,WINDOW_WIDTH/<span class="number">2</span>),</span><br><span class="line">    Size(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">16</span>),</span><br><span class="line">    angle,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">360</span>,</span><br><span class="line">    Scalar(<span class="number">255</span>,<span class="number">129</span>,<span class="number">0</span>),</span><br><span class="line">    thickness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFilledCircle</span><span class="params">(Mat img,Point center)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line">    circle(img,</span><br><span class="line">    center,</span><br><span class="line">    WINDOW_WIDTH/<span class="number">32</span>,</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),</span><br><span class="line">    thickness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPolygon</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Point rookPoints[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">0</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">1</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">7</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">2</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">3</span>] = Point(<span class="number">11</span>*WINDOW_WIDTH/<span class="number">16</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">4</span>] = Point(<span class="number">19</span>*WINDOW_WIDTH/<span class="number">32</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">5</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">6</span>] = Point(<span class="number">3</span>*WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">7</span>] = Point(<span class="number">26</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">8</span>] = Point(<span class="number">26</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">9</span>] = Point(<span class="number">22</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">10</span>] = Point(<span class="number">22</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">11</span>] = Point(<span class="number">18</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">12</span>] = Point(<span class="number">18</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">13</span>] = Point(<span class="number">14</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">4</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">14</span>] = Point(<span class="number">14</span>*WINDOW_WIDTH/<span class="number">40</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">15</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">16</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">17</span>] = Point(<span class="number">13</span>*WINDOW_WIDTH/<span class="number">32</span>,<span class="number">3</span>*WINDOW_WIDTH/<span class="number">8</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">18</span>] = Point(<span class="number">5</span>*WINDOW_WIDTH/<span class="number">16</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line">    rookPoints[<span class="number">0</span>][<span class="number">19</span>] = Point(WINDOW_WIDTH/<span class="number">4</span>,<span class="number">13</span>*WINDOW_WIDTH/<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point* ppt[<span class="number">1</span>] = &#123;rookPoints[<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">    fillPoly(img,</span><br><span class="line">    ppt,</span><br><span class="line">    npt,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Mat img,Point start,Point end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thinkness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> linetype = <span class="number">8</span>;</span><br><span class="line">    line(img,</span><br><span class="line">    start,</span><br><span class="line">    end,</span><br><span class="line">    Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">    thinkness,</span><br><span class="line">    linetype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br><img src="/2019/03/18/OpenCV-Learning-Day-8/1.png"><br><img src="/2019/03/18/OpenCV-Learning-Day-8/2.png"></p><h2 id="一、void-DrawEllipse-Mat-img-double-angle"><a href="#一、void-DrawEllipse-Mat-img-double-angle" class="headerlink" title="一、void DrawEllipse(Mat img, double angle)"></a>一、void DrawEllipse(Mat img, double angle)</h2><p>该函数调用了OpenCV中的ellipse函数用以绘制椭圆。<br>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">ellipse</span>(</span><br><span class="line">    Mat&amp; img, </span><br><span class="line">    Point center, </span><br><span class="line">    Size axes, </span><br><span class="line">    <span class="keyword">double</span> angle, </span><br><span class="line">    <span class="keyword">double</span> startAngle, </span><br><span class="line">    <span class="keyword">double</span> endAngle, </span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness=<span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType=<span class="number">8</span>, </span><br><span class="line">    <span class="built_in">int</span> shift=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">ellipse</span>(</span><br><span class="line">    Mat&amp; img, </span><br><span class="line">    <span class="keyword">const</span> RotatedRect&amp; <span class="built_in">box</span>, </span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness=<span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType=<span class="number">8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="二、void-DrawFilledCircle-Mat-img-Point-center"><a href="#二、void-DrawFilledCircle-Mat-img-Point-center" class="headerlink" title="二、void DrawFilledCircle(Mat img,Point center)"></a>二、void DrawFilledCircle(Mat img,Point center)</h2><p>该函数调用circle函数用以绘制圆形。<br>函数原型：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">circle</span>(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point center, </span><br><span class="line">    <span class="keyword">int</span> radius, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;color, </span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">1</span>, </span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>在测试程序中，由于线粗设置为-1，因此圆形是实心的。</p><h2 id="三、void-DrawPolygon-Mat-img"><a href="#三、void-DrawPolygon-Mat-img" class="headerlink" title="三、void DrawPolygon(Mat img)"></a>三、void DrawPolygon(Mat img)</h2><p>该函数调用了fillPoly函数用以绘制自定义的多边形。<br>函数原型：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> fillPoly(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    <span class="keyword">const</span> Point **pts, </span><br><span class="line">    <span class="keyword">const</span> <span class="type">int</span> *npts, </span><br><span class="line">    <span class="type">int</span> ncontours, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;color, </span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="type">int</span> shift = <span class="number">0</span>, </span><br><span class="line">    Point <span class="keyword">offset</span> = Point()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>在测试程序中，该函数的多边形的顶点集为ppt，需绘制的多边形顶点数目为npt，绘制图形数量为1。</p><h2 id="四、void-DrawLine-Mat-img-Point-start-Point-end"><a href="#四、void-DrawLine-Mat-img-Point-start-Point-end" class="headerlink" title="四、void DrawLine(Mat img,Point start,Point end)"></a>四、void DrawLine(Mat img,Point start,Point end)</h2><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">line</span>(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point pt1, </span><br><span class="line">    Point pt2, </span><br><span class="line">    <span class="keyword">const</span> Scalar &amp;<span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness = <span class="number">1</span>, </span><br><span class="line">    <span class="built_in">int</span> lineType = <span class="number">8</span>, </span><br><span class="line">    <span class="built_in">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>无甚可讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看毛星云大大的教程的测试代码就把我看晕了……所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>鼠标操作初级</title>
    <link href="http://yoursite.com/2019/03/17/OpenCV-Learning-Day-7/"/>
    <id>http://yoursite.com/2019/03/17/OpenCV-Learning-Day-7/</id>
    <published>2019-03-17T00:37:57.000Z</published>
    <updated>2019-03-31T11:26:32.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为今天天气不错，所以没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINDOW_NAME <span class="meta-string">"SetMouseCallback Sample"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> on_MouseHandle(<span class="keyword">int</span> event,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flags,<span class="keyword">void</span>* param);</span><br><span class="line"><span class="keyword">void</span> DrawRectangle(Mat&amp; img,Rect box);</span><br><span class="line"><span class="keyword">void</span> ShowHelpText();</span><br><span class="line"></span><br><span class="line">Rect g_rectangle;</span><br><span class="line"><span class="keyword">bool</span> g_bDrawingBox = false;</span><br><span class="line">RNG g_rng(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)&#123;</span><br><span class="line">    g_rectangle = Rect(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    Mat srcImage(<span class="number">600</span>,<span class="number">800</span>,CV_8UC3),tempImage;</span><br><span class="line">    srcImage.copyTo(tempImage);</span><br><span class="line">    srcImage = Scalar::all(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    namedWindow(WINDOW_NAME);</span><br><span class="line">    setMouseCallback(WINDOW_NAME,on_MouseHandle,(<span class="keyword">void</span>*)&amp;srcImage);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        srcImage.copyTo(tempImage);</span><br><span class="line">        <span class="built_in">if</span>(g_bDrawingBox) DrawRectangle(tempImage, g_rectangle);</span><br><span class="line">        imshow(WINDOW_NAME,tempImage);</span><br><span class="line">        <span class="built_in">if</span>(waitKey(<span class="number">10</span>) == <span class="number">27</span>) <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> on_MouseHandle(<span class="keyword">int</span> event,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flags,<span class="keyword">void</span>* param)&#123;</span><br><span class="line">    Mat&amp; <span class="built_in">image</span> = *(Mat*) param;</span><br><span class="line">    <span class="built_in">switch</span> (event)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//鼠标移动消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_MOUSEMOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">if</span> (g_bDrawingBox) &#123;</span><br><span class="line">            g_rectangle.<span class="built_in">width</span> = x - g_rectangle.x;</span><br><span class="line">            g_rectangle.<span class="built_in">height</span> = y - g_rectangle.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左键按下消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            g_bDrawingBox = true;</span><br><span class="line">            g_rectangle = Rect(x,y,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左键抬起消息</span></span><br><span class="line">        <span class="built_in">case</span> EVENT_LBUTTONUP:</span><br><span class="line">        &#123;</span><br><span class="line">            g_bDrawingBox = false;</span><br><span class="line">            <span class="comment">//对宽和高小于0的处理</span></span><br><span class="line">            <span class="built_in">if</span> (g_rectangle.<span class="built_in">width</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                g_rectangle.x += g_rectangle.<span class="built_in">width</span>;</span><br><span class="line">                g_rectangle.<span class="built_in">width</span> *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            DrawRectangle(<span class="built_in">image</span>,g_rectangle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DrawRectangle(Mat&amp; img,Rect box)&#123;</span><br><span class="line">    rectangle(img,box.tl(),box.br(),Scalar(g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>),g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>),g_rng.uniform(<span class="number">0</span>,<span class="number">255</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图：<br><img src="/2019/03/17/OpenCV-Learning-Day-7/1.png"><br>setMouseCallback()函数<br>函数原型：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setMouseCallback(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">String</span> &amp;winname, </span><br><span class="line">    MouseCallback onMouse, </span><br><span class="line">    <span class="keyword">void</span> *userdata = (<span class="keyword">void</span> *)<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数为窗口名称<br>第二个参数为MouseCallback类型的onMouse，窗口里每次鼠标操作的发生都会调用这个函数，这个函数的原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_MouseHandle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> <span class="keyword">event</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> x, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> y, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *param</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><br>event是许多EVENT_变量，这个在测试程序中有所体现；x和y是在图像坐标系（？）的坐标值，flags是EVENT_FLAG的组合，param是用户定义的传递到setMouseCallback()函数调用的参数。<br>第三个参数是用户定义的传递到回调函数的参数，有默认值0</p><h2 id="一、Scalar-函数："><a href="#一、Scalar-函数：" class="headerlink" title="一、Scalar()函数："></a>一、Scalar()函数：</h2><p>函数定义：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct <span class="keyword">Scalar</span></span><br><span class="line">&#123;</span><br><span class="line">    double <span class="comment">val[4]</span>;</span><br><span class="line">&#125;<span class="keyword">Scalar</span>;</span><br></pre></td></tr></table></figure><br>由函数定义可知Scalar()可以存储4个double类型的值，分别对应4通道（需要注意的是，在OpenCV中，前三个颜色通道分别是BGR而不是常识中的RGB，第四个通道则是透明度Alpha值），在使用Scalar()函数的过程中，具体需要使用几个值需要看Mat类型图像的type，比如常见的CV_8UC3类型，C就代表通道（channel），看到C3就知道这个图像有三个通道，因此应该写三个值，每个值分别赋值给对应通道内的所有矩阵元素，如果出现参数比通道数少的情况，那么未赋值的通道内所有矩阵元素全部为0。<br>另科普Mat类型的type参数：<br>1.bit_depth：比特数，代表8bite,16bites,32bites,64bites例如创建一个存储灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位，所以它对应的就是CV_8<br>2.S|U|F<br>S代表signed int有符号整形<br>U代表unsigned int无符号整形<br>F代表float单精度浮点型<br>3.C（channel）代表一张图片的通道数<br>灰度图片grayImg是单通道图像<br>RGB彩色图像是3通道图像<br>带Alph通道的RGB图像是4通道图像</p><h2 id="二、Rect-函数"><a href="#二、Rect-函数" class="headerlink" title="二、Rect()函数"></a>二、Rect()函数</h2><p>函数定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">/* 方形的左上角的x-坐标 */</span> </span><br><span class="line">    <span class="keyword">int</span> y; <span class="comment">/* 方形的左上角的y-坐标*/</span> </span><br><span class="line">    <span class="keyword">int</span> width; <span class="comment">/* 宽 */</span> </span><br><span class="line">    <span class="keyword">int</span> height; <span class="comment">/* 高 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数用法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果创建一个Rect对象rect(100, 50, 50, 100)，那么rect会有以下几个功能： </span></span><br><span class="line"><span class="built_in">rect</span>.area(); <span class="comment">//返回rect的面积 5000 </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">size</span>(); <span class="comment">//返回rect的尺寸 [50 × 100] </span></span><br><span class="line"><span class="built_in">rect</span>.tl(); <span class="comment">//返回rect的左上顶点的坐标 [100, 50] </span></span><br><span class="line"><span class="built_in">rect</span>.br(); <span class="comment">//返回rect的右下顶点的坐标 [150, 150] </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">width</span>(); <span class="comment">//返回rect的宽度 50 </span></span><br><span class="line"><span class="built_in">rect</span>.<span class="built_in">height</span>(); <span class="comment">//返回rect的高度 100 </span></span><br><span class="line"><span class="built_in">rect</span>.contains(Point(x, y)); <span class="comment">//返回布尔变量，判断rect是否包含Point(x, y)点 </span></span><br><span class="line"><span class="comment">//还可以求两个矩形的交集和并集 </span></span><br><span class="line"><span class="built_in">rect</span> = rect1 &amp; rect2; </span><br><span class="line"><span class="built_in">rect</span> = rect1 | rect2; </span><br><span class="line"><span class="comment">//还可以对矩形进行平移和缩放 </span></span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + Point(<span class="number">-100</span>, <span class="number">100</span>); <span class="comment">//平移，也就是左上顶点的x坐标-100，y坐标+100 </span></span><br><span class="line"><span class="built_in">rect</span> = <span class="built_in">rect</span> + Size(<span class="number">-100</span>, <span class="number">100</span>); <span class="comment">//缩放，左上顶点不变，宽度-100，高度+100 </span></span><br><span class="line"><span class="comment">//还可以对矩形进行对比，返回布尔变量 </span></span><br><span class="line">rect1 == rect2; </span><br><span class="line">rect1 != rect2; </span><br><span class="line"><span class="comment">//判断rect1是否在rect2里面</span></span><br><span class="line"><span class="keyword">bool</span> isInside(Rect rect1, Rect rect2) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">return</span> (rect1 == (rect1&amp;rect2)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//矩形中心点</span></span><br><span class="line">Point getCenterPoint(Rect <span class="built_in">rect</span>) </span><br><span class="line">&#123; </span><br><span class="line">    Point cpt; </span><br><span class="line">    cpt.x = <span class="built_in">rect</span>.x + cvRound(<span class="built_in">rect</span>.<span class="built_in">width</span>/<span class="number">2.0</span>); </span><br><span class="line">    cpt.y = <span class="built_in">rect</span>.y + cvRound(<span class="built_in">rect</span>.<span class="built_in">height</span>/<span class="number">2.0</span>); </span><br><span class="line">    <span class="built_in">return</span> cpt; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//围绕矩形中心缩放 </span></span><br><span class="line">Rect rectCenterScale(Rect <span class="built_in">rect</span>, Size <span class="built_in">size</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">rect</span> = <span class="built_in">rect</span> + <span class="built_in">size</span>; </span><br><span class="line">    Point pt; </span><br><span class="line">    pt.x = cvRound(<span class="built_in">size</span>.<span class="built_in">width</span>/<span class="number">2.0</span>); </span><br><span class="line">    pt.y = cvRound(<span class="built_in">size</span>.<span class="built_in">height</span>/<span class="number">2.0</span>); </span><br><span class="line">    <span class="built_in">return</span> (<span class="built_in">rect</span>-pt); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>Rect()函数用法摘自：<br><blockquote><footer><strong>【OpenCV】cv::Rect矩形类用法</strong><cite><a href="https://blog.csdn.net/qq_30214939/article/details/65648273" target="_blank" rel="noopener">blog.csdn.net/qq_30214939/article/details/65648273</a></cite></footer></blockquote></p><h2 id="三、Rectangle-函数"><a href="#三、Rectangle-函数" class="headerlink" title="三、Rectangle()函数"></a>三、Rectangle()函数</h2><p>函数原型：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rectangle(</span><br><span class="line">    InputOutputArray img, </span><br><span class="line">    Point pt1, </span><br><span class="line">    Point pt2,</span><br><span class="line">    <span class="keyword">const</span> Scalar&amp; <span class="built_in">color</span>, </span><br><span class="line">    <span class="built_in">int</span> thickness = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">int</span> lineType = LINE_8, </span><br><span class="line">    <span class="built_in">int</span> shift = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>第一个参数是要处理的图片<br>第二和第三个参数分别是矩形的左上角和右下角的坐标<br>第四个参数是矩形的颜色<br>第五个参数是线的粗细<br>第六个参数是线形</p><h2 id="四、RNG随机数类型"><a href="#四、RNG随机数类型" class="headerlink" title="四、RNG随机数类型"></a>四、RNG随机数类型</h2><p>RNG可以产生3种随机数：<br>RNG(int seed)使用种子seed产生一个64位随机整数，默认-1（计算机的伪随机数是由随机种子根据一定的计算方法计算出来的数值，所以只要计算方法一定，随机种子一定，那么产生的随机数就是固定的）<br>RNG::uniform()产生一个均匀分布的随机数（RNG::uniform(a, b )返回一个[a,b)范围的均匀分布的随机数，a,b的数据类型要一致，而且必须是int、float、double中的一种，默认是int）<br>RNG::gaussian( )产生一个高斯分布的随机数（返回一个均值为0，标准差为σ的随机数。如果要产生均值为λ，标准差为σ的随机数，可以λ+ RNG::gaussian( σ)）</p><h2 id="五、Mat-amp-image-Mat-param-的解释"><a href="#五、Mat-amp-image-Mat-param-的解释" class="headerlink" title="五、Mat&amp; image = (Mat) param;的解释"></a>五、Mat&amp; image = <em>(Mat</em>) param;的解释</h2><p>param是用户定义的传递到setMouseCallback()函数调用的参数,在本行代码中先将param强制转换为Mat类型指针，然后取param的值赋值给左边作为Mat类型引用的image变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为今天天气不错，所以没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动条创建和使用</title>
    <link href="http://yoursite.com/2019/03/16/OpenCV-Learning-Day-6/"/>
    <id>http://yoursite.com/2019/03/16/OpenCV-Learning-Day-6/</id>
    <published>2019-03-16T07:12:39.000Z</published>
    <updated>2019-03-26T02:37:08.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没有前言。</p><a id="more"></a><p>测试代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_nMaxAlphaValue = <span class="number">100</span>; <span class="comment">//Alpha值最大值</span></span><br><span class="line"><span class="keyword">int</span> g_nAlphaValueSlider;<span class="comment">//滑动条对应变量</span></span><br><span class="line"><span class="keyword">double</span> g_dAlphaValue;</span><br><span class="line"><span class="keyword">double</span> g_dBetaValue;</span><br><span class="line"></span><br><span class="line">Mat g_srcImage1;</span><br><span class="line">Mat g_srcImage2;</span><br><span class="line">Mat g_dstImage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_Trackbar</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Alpha和Beta值的比例</span></span><br><span class="line">    g_dAlphaValue = (<span class="keyword">double</span>) g_nAlphaValueSlider / g_nMaxAlphaValue;</span><br><span class="line">    g_dBetaValue = (<span class="number">1.0</span> - g_dAlphaValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据Alpha和Beta线性混合</span></span><br><span class="line">    addWeighted(g_srcImage1,g_dAlphaValue,g_srcImage2,g_dBetaValue,<span class="number">0</span>,g_dstImage);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"Trackbar Sample"</span>,g_dstImage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">//图像尺寸必须相同！！！</span></span><br><span class="line">    g_srcImage1 = imread(<span class="string">"Paint1.jpg"</span>);</span><br><span class="line">    g_srcImage2 = imread(<span class="string">"Paint2.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage1.data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reading image 1 failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g_srcImage2.data) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reading image 2 failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_nAlphaValueSlider = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"Trackbar Sample"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> TrakbarName[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(TrakbarName,<span class="string">"Alpha"</span>);</span><br><span class="line"></span><br><span class="line">    createTrackbar(TrakbarName,<span class="string">"Trackbar Sample"</span>,&amp;g_nAlphaValueSlider,g_nMaxAlphaValue,on_Trackbar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行时初始化界面</span></span><br><span class="line">    on_Trackbar(g_nAlphaValueSlider,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果图；<br>Alpha为0时：<br><img src="/2019/03/16/OpenCV-Learning-Day-6/1.jpg"><br>Alpha为100时：<br><img src="/2019/03/16/OpenCV-Learning-Day-6/2.jpg"></p><p>1.createTrackbar() 函数<br>函数原型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTrackbar</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">string</span>&amp; trackbarname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">string</span>&amp; winname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>* <span class="keyword">value</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count, </span></span></span><br><span class="line"><span class="function"><span class="params">    TrackbarCallback onChange=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* userdata=<span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure><br>第一个参数：轨迹条的名字<br>第二个参数：窗口的名字<br>第三个参数：int*类型的指针，指向滑块位置，创建时滑块的位置就是该变量当前的值<br>第四个参数：滑块能达到的最大位置的值<br>第五个参数：TrackbarCallback回调函数，默认为零，滑动条的每一次变化都会调用这个函数，函数原型必须是void XXX(int, void*)，第一个参数是轨迹条的位置，第二个参数是用户传给回调函数的参数，如果第三个参数是全局变量的话，完全可以不用管第六个参数。<br>需要注意的是，读取的图像尺寸必须相同，不然会报错。<br>2.getTrackbarPos()：获取滑动条的位置的值<br>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTrackbarPos</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; trackbarname, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; winname</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;没有前言。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenCV" scheme="http://yoursite.com/categories/OpenCV/"/>
    
    
  </entry>
  
</feed>
